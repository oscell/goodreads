{"ast":null,"code":"import { mergeProps as $6WsjB$mergeProps } from \"@react-aria/utils\";\nimport { useLocale as $6WsjB$useLocale } from \"@react-aria/i18n\";\nimport { useSlider as $6WsjB$useSlider, useSliderThumb as $6WsjB$useSliderThumb } from \"@react-aria/slider\";\nimport { useVisuallyHidden as $6WsjB$useVisuallyHidden } from \"@react-aria/visually-hidden\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $40af666d6c251e36$export$106b7a4e66508f66(props, state) {\n  let {\n    trackRef: trackRef,\n    inputRef: inputRef,\n    orientation: orientation,\n    channel: channel,\n    'aria-label': ariaLabel,\n    name: name\n  } = props;\n  let {\n    locale: locale,\n    direction: direction\n  } = (0, $6WsjB$useLocale)();\n  // Provide a default aria-label if there is no other label provided.\n  if (!props.label && !ariaLabel && !props['aria-labelledby']) ariaLabel = state.value.getChannelName(channel, locale);\n  // @ts-ignore - ignore unused incompatible props\n  let {\n    groupProps: groupProps,\n    trackProps: trackProps,\n    labelProps: labelProps,\n    outputProps: outputProps\n  } = (0, $6WsjB$useSlider)({\n    ...props,\n    'aria-label': ariaLabel\n  }, state, trackRef);\n  let {\n    inputProps: inputProps,\n    thumbProps: thumbProps\n  } = (0, $6WsjB$useSliderThumb)({\n    index: 0,\n    orientation: orientation,\n    isDisabled: props.isDisabled,\n    name: name,\n    trackRef: trackRef,\n    inputRef: inputRef\n  }, state);\n  let value = state.getDisplayColor();\n  let generateBackground = () => {\n    let to;\n    if (orientation === 'vertical') to = 'top';else if (direction === 'ltr') to = 'right';else to = 'left';\n    switch (channel) {\n      case 'hue':\n        {\n          let stops = [0, 60, 120, 180, 240, 300, 360].map(hue => value.withChannelValue('hue', hue).toString('css')).join(', ');\n          return `linear-gradient(to ${to}, ${stops})`;\n        }\n      case 'lightness':\n        {\n          // We have to add an extra color stop in the middle so that the hue shows up at all.\n          // Otherwise it will always just be black to white.\n          let min = state.getThumbMinValue(0);\n          let max = state.getThumbMaxValue(0);\n          let start = value.withChannelValue(channel, min).toString('css');\n          let middle = value.withChannelValue(channel, (max - min) / 2).toString('css');\n          let end = value.withChannelValue(channel, max).toString('css');\n          return `linear-gradient(to ${to}, ${start}, ${middle}, ${end})`;\n        }\n      case 'saturation':\n      case 'brightness':\n      case 'red':\n      case 'green':\n      case 'blue':\n      case 'alpha':\n        {\n          let start = value.withChannelValue(channel, state.getThumbMinValue(0)).toString('css');\n          let end = value.withChannelValue(channel, state.getThumbMaxValue(0)).toString('css');\n          return `linear-gradient(to ${to}, ${start}, ${end})`;\n        }\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  };\n  let forcedColorAdjustNoneStyle = {\n    forcedColorAdjust: 'none'\n  };\n  if (channel === 'hue') inputProps['aria-valuetext'] += `, ${value.getHueName(locale)}`;else if (channel !== 'alpha') inputProps['aria-valuetext'] += `, ${value.getColorName(locale)}`;\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = (0, $6WsjB$useVisuallyHidden)({\n    style: {\n      opacity: '0.0001',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none'\n    }\n  });\n  return {\n    trackProps: {\n      ...(0, $6WsjB$mergeProps)(groupProps, trackProps),\n      style: {\n        ...trackProps.style,\n        ...forcedColorAdjustNoneStyle,\n        background: generateBackground()\n      }\n    },\n    inputProps: {\n      ...inputProps,\n      style: {\n        ...inputProps.style,\n        ...visuallyHiddenProps.style\n      }\n    },\n    thumbProps: {\n      ...thumbProps,\n      style: {\n        ...thumbProps.style,\n        ...forcedColorAdjustNoneStyle\n      }\n    },\n    labelProps: labelProps,\n    outputProps: outputProps\n  };\n}\nexport { $40af666d6c251e36$export$106b7a4e66508f66 as useColorSlider };","map":{"version":3,"names":["$40af666d6c251e36$export$106b7a4e66508f66","props","state","trackRef","inputRef","orientation","channel","ariaLabel","name","locale","direction","$6WsjB$useLocale","label","value","getChannelName","groupProps","trackProps","labelProps","outputProps","$6WsjB$useSlider","inputProps","thumbProps","$6WsjB$useSliderThumb","index","isDisabled","getDisplayColor","generateBackground","to","stops","map","hue","withChannelValue","toString","join","min","getThumbMinValue","max","getThumbMaxValue","start","middle","end","Error","forcedColorAdjustNoneStyle","forcedColorAdjust","getHueName","getColorName","visuallyHiddenProps","$6WsjB$useVisuallyHidden","style","opacity","width","height","pointerEvents","$6WsjB$mergeProps","background"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-aria/color/dist/packages/@react-aria/color/src/useColorSlider.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaColorSliderProps} from '@react-types/color';\nimport {ColorSliderState} from '@react-stately/color';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {InputHTMLAttributes} from 'react';\nimport {mergeProps} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\nimport {useSlider, useSliderThumb} from '@react-aria/slider';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface AriaColorSliderOptions extends AriaColorSliderProps {\n  /** A ref for the track element. */\n  trackRef: RefObject<Element | null>,\n  /** A ref for the input element. */\n  inputRef: RefObject<HTMLInputElement | null>\n}\n\nexport interface ColorSliderAria {\n  /** Props for the label element. */\n  labelProps: DOMAttributes,\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n  /** Props for the thumb element. */\n  thumbProps: DOMAttributes,\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n  /** Props for the output element, displaying the value of the color slider. */\n  outputProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a color slider component.\n * Color sliders allow users to adjust an individual channel of a color value.\n */\nexport function useColorSlider(props: AriaColorSliderOptions, state: ColorSliderState): ColorSliderAria {\n  let {trackRef, inputRef, orientation, channel, 'aria-label': ariaLabel, name} = props;\n\n  let {locale, direction} = useLocale();\n\n  // Provide a default aria-label if there is no other label provided.\n  if (!props.label && !ariaLabel && !props['aria-labelledby']) {\n    ariaLabel = state.value.getChannelName(channel, locale);\n  }\n\n  // @ts-ignore - ignore unused incompatible props\n  let {groupProps, trackProps, labelProps, outputProps} = useSlider({...props, 'aria-label': ariaLabel}, state, trackRef);\n  let {inputProps, thumbProps} = useSliderThumb({\n    index: 0,\n    orientation,\n    isDisabled: props.isDisabled,\n    name,\n    trackRef,\n    inputRef\n  }, state);\n\n  let value = state.getDisplayColor();\n  let generateBackground = () => {\n    let to: string;\n    if (orientation === 'vertical') {\n      to = 'top';\n    } else if (direction === 'ltr') {\n      to = 'right';\n    } else {\n      to = 'left';\n    }\n    switch (channel) {\n      case 'hue': {\n        let stops = [0, 60, 120, 180, 240, 300, 360].map(hue => value.withChannelValue('hue', hue).toString('css')).join(', ');\n        return `linear-gradient(to ${to}, ${stops})`;\n      }\n      case 'lightness': {\n        // We have to add an extra color stop in the middle so that the hue shows up at all.\n        // Otherwise it will always just be black to white.\n        let min = state.getThumbMinValue(0);\n        let max = state.getThumbMaxValue(0);\n        let start = value.withChannelValue(channel, min).toString('css');\n        let middle = value.withChannelValue(channel, (max - min) / 2).toString('css');\n        let end = value.withChannelValue(channel, max).toString('css');\n        return `linear-gradient(to ${to}, ${start}, ${middle}, ${end})`;\n      }\n      case 'saturation':\n      case 'brightness':\n      case 'red':\n      case 'green':\n      case 'blue':\n      case 'alpha': {\n        let start = value.withChannelValue(channel, state.getThumbMinValue(0)).toString('css');\n        let end = value.withChannelValue(channel, state.getThumbMaxValue(0)).toString('css');\n        return `linear-gradient(to ${to}, ${start}, ${end})`;\n      }\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  };\n\n  let forcedColorAdjustNoneStyle = {forcedColorAdjust: 'none'};\n\n  if (channel === 'hue') {\n    inputProps['aria-valuetext'] += `, ${value.getHueName(locale)}`;\n  } else if (channel !== 'alpha') {\n    inputProps['aria-valuetext'] += `, ${value.getColorName(locale)}`;\n  }\n\n  let {visuallyHiddenProps} = useVisuallyHidden({\n    style: {\n      opacity: '0.0001',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none'\n    }\n  });\n\n  return {\n    trackProps: {\n      ...mergeProps(groupProps, trackProps),\n      style: {\n        ...trackProps.style,\n        ...forcedColorAdjustNoneStyle,\n        background: generateBackground()\n      }\n    },\n    inputProps: {\n      ...inputProps,\n      style: {\n        ...inputProps.style,\n        ...visuallyHiddenProps.style\n      }\n    },\n    thumbProps: {\n      ...thumbProps,\n      style: {\n        ...thumbProps.style,\n        ...forcedColorAdjustNoneStyle\n      }\n    },\n    labelProps,\n    outputProps\n  };\n}\n"],"mappings":";;;;;AAAA;;;;;;;;;;;;AA6CO,SAASA,0CAAeC,KAA6B,EAAEC,KAAuB;EACnF,IAAI;IAAAC,QAAA,EAACA,QAAQ;IAAAC,QAAA,EAAEA,QAAQ;IAAAC,WAAA,EAAEA,WAAW;IAAAC,OAAA,EAAEA,OAAO;IAAE,cAAcC,SAAS;IAAAC,IAAA,EAAEA;EAAI,CAAC,GAAGP,KAAA;EAEhF,IAAI;IAAAQ,MAAA,EAACA,MAAM;IAAAC,SAAA,EAAEA;EAAS,CAAC,GAAG,IAAAC,gBAAQ;EAElC;EACA,IAAI,CAACV,KAAA,CAAMW,KAAK,IAAI,CAACL,SAAA,IAAa,CAACN,KAAK,CAAC,kBAAkB,EACzDM,SAAA,GAAYL,KAAA,CAAMW,KAAK,CAACC,cAAc,CAACR,OAAA,EAASG,MAAA;EAGlD;EACA,IAAI;IAAAM,UAAA,EAACA,UAAU;IAAAC,UAAA,EAAEA,UAAU;IAAAC,UAAA,EAAEA,UAAU;IAAAC,WAAA,EAAEA;EAAW,CAAC,GAAG,IAAAC,gBAAQ,EAAE;IAAC,GAAGlB,KAAK;IAAE,cAAcM;EAAS,GAAGL,KAAA,EAAOC,QAAA;EAC9G,IAAI;IAAAiB,UAAA,EAACA,UAAU;IAAAC,UAAA,EAAEA;EAAU,CAAC,GAAG,IAAAC,qBAAa,EAAE;IAC5CC,KAAA,EAAO;iBACPlB,WAAA;IACAmB,UAAA,EAAYvB,KAAA,CAAMuB,UAAU;UAC5BhB,IAAA;cACAL,QAAA;cACAC;EACF,GAAGF,KAAA;EAEH,IAAIW,KAAA,GAAQX,KAAA,CAAMuB,eAAe;EACjC,IAAIC,kBAAA,GAAqBA,CAAA;IACvB,IAAIC,EAAA;IACJ,IAAItB,WAAA,KAAgB,YAClBsB,EAAA,GAAK,WACA,IAAIjB,SAAA,KAAc,OACvBiB,EAAA,GAAK,aAELA,EAAA,GAAK;IAEP,QAAQrB,OAAA;MACN,KAAK;QAAO;UACV,IAAIsB,KAAA,GAAQ,CAAC,GAAG,IAAI,KAAK,KAAK,KAAK,KAAK,IAAI,CAACC,GAAG,CAACC,GAAA,IAAOjB,KAAA,CAAMkB,gBAAgB,CAAC,OAAOD,GAAA,EAAKE,QAAQ,CAAC,QAAQC,IAAI,CAAC;UACjH,OAAO,sBAAsBN,EAAA,KAAOC,KAAA,GAAQ;QAC9C;MACA,KAAK;QAAa;UAChB;UACA;UACA,IAAIM,GAAA,GAAMhC,KAAA,CAAMiC,gBAAgB,CAAC;UACjC,IAAIC,GAAA,GAAMlC,KAAA,CAAMmC,gBAAgB,CAAC;UACjC,IAAIC,KAAA,GAAQzB,KAAA,CAAMkB,gBAAgB,CAACzB,OAAA,EAAS4B,GAAA,EAAKF,QAAQ,CAAC;UAC1D,IAAIO,MAAA,GAAS1B,KAAA,CAAMkB,gBAAgB,CAACzB,OAAA,EAAS,CAAC8B,GAAA,GAAMF,GAAE,IAAK,GAAGF,QAAQ,CAAC;UACvE,IAAIQ,GAAA,GAAM3B,KAAA,CAAMkB,gBAAgB,CAACzB,OAAA,EAAS8B,GAAA,EAAKJ,QAAQ,CAAC;UACxD,OAAO,sBAAsBL,EAAA,KAAOW,KAAA,KAAUC,MAAA,KAAWC,GAAA,GAAM;QACjE;MACA,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;QAAS;UACZ,IAAIF,KAAA,GAAQzB,KAAA,CAAMkB,gBAAgB,CAACzB,OAAA,EAASJ,KAAA,CAAMiC,gBAAgB,CAAC,IAAIH,QAAQ,CAAC;UAChF,IAAIQ,GAAA,GAAM3B,KAAA,CAAMkB,gBAAgB,CAACzB,OAAA,EAASJ,KAAA,CAAMmC,gBAAgB,CAAC,IAAIL,QAAQ,CAAC;UAC9E,OAAO,sBAAsBL,EAAA,KAAOW,KAAA,KAAUE,GAAA,GAAM;QACtD;MACA;QACE,MAAM,IAAIC,KAAA,CAAM,4BAA4BnC,OAAA;IAChD;EACF;EAEA,IAAIoC,0BAAA,GAA6B;IAACC,iBAAA,EAAmB;EAAM;EAE3D,IAAIrC,OAAA,KAAY,OACdc,UAAU,CAAC,iBAAiB,IAAI,KAAKP,KAAA,CAAM+B,UAAU,CAACnC,MAAA,GAAS,MAC1D,IAAIH,OAAA,KAAY,SACrBc,UAAU,CAAC,iBAAiB,IAAI,KAAKP,KAAA,CAAMgC,YAAY,CAACpC,MAAA,GAAS;EAGnE,IAAI;IAAAqC,mBAAA,EAACA;EAAmB,CAAC,GAAG,IAAAC,wBAAgB,EAAE;IAC5CC,KAAA,EAAO;MACLC,OAAA,EAAS;MACTC,KAAA,EAAO;MACPC,MAAA,EAAQ;MACRC,aAAA,EAAe;IACjB;EACF;EAEA,OAAO;IACLpC,UAAA,EAAY;MACV,GAAG,IAAAqC,iBAAS,EAAEtC,UAAA,EAAYC,UAAA,CAAW;MACrCgC,KAAA,EAAO;QACL,GAAGhC,UAAA,CAAWgC,KAAK;QACnB,GAAGN,0BAA0B;QAC7BY,UAAA,EAAY5B,kBAAA;MACd;IACF;IACAN,UAAA,EAAY;MACV,GAAGA,UAAU;MACb4B,KAAA,EAAO;QACL,GAAG5B,UAAA,CAAW4B,KAAK;QACnB,GAAGF,mBAAA,CAAoBE;MACzB;IACF;IACA3B,UAAA,EAAY;MACV,GAAGA,UAAU;MACb2B,KAAA,EAAO;QACL,GAAG3B,UAAA,CAAW2B,KAAK;QACnB,GAAGN;MACL;IACF;gBACAzB,UAAA;iBACAC;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}