{"ast":null,"code":"import { parseColor as $799cddbef784668f$export$6e865ea70d7724f } from \"./Color.mjs\";\nimport { useColor as $aa90ad8b2b1d015f$export$5aadd9c0606af5c2 } from \"./useColor.mjs\";\nimport { useFormValidationState as $aP5W6$useFormValidationState } from \"@react-stately/form\";\nimport { useControlledState as $aP5W6$useControlledState } from \"@react-stately/utils\";\nimport { useState as $aP5W6$useState, useMemo as $aP5W6$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $b335ada08155d9c0$var$MIN_COLOR = (0, $799cddbef784668f$export$6e865ea70d7724f)('#000000');\nconst $b335ada08155d9c0$var$MAX_COLOR = (0, $799cddbef784668f$export$6e865ea70d7724f)('#FFFFFF');\nconst $b335ada08155d9c0$var$MIN_COLOR_INT = $b335ada08155d9c0$var$MIN_COLOR.toHexInt();\nconst $b335ada08155d9c0$var$MAX_COLOR_INT = $b335ada08155d9c0$var$MAX_COLOR.toHexInt();\nfunction $b335ada08155d9c0$export$d52a01683abdfcd6(props) {\n  let {\n    value: value,\n    defaultValue: defaultValue,\n    onChange: onChange\n  } = props;\n  let {\n    step: step\n  } = $b335ada08155d9c0$var$MIN_COLOR.getChannelRange('red');\n  let initialValue = (0, $aa90ad8b2b1d015f$export$5aadd9c0606af5c2)(value);\n  let initialDefaultValue = (0, $aa90ad8b2b1d015f$export$5aadd9c0606af5c2)(defaultValue);\n  let [colorValue, setColorValue] = (0, $aP5W6$useControlledState)(initialValue, initialDefaultValue, onChange);\n  let [inputValue, setInputValue] = (0, $aP5W6$useState)(() => (value || defaultValue) && colorValue ? colorValue.toString('hex') : '');\n  let validation = (0, $aP5W6$useFormValidationState)({\n    ...props,\n    value: colorValue\n  });\n  let safelySetColorValue = newColor => {\n    if (!colorValue || !newColor) {\n      setColorValue(newColor);\n      return;\n    }\n    if (newColor.toHexInt() !== colorValue.toHexInt()) {\n      setColorValue(newColor);\n      return;\n    }\n  };\n  let [prevValue, setPrevValue] = (0, $aP5W6$useState)(colorValue);\n  if (prevValue !== colorValue) {\n    setInputValue(colorValue ? colorValue.toString('hex') : '');\n    setPrevValue(colorValue);\n  }\n  let parsedValue = (0, $aP5W6$useMemo)(() => {\n    let color;\n    try {\n      color = (0, $799cddbef784668f$export$6e865ea70d7724f)(inputValue.startsWith('#') ? inputValue : `#${inputValue}`);\n    } catch (err) {\n      color = null;\n    }\n    return color;\n  }, [inputValue]);\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      safelySetColorValue(null);\n      if (value === undefined || colorValue === null) setInputValue('');else setInputValue(colorValue.toString('hex'));\n      return;\n    }\n    // if it failed to parse, then reset input to formatted version of current number\n    if (parsedValue == null) {\n      setInputValue(colorValue ? colorValue.toString('hex') : '');\n      return;\n    }\n    safelySetColorValue(parsedValue);\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    let newColorValue = '';\n    if (colorValue) newColorValue = colorValue.toString('hex');\n    setInputValue(newColorValue);\n  };\n  let increment = () => {\n    let newValue = $b335ada08155d9c0$var$addColorValue(parsedValue, step);\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === colorValue) setInputValue(newValue.toString('hex'));\n    safelySetColorValue(newValue);\n    validation.commitValidation();\n  };\n  let decrement = () => {\n    let newValue = $b335ada08155d9c0$var$addColorValue(parsedValue, -step);\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === colorValue) setInputValue(newValue.toString('hex'));\n    safelySetColorValue(newValue);\n    validation.commitValidation();\n  };\n  let incrementToMax = () => safelySetColorValue($b335ada08155d9c0$var$MAX_COLOR);\n  let decrementToMin = () => safelySetColorValue($b335ada08155d9c0$var$MIN_COLOR);\n  let validate = value => {\n    var _value_match;\n    return value === '' || !!((_value_match = value.match(/^#?[0-9a-f]{0,6}$/i)) === null || _value_match === void 0 ? void 0 : _value_match[0]);\n  };\n  return {\n    ...validation,\n    validate: validate,\n    colorValue: colorValue,\n    inputValue: inputValue,\n    setInputValue: setInputValue,\n    commit: commit,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin\n  };\n}\nfunction $b335ada08155d9c0$var$addColorValue(color, step) {\n  let newColor = color ? color : $b335ada08155d9c0$var$MIN_COLOR;\n  let colorInt = newColor.toHexInt();\n  let clampInt = Math.min(Math.max(colorInt + step, $b335ada08155d9c0$var$MIN_COLOR_INT), $b335ada08155d9c0$var$MAX_COLOR_INT);\n  if (clampInt !== colorInt) {\n    let newColorString = `#${clampInt.toString(16).padStart(6, '0').toUpperCase()}`;\n    newColor = (0, $799cddbef784668f$export$6e865ea70d7724f)(newColorString);\n  }\n  return newColor;\n}\nexport { $b335ada08155d9c0$export$d52a01683abdfcd6 as useColorFieldState };","map":{"version":3,"names":["$b335ada08155d9c0$var$MIN_COLOR","$799cddbef784668f$export$6e865ea70d7724f","$b335ada08155d9c0$var$MAX_COLOR","$b335ada08155d9c0$var$MIN_COLOR_INT","toHexInt","$b335ada08155d9c0$var$MAX_COLOR_INT","$b335ada08155d9c0$export$d52a01683abdfcd6","props","value","defaultValue","onChange","step","getChannelRange","initialValue","$aa90ad8b2b1d015f$export$5aadd9c0606af5c2","initialDefaultValue","colorValue","setColorValue","$aP5W6$useControlledState","inputValue","setInputValue","$aP5W6$useState","toString","validation","$aP5W6$useFormValidationState","safelySetColorValue","newColor","prevValue","setPrevValue","parsedValue","$aP5W6$useMemo","color","startsWith","err","commit","length","undefined","newColorValue","increment","newValue","$b335ada08155d9c0$var$addColorValue","commitValidation","decrement","incrementToMax","decrementToMin","validate","_value_match","match","colorInt","clampInt","Math","min","max","newColorString","padStart","toUpperCase"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-stately/color/dist/packages/@react-stately/color/src/useColorFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Color, ColorFieldProps} from '@react-types/color';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {parseColor} from './Color';\nimport {useColor} from './useColor';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\n\nexport interface ColorFieldState extends FormValidationState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  readonly inputValue: string,\n  /**\n   * The currently parsed color value, or null if the field is empty.\n   * Updated based on the `inputValue` as the user types.\n   */\n  readonly colorValue: Color | null,\n  /** Sets the current text value of the input. */\n  setInputValue(value: string): void,\n  /**\n   * Updates the input value based on the currently parsed color value.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the maximum color value, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the minimum color value, and fires `onChange`. */\n  decrementToMin(): void,\n  /**\n   * Validates a user input string.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a color.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean\n}\n\nconst MIN_COLOR = parseColor('#000000');\nconst MAX_COLOR = parseColor('#FFFFFF');\nconst MIN_COLOR_INT = MIN_COLOR.toHexInt();\nconst MAX_COLOR_INT = MAX_COLOR.toHexInt();\n\n/**\n * Provides state management for a color field component. Color fields allow\n * users to enter and adjust a hex color value.\n */\nexport function useColorFieldState(\n  props: ColorFieldProps\n): ColorFieldState {\n  let {\n    value,\n    defaultValue,\n    onChange\n  } = props;\n  let {step} = MIN_COLOR.getChannelRange('red');\n\n  let initialValue = useColor(value);\n  let initialDefaultValue = useColor(defaultValue);\n  let [colorValue, setColorValue] = useControlledState<Color | null>(initialValue!, initialDefaultValue!, onChange);\n  let [inputValue, setInputValue] = useState(() => (value || defaultValue) && colorValue ? colorValue.toString('hex') : '');\n\n  let validation = useFormValidationState({\n    ...props,\n    value: colorValue\n  });\n\n  let safelySetColorValue = (newColor: Color | null) => {\n    if (!colorValue || !newColor) {\n      setColorValue(newColor);\n      return;\n    }\n    if (newColor.toHexInt() !== colorValue.toHexInt()) {\n      setColorValue(newColor);\n      return;\n    }\n  };\n\n  let [prevValue, setPrevValue] = useState(colorValue);\n  if (prevValue !== colorValue) {\n    setInputValue(colorValue ? colorValue.toString('hex') : '');\n    setPrevValue(colorValue);\n  }\n\n  let parsedValue = useMemo(() => {\n    let color;\n    try {\n      color = parseColor(inputValue.startsWith('#') ? inputValue : `#${inputValue}`);\n    } catch (err) {\n      color = null;\n    }\n    return color;\n  }, [inputValue]);\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      safelySetColorValue(null);\n      if (value === undefined || colorValue === null) {\n        setInputValue('');\n      } else {\n        setInputValue(colorValue.toString('hex'));\n      }\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (parsedValue == null) {\n      setInputValue(colorValue ? colorValue.toString('hex') : '');\n      return;\n    }\n\n    safelySetColorValue(parsedValue);\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    let newColorValue = '';\n    if (colorValue) {\n      newColorValue = colorValue.toString('hex');\n    }\n    setInputValue(newColorValue);\n  };\n\n  let increment = () => {\n    let newValue = addColorValue(parsedValue, step);\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === colorValue) {\n      setInputValue(newValue.toString('hex'));\n    }\n    safelySetColorValue(newValue);\n    validation.commitValidation();\n  };\n  let decrement = () => {\n    let newValue = addColorValue(parsedValue, -step);\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === colorValue) {\n      setInputValue(newValue.toString('hex'));\n    }\n    safelySetColorValue(newValue);\n    validation.commitValidation();\n  };\n  let incrementToMax = () => safelySetColorValue(MAX_COLOR);\n  let decrementToMin = () => safelySetColorValue(MIN_COLOR);\n\n  let validate = (value: string) => value === '' || !!value.match(/^#?[0-9a-f]{0,6}$/i)?.[0];\n\n  return {\n    ...validation,\n    validate,\n    colorValue,\n    inputValue,\n    setInputValue,\n    commit,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin\n  };\n}\n\nfunction addColorValue(color: Color, step: number) {\n  let newColor = color ? color : MIN_COLOR;\n  let colorInt = newColor.toHexInt();\n\n  let clampInt = Math.min(Math.max(colorInt + step, MIN_COLOR_INT), MAX_COLOR_INT);\n  if (clampInt !== colorInt) {\n    let newColorString = `#${clampInt.toString(16).padStart(6, '0').toUpperCase()}`;\n    newColor = parseColor(newColorString);\n  }\n  return newColor;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}