{"ast":null,"code":"import { normalizeColor as $799cddbef784668f$export$4cde5df63f53f473, parseColor as $799cddbef784668f$export$6e865ea70d7724f } from \"./Color.mjs\";\nimport { useControlledState as $5ShDH$useControlledState, clamp as $5ShDH$clamp, snapValueToStep as $5ShDH$snapValueToStep } from \"@react-stately/utils\";\nimport { useMemo as $5ShDH$useMemo, useRef as $5ShDH$useRef, useState as $5ShDH$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $6e14a98a7f67141d$var$DEFAULT_COLOR = (0, $799cddbef784668f$export$6e865ea70d7724f)('#ffffff');\nfunction $6e14a98a7f67141d$export$6df7f0e2cabc7eef(props) {\n  let {\n    value: value,\n    defaultValue: defaultValue,\n    colorSpace: colorSpace,\n    xChannel: xChannel,\n    yChannel: yChannel,\n    onChange: onChange,\n    onChangeEnd: onChangeEnd\n  } = props;\n  if (!value && !defaultValue) defaultValue = $6e14a98a7f67141d$var$DEFAULT_COLOR;\n  if (value) value = (0, $799cddbef784668f$export$4cde5df63f53f473)(value);\n  if (defaultValue) defaultValue = (0, $799cddbef784668f$export$4cde5df63f53f473)(defaultValue);\n  // safe to cast value and defaultValue to Color, one of them will always be defined because if neither are, we assign a default\n  let [colorValue, setColorState] = (0, $5ShDH$useControlledState)(value, defaultValue, onChange);\n  let color = (0, $5ShDH$useMemo)(() => colorSpace && colorValue ? colorValue.toFormat(colorSpace) : colorValue, [colorValue, colorSpace]);\n  let valueRef = (0, $5ShDH$useRef)(color);\n  let setColor = color => {\n    valueRef.current = color;\n    setColorState(color);\n  };\n  let channels = (0, $5ShDH$useMemo)(() => color.getColorSpaceAxes({\n    xChannel: xChannel,\n    yChannel: yChannel\n  }), [color, xChannel, yChannel]);\n  let xChannelRange = color.getChannelRange(channels.xChannel);\n  let yChannelRange = color.getChannelRange(channels.yChannel);\n  let {\n    minValue: minValueX,\n    maxValue: maxValueX,\n    step: stepX,\n    pageSize: pageSizeX\n  } = xChannelRange;\n  let {\n    minValue: minValueY,\n    maxValue: maxValueY,\n    step: stepY,\n    pageSize: pageSizeY\n  } = yChannelRange;\n  let [isDragging, setDragging] = (0, $5ShDH$useState)(false);\n  let isDraggingRef = (0, $5ShDH$useRef)(false);\n  let xValue = color.getChannelValue(channels.xChannel);\n  let yValue = color.getChannelValue(channels.yChannel);\n  let setXValue = v => {\n    if (v === xValue) return;\n    let newColor = color.withChannelValue(channels.xChannel, v);\n    setColor(newColor);\n  };\n  let setYValue = v => {\n    if (v === yValue) return;\n    let newColor = color.withChannelValue(channels.yChannel, v);\n    setColor(newColor);\n  };\n  return {\n    channels: channels,\n    xChannelStep: stepX,\n    yChannelStep: stepY,\n    xChannelPageStep: pageSizeX,\n    yChannelPageStep: pageSizeY,\n    value: color,\n    setValue(value) {\n      setColor((0, $799cddbef784668f$export$4cde5df63f53f473)(value));\n    },\n    xValue: xValue,\n    setXValue: setXValue,\n    yValue: yValue,\n    setYValue: setYValue,\n    setColorFromPoint(x, y) {\n      let newXValue = minValueX + (0, $5ShDH$clamp)(x, 0, 1) * (maxValueX - minValueX);\n      let newYValue = minValueY + (1 - (0, $5ShDH$clamp)(y, 0, 1)) * (maxValueY - minValueY);\n      let newColor;\n      if (newXValue !== xValue) {\n        // Round new value to multiple of step, clamp value between min and max\n        newXValue = (0, $5ShDH$snapValueToStep)(newXValue, minValueX, maxValueX, stepX);\n        newColor = color.withChannelValue(channels.xChannel, newXValue);\n      }\n      if (newYValue !== yValue) {\n        // Round new value to multiple of step, clamp value between min and max\n        newYValue = (0, $5ShDH$snapValueToStep)(newYValue, minValueY, maxValueY, stepY);\n        newColor = (newColor || color).withChannelValue(channels.yChannel, newYValue);\n      }\n      if (newColor) setColor(newColor);\n    },\n    getThumbPosition() {\n      let x = (xValue - minValueX) / (maxValueX - minValueX);\n      let y = 1 - (yValue - minValueY) / (maxValueY - minValueY);\n      return {\n        x: x,\n        y: y\n      };\n    },\n    incrementX(stepSize = 1) {\n      setXValue(xValue + stepSize > maxValueX ? maxValueX : (0, $5ShDH$snapValueToStep)(xValue + stepSize, minValueX, maxValueX, stepX));\n    },\n    incrementY(stepSize = 1) {\n      setYValue(yValue + stepSize > maxValueY ? maxValueY : (0, $5ShDH$snapValueToStep)(yValue + stepSize, minValueY, maxValueY, stepY));\n    },\n    decrementX(stepSize = 1) {\n      setXValue((0, $5ShDH$snapValueToStep)(xValue - stepSize, minValueX, maxValueX, stepX));\n    },\n    decrementY(stepSize = 1) {\n      setYValue((0, $5ShDH$snapValueToStep)(yValue - stepSize, minValueY, maxValueY, stepY));\n    },\n    setDragging(isDragging) {\n      let wasDragging = isDraggingRef.current;\n      isDraggingRef.current = isDragging;\n      if (onChangeEnd && !isDragging && wasDragging) onChangeEnd(valueRef.current);\n      setDragging(isDragging);\n    },\n    isDragging: isDragging,\n    getDisplayColor() {\n      return color.withChannelValue('alpha', 1);\n    }\n  };\n}\nexport { $6e14a98a7f67141d$export$6df7f0e2cabc7eef as useColorAreaState };","map":{"version":3,"names":["$6e14a98a7f67141d$var$DEFAULT_COLOR","$799cddbef784668f$export$6e865ea70d7724f","$6e14a98a7f67141d$export$6df7f0e2cabc7eef","props","value","defaultValue","colorSpace","xChannel","yChannel","onChange","onChangeEnd","$799cddbef784668f$export$4cde5df63f53f473","colorValue","setColorState","$5ShDH$useControlledState","color","$5ShDH$useMemo","toFormat","valueRef","$5ShDH$useRef","setColor","current","channels","getColorSpaceAxes","xChannelRange","getChannelRange","yChannelRange","minValue","minValueX","maxValue","maxValueX","step","stepX","pageSize","pageSizeX","minValueY","maxValueY","stepY","pageSizeY","isDragging","setDragging","$5ShDH$useState","isDraggingRef","xValue","getChannelValue","yValue","setXValue","v","newColor","withChannelValue","setYValue","xChannelStep","yChannelStep","xChannelPageStep","yChannelPageStep","setValue","setColorFromPoint","x","y","newXValue","$5ShDH$clamp","newYValue","$5ShDH$snapValueToStep","getThumbPosition","incrementX","stepSize","incrementY","decrementX","decrementY","wasDragging","getDisplayColor"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/color/dist/packages/@react-stately/color/src/useColorAreaState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {Color, ColorAreaProps, ColorChannel} from '@react-types/color';\nimport {normalizeColor, parseColor} from './Color';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface ColorAreaState {\n  /** The current color value displayed by the color area. */\n  readonly value: Color,\n  /** Sets the current color value. If a string is passed, it will be parsed to a Color. */\n  setValue(value: string | Color): void,\n\n  /** The current value of the horizontal axis channel displayed by the color area. */\n  xValue: number,\n  /** Sets the value for the horizontal axis channel displayed by the color area, and triggers `onChange`. */\n  setXValue(value: number): void,\n\n  /** The current value of the vertical axis channel displayed by the color area. */\n  yValue: number,\n  /** Sets the value for the vertical axis channel displayed by the color area, and triggers `onChange`. */\n  setYValue(value: number): void,\n\n  /** Sets the x and y channels of the current color value based on a percentage of the width and height of the color area, and triggers `onChange`. */\n  setColorFromPoint(x: number, y: number): void,\n  /** Returns the coordinates of the thumb relative to the upper left corner of the color area as a percentage. */\n  getThumbPosition(): {x: number, y: number},\n\n  /** Increments the value of the horizontal axis channel by the channel step or page amount. */\n  incrementX(stepSize?: number): void,\n  /** Decrements the value of the horizontal axis channel by the channel step or page amount. */\n  decrementX(stepSize?: number): void,\n\n  /** Increments the value of the vertical axis channel by the channel step or page amount. */\n  incrementY(stepSize?: number): void,\n  /** Decrements the value of the vertical axis channel by the channel step or page amount. */\n  decrementY(stepSize?: number): void,\n\n  /** Whether the color area is currently being dragged. */\n  readonly isDragging: boolean,\n  /** Sets whether the color area is being dragged. */\n  setDragging(value: boolean): void,\n\n  /** Returns the xChannel, yChannel and zChannel names based on the color value. */\n  channels: {xChannel: ColorChannel, yChannel: ColorChannel, zChannel: ColorChannel},\n  /** The step value of the xChannel, used when incrementing and decrementing. */\n  xChannelStep: number,\n  /** The step value of the yChannel, used when incrementing and decrementing. */\n  yChannelStep: number,\n  /** The page step value of the xChannel, used when incrementing and decrementing. */\n  xChannelPageStep: number,\n  /** The page step value of the yChannel, used when incrementing and decrementing. */\n  yChannelPageStep: number,\n\n  /** Returns the color that should be displayed in the color area thumb instead of `value`. */\n  getDisplayColor(): Color\n}\n\nconst DEFAULT_COLOR = parseColor('#ffffff');\n/**\n * Provides state management for a color area component.\n * Color area allows users to adjust two channels of an HSL, HSB or RGB color value against a two-dimensional gradient background.\n */\nexport function useColorAreaState(props: ColorAreaProps): ColorAreaState {\n  let {\n    value,\n    defaultValue,\n    colorSpace,\n    xChannel,\n    yChannel,\n    onChange,\n    onChangeEnd\n  } = props;\n\n  if (!value && !defaultValue) {\n    defaultValue = DEFAULT_COLOR;\n  }\n  if (value) {\n    value = normalizeColor(value);\n  }\n  if (defaultValue) {\n    defaultValue = normalizeColor(defaultValue);\n  }\n\n  // safe to cast value and defaultValue to Color, one of them will always be defined because if neither are, we assign a default\n  let [colorValue, setColorState] = useControlledState<Color>(value as Color, defaultValue as Color, onChange);\n  let color = useMemo(() => colorSpace && colorValue ? colorValue.toFormat(colorSpace) : colorValue, [colorValue, colorSpace]);\n  let valueRef = useRef(color);\n  let setColor = (color: Color) => {\n    valueRef.current = color;\n    setColorState(color);\n  };\n\n  let channels = useMemo(() =>\n    color.getColorSpaceAxes({xChannel, yChannel}),\n    [color, xChannel, yChannel]\n  );\n\n  let xChannelRange = color.getChannelRange(channels.xChannel);\n  let yChannelRange = color.getChannelRange(channels.yChannel);\n  let {minValue: minValueX, maxValue: maxValueX, step: stepX, pageSize: pageSizeX} = xChannelRange;\n  let {minValue: minValueY, maxValue: maxValueY, step: stepY, pageSize: pageSizeY} = yChannelRange;\n\n  let [isDragging, setDragging] = useState(false);\n  let isDraggingRef = useRef(false);\n\n  let xValue = color.getChannelValue(channels.xChannel);\n  let yValue = color.getChannelValue(channels.yChannel);\n  let setXValue = (v: number) => {\n    if (v === xValue) {\n      return;\n    }\n    let newColor = color.withChannelValue(channels.xChannel, v);\n    setColor(newColor);\n  };\n  let setYValue = (v: number) => {\n    if (v === yValue) {\n      return;\n    }\n    let newColor = color.withChannelValue(channels.yChannel, v);\n    setColor(newColor);\n  };\n\n  return {\n    channels,\n    xChannelStep: stepX,\n    yChannelStep: stepY,\n    xChannelPageStep: pageSizeX,\n    yChannelPageStep: pageSizeY,\n    value: color,\n    setValue(value) {\n      setColor(normalizeColor(value));\n    },\n    xValue,\n    setXValue,\n    yValue,\n    setYValue,\n    setColorFromPoint(x: number, y: number) {\n      let newXValue = minValueX + clamp(x, 0, 1) * (maxValueX - minValueX);\n      let newYValue = minValueY + (1 - clamp(y, 0, 1)) * (maxValueY - minValueY);\n      let newColor: Color | undefined;\n      if (newXValue !== xValue) {\n        // Round new value to multiple of step, clamp value between min and max\n        newXValue = snapValueToStep(newXValue, minValueX, maxValueX, stepX);\n        newColor = color.withChannelValue(channels.xChannel, newXValue);\n      }\n      if (newYValue !== yValue) {\n        // Round new value to multiple of step, clamp value between min and max\n        newYValue = snapValueToStep(newYValue, minValueY, maxValueY, stepY);\n        newColor = (newColor || color).withChannelValue(channels.yChannel, newYValue);\n      }\n      if (newColor) {\n        setColor(newColor);\n      }\n    },\n    getThumbPosition() {\n      let x = (xValue - minValueX) / (maxValueX - minValueX);\n      let y = 1 - (yValue - minValueY) / (maxValueY - minValueY);\n      return {x, y};\n    },\n    incrementX(stepSize = 1) {\n      setXValue(xValue + stepSize > maxValueX ? maxValueX : snapValueToStep(xValue + stepSize, minValueX, maxValueX, stepX));\n    },\n    incrementY(stepSize = 1) {\n      setYValue(yValue + stepSize > maxValueY ? maxValueY : snapValueToStep(yValue + stepSize, minValueY, maxValueY, stepY));\n    },\n    decrementX(stepSize = 1) {\n      setXValue(snapValueToStep(xValue - stepSize, minValueX, maxValueX, stepX));\n    },\n    decrementY(stepSize = 1) {\n      setYValue(snapValueToStep(yValue - stepSize, minValueY, maxValueY, stepY));\n    },\n    setDragging(isDragging) {\n      let wasDragging = isDraggingRef.current;\n      isDraggingRef.current = isDragging;\n\n      if (onChangeEnd && !isDragging && wasDragging) {\n        onChangeEnd(valueRef.current);\n      }\n\n      setDragging(isDragging);\n    },\n    isDragging,\n    getDisplayColor() {\n      return color.withChannelValue('alpha', 1);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}