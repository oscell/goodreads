{"ast":null,"code":"class $3ca85212bf8898e4$export$fbd65d14c79e28cc {\n  getPrimaryStart(rect) {\n    return this.orientation === 'horizontal' ? rect.left : rect.top;\n  }\n  getPrimaryEnd(rect) {\n    return this.orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n  getSecondaryStart(rect) {\n    return this.orientation === 'horizontal' ? rect.top : rect.left;\n  }\n  getSecondaryEnd(rect) {\n    return this.orientation === 'horizontal' ? rect.bottom : rect.right;\n  }\n  getFlowStart(rect) {\n    return this.layout === 'stack' ? this.getPrimaryStart(rect) : this.getSecondaryStart(rect);\n  }\n  getFlowEnd(rect) {\n    return this.layout === 'stack' ? this.getPrimaryEnd(rect) : this.getSecondaryEnd(rect);\n  }\n  getFlowSize(rect) {\n    return this.getFlowEnd(rect) - this.getFlowStart(rect);\n  }\n  getDropTargetFromPoint(x, y, isValidDropTarget) {\n    if (this.collection[Symbol.iterator]().next().done) return {\n      type: 'root'\n    };\n    let rect = this.ref.current.getBoundingClientRect();\n    let primary = this.orientation === 'horizontal' ? x : y;\n    let secondary = this.orientation === 'horizontal' ? y : x;\n    primary += this.getPrimaryStart(rect);\n    secondary += this.getSecondaryStart(rect);\n    let flow = this.layout === 'stack' ? primary : secondary;\n    let isPrimaryRTL = this.orientation === 'horizontal' && this.direction === 'rtl';\n    let isSecondaryRTL = this.layout === 'grid' && this.orientation === 'vertical' && this.direction === 'rtl';\n    let isFlowRTL = this.layout === 'stack' ? isPrimaryRTL : isSecondaryRTL;\n    let elements = this.ref.current.querySelectorAll('[data-key]');\n    let elementMap = new Map();\n    for (let item of elements) if (item instanceof HTMLElement) elementMap.set(item.dataset.key, item);\n    // TODO: assume that only item type items are valid drop targets. This is to prevent a crash when dragging over the loader\n    // row since it doesn't have a data-key set on it. Will eventually need to handle the case with drag and drop and loaders located between rows aka tree.\n    // Can see https://github.com/adobe/react-spectrum/pull/4210/files#diff-21e555e0c597a28215e36137f5be076a65a1e1456c92cd0fdd60f866929aae2a for additional logic\n    // that may need to happen then\n    let items = [...this.collection].filter(item => item.type === 'item');\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      let item = items[mid];\n      let element = elementMap.get(String(item.key));\n      let rect = element.getBoundingClientRect();\n      let update = isGreater => {\n        if (isGreater) low = mid + 1;else high = mid;\n      };\n      if (primary < this.getPrimaryStart(rect)) update(isPrimaryRTL);else if (primary > this.getPrimaryEnd(rect)) update(!isPrimaryRTL);else if (secondary < this.getSecondaryStart(rect)) update(isSecondaryRTL);else if (secondary > this.getSecondaryEnd(rect)) update(!isSecondaryRTL);else {\n        let target = {\n          type: 'item',\n          key: item.key,\n          dropPosition: 'on'\n        };\n        if (isValidDropTarget(target)) {\n          // Otherwise, if dropping on the item is accepted, try the before/after positions if within 5px\n          // of the start or end of the item.\n          if (flow <= this.getFlowStart(rect) + 5 && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n          })) target.dropPosition = isFlowRTL ? 'after' : 'before';else if (flow >= this.getFlowEnd(rect) - 5 && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n          })) target.dropPosition = isFlowRTL ? 'before' : 'after';\n        } else {\n          // If dropping on the item isn't accepted, try the target before or after depending on the position.\n          let mid = this.getFlowStart(rect) + this.getFlowSize(rect) / 2;\n          if (flow <= mid && isValidDropTarget({\n            ...target,\n            dropPosition: 'before'\n          })) target.dropPosition = isFlowRTL ? 'after' : 'before';else if (flow >= mid && isValidDropTarget({\n            ...target,\n            dropPosition: 'after'\n          })) target.dropPosition = isFlowRTL ? 'before' : 'after';\n        }\n        return target;\n      }\n    }\n    let item = items[Math.min(low, items.length - 1)];\n    let element = elementMap.get(String(item.key));\n    rect = element.getBoundingClientRect();\n    if (primary < this.getPrimaryStart(rect) || Math.abs(flow - this.getFlowStart(rect)) < Math.abs(flow - this.getFlowEnd(rect))) return {\n      type: 'item',\n      key: item.key,\n      dropPosition: isFlowRTL ? 'after' : 'before'\n    };\n    return {\n      type: 'item',\n      key: item.key,\n      dropPosition: isFlowRTL ? 'before' : 'after'\n    };\n  }\n  constructor(collection, ref, options) {\n    this.collection = collection;\n    this.ref = ref;\n    this.layout = (options === null || options === void 0 ? void 0 : options.layout) || 'stack';\n    this.orientation = (options === null || options === void 0 ? void 0 : options.orientation) || 'vertical';\n    this.direction = (options === null || options === void 0 ? void 0 : options.direction) || 'ltr';\n  }\n}\nexport { $3ca85212bf8898e4$export$fbd65d14c79e28cc as ListDropTargetDelegate };","map":{"version":3,"names":["$3ca85212bf8898e4$export$fbd65d14c79e28cc","getPrimaryStart","rect","orientation","left","top","getPrimaryEnd","right","bottom","getSecondaryStart","getSecondaryEnd","getFlowStart","layout","getFlowEnd","getFlowSize","getDropTargetFromPoint","x","y","isValidDropTarget","collection","Symbol","iterator","next","done","type","ref","current","getBoundingClientRect","primary","secondary","flow","isPrimaryRTL","direction","isSecondaryRTL","isFlowRTL","elements","querySelectorAll","elementMap","Map","item","HTMLElement","set","dataset","key","items","filter","low","high","length","mid","Math","floor","element","get","String","update","isGreater","target","dropPosition","min","abs","constructor","options"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-aria/dnd/dist/packages/@react-aria/dnd/src/ListDropTargetDelegate.ts"],"sourcesContent":["import {Direction, DropTarget, DropTargetDelegate, Node, Orientation, RefObject} from '@react-types/shared';\n\ninterface ListDropTargetDelegateOptions {\n  /**\n   * Whether the items are arranged in a stack or grid.\n   * @default 'stack'\n   */\n  layout?: 'stack' | 'grid',\n  /**\n   * The primary orientation of the items. Usually this is the\n   * direction that the collection scrolls.\n   * @default 'vertical'\n   */\n  orientation?: Orientation,\n  /**\n   * The horizontal layout direction.\n   * @default 'ltr'\n   */\n  direction?: Direction\n}\n\n// Terms used in the below code:\n//   * \"Primary\"   – The main layout direction. For stacks, this is the direction\n//                   that the stack is arranged in (e.g. horizontal or vertical).\n//                   For grids, this is the main scroll direction.\n//   * \"Secondary\" – The secondary layout direction. For stacks, there is no secondary\n//                   layout direction. For grids, this is the opposite of the primary direction.\n//   * \"Flow\"      – The flow direction of the items. For stacks, this is the the primary\n//                   direction. For grids, it is the secondary direction.\n\nexport class ListDropTargetDelegate implements DropTargetDelegate {\n  private collection: Iterable<Node<unknown>>;\n  private ref: RefObject<HTMLElement | null>;\n  private layout: 'stack' | 'grid';\n  private orientation: Orientation;\n  private direction: Direction;\n\n  constructor(collection: Iterable<Node<unknown>>, ref: RefObject<HTMLElement | null>, options?: ListDropTargetDelegateOptions) {\n    this.collection = collection;\n    this.ref = ref;\n    this.layout = options?.layout || 'stack';\n    this.orientation = options?.orientation || 'vertical';\n    this.direction = options?.direction || 'ltr';\n  }\n\n  private getPrimaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.left : rect.top;\n  }\n\n  private getPrimaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n\n  private getSecondaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.top : rect.left;\n  }\n\n  private getSecondaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.bottom : rect.right;\n  }\n\n  private getFlowStart(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryStart(rect) : this.getSecondaryStart(rect);\n  }\n\n  private getFlowEnd(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryEnd(rect) : this.getSecondaryEnd(rect);\n  }\n\n  private getFlowSize(rect: DOMRect) {\n    return this.getFlowEnd(rect) - this.getFlowStart(rect);\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.collection[Symbol.iterator]().next().done) {\n      return {type: 'root'};\n    }\n\n    let rect = this.ref.current.getBoundingClientRect();\n    let primary = this.orientation === 'horizontal' ? x : y;\n    let secondary = this.orientation === 'horizontal' ? y : x;\n    primary += this.getPrimaryStart(rect);\n    secondary += this.getSecondaryStart(rect);\n\n    let flow = this.layout === 'stack' ? primary : secondary;\n    let isPrimaryRTL = this.orientation === 'horizontal' && this.direction === 'rtl';\n    let isSecondaryRTL = this.layout === 'grid' && this.orientation === 'vertical' && this.direction === 'rtl';\n    let isFlowRTL = this.layout === 'stack' ? isPrimaryRTL : isSecondaryRTL;\n\n    let elements = this.ref.current.querySelectorAll('[data-key]');\n    let elementMap = new Map<string, HTMLElement>();\n    for (let item of elements) {\n      if (item instanceof HTMLElement) {\n        elementMap.set(item.dataset.key, item);\n      }\n    }\n\n    // TODO: assume that only item type items are valid drop targets. This is to prevent a crash when dragging over the loader\n    // row since it doesn't have a data-key set on it. Will eventually need to handle the case with drag and drop and loaders located between rows aka tree.\n    // Can see https://github.com/adobe/react-spectrum/pull/4210/files#diff-21e555e0c597a28215e36137f5be076a65a1e1456c92cd0fdd60f866929aae2a for additional logic\n    // that may need to happen then\n    let items = [...this.collection].filter(item => item.type === 'item');\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      let item = items[mid];\n      let element = elementMap.get(String(item.key));\n      let rect = element.getBoundingClientRect();\n      let update = (isGreater: boolean) => {\n        if (isGreater) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      };\n\n      if (primary < this.getPrimaryStart(rect)) {\n        update(isPrimaryRTL);\n      } else if (primary > this.getPrimaryEnd(rect)) {\n        update(!isPrimaryRTL);\n      } else if (secondary < this.getSecondaryStart(rect)) {\n        update(isSecondaryRTL);\n      } else if (secondary > this.getSecondaryEnd(rect)) {\n        update(!isSecondaryRTL);\n      } else {\n        let target: DropTarget = {\n          type: 'item',\n          key: item.key,\n          dropPosition: 'on'\n        };\n\n        if (isValidDropTarget(target)) {\n          // Otherwise, if dropping on the item is accepted, try the before/after positions if within 5px\n          // of the start or end of the item.\n          if (flow <= this.getFlowStart(rect) + 5 && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= this.getFlowEnd(rect) - 5 && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        } else {\n          // If dropping on the item isn't accepted, try the target before or after depending on the position.\n          let mid = this.getFlowStart(rect) + this.getFlowSize(rect) / 2;\n          if (flow <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        }\n\n        return target;\n      }\n    }\n\n    let item = items[Math.min(low, items.length - 1)];\n    let element = elementMap.get(String(item.key));\n    rect = element.getBoundingClientRect();\n\n    if (primary < this.getPrimaryStart(rect) || Math.abs(flow - this.getFlowStart(rect)) < Math.abs(flow - this.getFlowEnd(rect))) {\n      return {\n        type: 'item',\n        key: item.key,\n        dropPosition: isFlowRTL ? 'after' : 'before'\n      };\n    }\n\n    return {\n      type: 'item',\n      key: item.key,\n      dropPosition: isFlowRTL ? 'before' : 'after'\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}