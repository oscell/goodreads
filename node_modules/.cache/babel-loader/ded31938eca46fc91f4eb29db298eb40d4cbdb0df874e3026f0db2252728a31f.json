{"ast":null,"code":"import { normalizeColor as $799cddbef784668f$export$4cde5df63f53f473, parseColor as $799cddbef784668f$export$6e865ea70d7724f } from \"./Color.mjs\";\nimport { useControlledState as $d4Pfi$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $d4Pfi$useMemo, useRef as $d4Pfi$useRef, useState as $d4Pfi$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $ee4262c74a467b07$var$DEFAULT_COLOR = (0, $799cddbef784668f$export$6e865ea70d7724f)('hsl(0, 100%, 50%)');\nfunction $ee4262c74a467b07$var$roundToStep(value, step) {\n  return Math.round(value / step) * step;\n}\nfunction $ee4262c74a467b07$var$mod(n, m) {\n  return (n % m + m) % m;\n}\nfunction $ee4262c74a467b07$var$roundDown(v) {\n  let r = Math.floor(v);\n  if (r === v) return v - 1;else return r;\n}\nfunction $ee4262c74a467b07$var$degToRad(deg) {\n  return deg * Math.PI / 180;\n}\nfunction $ee4262c74a467b07$var$radToDeg(rad) {\n  return rad * 180 / Math.PI;\n}\n// 0deg = 3 o'clock. increases clockwise\nfunction $ee4262c74a467b07$var$angleToCartesian(angle, radius) {\n  let rad = $ee4262c74a467b07$var$degToRad(360 - angle + 90);\n  let x = Math.sin(rad) * radius;\n  let y = Math.cos(rad) * radius;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction $ee4262c74a467b07$var$cartesianToAngle(x, y, radius) {\n  let deg = $ee4262c74a467b07$var$radToDeg(Math.atan2(y / radius, x / radius));\n  return (deg + 360) % 360;\n}\nfunction $ee4262c74a467b07$export$f4301076d9336137(props) {\n  let {\n    value: propsValue,\n    defaultValue: defaultValue,\n    onChange: onChange,\n    onChangeEnd: onChangeEnd\n  } = props;\n  if (!propsValue && !defaultValue) defaultValue = $ee4262c74a467b07$var$DEFAULT_COLOR;\n  if (propsValue) propsValue = (0, $799cddbef784668f$export$4cde5df63f53f473)(propsValue);\n  if (defaultValue) defaultValue = (0, $799cddbef784668f$export$4cde5df63f53f473)(defaultValue);\n  // safe to cast value and defaultValue to Color, one of them will always be defined because if neither are, we assign a default\n  let [stateValue, setValueState] = (0, $d4Pfi$useControlledState)(propsValue, defaultValue, onChange);\n  let value = (0, $d4Pfi$useMemo)(() => {\n    let colorSpace = stateValue.getColorSpace();\n    return colorSpace === 'hsl' || colorSpace === 'hsb' ? stateValue : stateValue.toFormat('hsl');\n  }, [stateValue]);\n  let valueRef = (0, $d4Pfi$useRef)(value);\n  let setValue = value => {\n    valueRef.current = value;\n    setValueState(value);\n  };\n  let channelRange = value.getChannelRange('hue');\n  let {\n    minValue: minValueX,\n    maxValue: maxValueX,\n    step: step,\n    pageSize: pageStep\n  } = channelRange;\n  let [isDragging, setDragging] = (0, $d4Pfi$useState)(false);\n  let isDraggingRef = (0, $d4Pfi$useRef)(false);\n  let hue = value.getChannelValue('hue');\n  function setHue(v) {\n    if (v > 360)\n      // Make sure you can always get back to 0.\n      v = 0;\n    v = $ee4262c74a467b07$var$roundToStep($ee4262c74a467b07$var$mod(v, 360), step);\n    if (hue !== v) {\n      let color = value.withChannelValue('hue', v);\n      setValue(color);\n    }\n  }\n  return {\n    value: value,\n    step: step,\n    pageStep: pageStep,\n    setValue(v) {\n      let color = (0, $799cddbef784668f$export$4cde5df63f53f473)(v);\n      setValue(color);\n    },\n    hue: hue,\n    setHue: setHue,\n    setHueFromPoint(x, y, radius) {\n      setHue($ee4262c74a467b07$var$cartesianToAngle(x, y, radius));\n    },\n    getThumbPosition(radius) {\n      return $ee4262c74a467b07$var$angleToCartesian(value.getChannelValue('hue'), radius);\n    },\n    increment(stepSize = 1) {\n      let s = Math.max(stepSize, step);\n      let newValue = hue + s;\n      if (newValue >= maxValueX)\n        // Make sure you can always get back to 0.\n        newValue = minValueX;\n      setHue($ee4262c74a467b07$var$roundToStep($ee4262c74a467b07$var$mod(newValue, 360), s));\n    },\n    decrement(stepSize = 1) {\n      let s = Math.max(stepSize, step);\n      if (hue === 0)\n        // We can't just subtract step because this might be the case:\n        // |(previous step) - 0| < step size\n        setHue($ee4262c74a467b07$var$roundDown(360 / s) * s);else setHue($ee4262c74a467b07$var$roundToStep($ee4262c74a467b07$var$mod(hue - s, 360), s));\n    },\n    setDragging(isDragging) {\n      let wasDragging = isDraggingRef.current;\n      isDraggingRef.current = isDragging;\n      if (onChangeEnd && !isDragging && wasDragging) onChangeEnd(valueRef.current);\n      setDragging(isDragging);\n    },\n    isDragging: isDragging,\n    getDisplayColor() {\n      return value.toFormat('hsl').withChannelValue('saturation', 100).withChannelValue('lightness', 50).withChannelValue('alpha', 1);\n    },\n    isDisabled: props.isDisabled || false\n  };\n}\nexport { $ee4262c74a467b07$export$f4301076d9336137 as useColorWheelState };","map":{"version":3,"names":["$ee4262c74a467b07$var$DEFAULT_COLOR","$799cddbef784668f$export$6e865ea70d7724f","$ee4262c74a467b07$var$roundToStep","value","step","Math","round","$ee4262c74a467b07$var$mod","n","m","$ee4262c74a467b07$var$roundDown","v","r","floor","$ee4262c74a467b07$var$degToRad","deg","PI","$ee4262c74a467b07$var$radToDeg","rad","$ee4262c74a467b07$var$angleToCartesian","angle","radius","x","sin","y","cos","$ee4262c74a467b07$var$cartesianToAngle","atan2","$ee4262c74a467b07$export$f4301076d9336137","props","propsValue","defaultValue","onChange","onChangeEnd","$799cddbef784668f$export$4cde5df63f53f473","stateValue","setValueState","$d4Pfi$useControlledState","$d4Pfi$useMemo","colorSpace","getColorSpace","toFormat","valueRef","$d4Pfi$useRef","setValue","current","channelRange","getChannelRange","minValue","minValueX","maxValue","maxValueX","pageSize","pageStep","isDragging","setDragging","$d4Pfi$useState","isDraggingRef","hue","getChannelValue","setHue","color","withChannelValue","setHueFromPoint","getThumbPosition","increment","stepSize","s","max","newValue","decrement","wasDragging","getDisplayColor","isDisabled"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/color/dist/packages/@react-stately/color/src/useColorWheelState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Color, ColorWheelProps} from '@react-types/color';\nimport {normalizeColor, parseColor} from './Color';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface ColorWheelState {\n  /** The current color value represented by the color wheel. */\n  readonly value: Color,\n  /** Sets the color value represented by the color wheel, and triggers `onChange`. */\n  setValue(value: string | Color): void,\n\n  /** The current value of the hue channel displayed by the color wheel. */\n  readonly hue: number,\n  /** Sets the hue channel of the current color value and triggers `onChange`. */\n  setHue(value: number): void,\n\n  /** Sets the hue channel of the current color value based on the given coordinates and radius of the color wheel, and triggers `onChange`. */\n  setHueFromPoint(x: number, y: number, radius: number): void,\n  /** Returns the coordinates of the thumb relative to the center point of the color wheel. */\n  getThumbPosition(radius: number): {x: number, y: number},\n\n  /** Increments the hue by the given amount (defaults to 1). */\n  increment(stepSize?: number): void,\n  /** Decrements the hue by the given amount (defaults to 1). */\n  decrement(stepSize?: number): void,\n\n  /** Whether the color wheel is currently being dragged. */\n  readonly isDragging: boolean,\n  /** Sets whether the color wheel is being dragged. */\n  setDragging(value: boolean): void,\n  /** Returns the color that should be displayed in the color wheel instead of `value`. */\n  getDisplayColor(): Color,\n  /** The step value of the hue channel, used when incrementing and decrementing. */\n  step: number,\n  /** The page step value of the hue channel, used when incrementing and decrementing. */\n  pageStep: number,\n\n  /** Whether the color wheel is disabled. */\n  readonly isDisabled: boolean\n}\n\nconst DEFAULT_COLOR = parseColor('hsl(0, 100%, 50%)');\n\nfunction roundToStep(value: number, step: number): number {\n  return Math.round(value / step) * step;\n}\n\nfunction mod(n: number, m: number) {\n  return ((n % m) + m) % m;\n}\n\nfunction roundDown(v: number) {\n  let r = Math.floor(v);\n  if (r === v) {\n    return v - 1;\n  } else {\n    return r;\n  }\n}\n\nfunction degToRad(deg: number) {\n  return deg * Math.PI / 180;\n}\n\nfunction radToDeg(rad: number) {\n  return rad * 180 / Math.PI;\n}\n\n// 0deg = 3 o'clock. increases clockwise\nfunction angleToCartesian(angle: number, radius: number): {x: number, y: number} {\n  let rad = degToRad(360 - angle + 90);\n  let x = Math.sin(rad) * (radius);\n  let y = Math.cos(rad) * (radius);\n  return {x, y};\n}\n\nfunction cartesianToAngle(x: number, y: number, radius: number): number {\n  let deg = radToDeg(Math.atan2(y / radius, x / radius));\n  return (deg + 360) % 360;\n}\n\n/**\n * Provides state management for a color wheel component.\n * Color wheels allow users to adjust the hue of an HSL or HSB color value on a circular track.\n */\nexport function useColorWheelState(props: ColorWheelProps): ColorWheelState {\n  let {value: propsValue, defaultValue, onChange, onChangeEnd} = props;\n\n  if (!propsValue && !defaultValue) {\n    defaultValue = DEFAULT_COLOR;\n  }\n  if (propsValue) {\n    propsValue = normalizeColor(propsValue);\n  }\n  if (defaultValue) {\n    defaultValue = normalizeColor(defaultValue);\n  }\n\n  // safe to cast value and defaultValue to Color, one of them will always be defined because if neither are, we assign a default\n  let [stateValue, setValueState] = useControlledState<Color>(propsValue as Color, defaultValue as Color, onChange);\n  let value = useMemo(() => {\n    let colorSpace = stateValue.getColorSpace();\n    return colorSpace === 'hsl' || colorSpace === 'hsb' ? stateValue : stateValue.toFormat('hsl');\n  }, [stateValue]);\n  let valueRef = useRef(value);\n  let setValue = (value: Color) => {\n    valueRef.current = value;\n    setValueState(value);\n  };\n\n  let channelRange = value.getChannelRange('hue');\n  let {minValue: minValueX, maxValue: maxValueX, step: step, pageSize: pageStep} = channelRange;\n  let [isDragging, setDragging] = useState(false);\n  let isDraggingRef = useRef(false);\n\n  let hue = value.getChannelValue('hue');\n  function setHue(v: number) {\n    if (v > 360) {\n      // Make sure you can always get back to 0.\n      v = 0;\n    }\n    v = roundToStep(mod(v, 360), step);\n    if (hue !== v) {\n      let color = value.withChannelValue('hue', v);\n      setValue(color);\n    }\n  }\n\n  return {\n    value,\n    step,\n    pageStep,\n    setValue(v) {\n      let color = normalizeColor(v);\n      setValue(color);\n    },\n    hue,\n    setHue,\n    setHueFromPoint(x, y, radius) {\n      setHue(cartesianToAngle(x, y, radius));\n    },\n    getThumbPosition(radius) {\n      return angleToCartesian(value.getChannelValue('hue'), radius);\n    },\n    increment(stepSize = 1) {\n      let s = Math.max(stepSize, step);\n      let newValue = hue + s;\n      if (newValue >= maxValueX) {\n        // Make sure you can always get back to 0.\n        newValue = minValueX;\n      }\n      setHue(roundToStep(mod(newValue, 360), s));\n    },\n    decrement(stepSize = 1) {\n      let s = Math.max(stepSize, step);\n      if (hue === 0) {\n        // We can't just subtract step because this might be the case:\n        // |(previous step) - 0| < step size\n        setHue(roundDown(360 / s) * s);\n      } else {\n        setHue(roundToStep(mod(hue - s, 360), s));\n      }\n    },\n    setDragging(isDragging) {\n      let wasDragging = isDraggingRef.current;\n      isDraggingRef.current = isDragging;\n\n      if (onChangeEnd && !isDragging && wasDragging) {\n        onChangeEnd(valueRef.current);\n      }\n\n      setDragging(isDragging);\n    },\n    isDragging,\n    getDisplayColor() {\n      return value.toFormat('hsl').withChannelValue('saturation', 100).withChannelValue('lightness', 50).withChannelValue('alpha', 1);\n    },\n    isDisabled: props.isDisabled || false\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}