{"ast":null,"code":"import { Size as $ipgKF$Size, Rect as $ipgKF$Rect, LayoutInfo as $ipgKF$LayoutInfo, Layout as $ipgKF$Layout } from \"@react-stately/virtualizer\";\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $a58592d295a170a4$export$7d2b12578154a735 extends (0, $ipgKF$Layout) {\n  update() {\n    let visibleWidth = this.virtualizer.visibleRect.width;\n    // The max item width is always the entire viewport.\n    // If the max item height is infinity, scale in proportion to the max width.\n    let maxItemWidth = Math.min(this.maxItemSize.width, visibleWidth);\n    let maxItemHeight = Number.isFinite(this.maxItemSize.height) ? this.maxItemSize.height : Math.floor(this.minItemSize.height / this.minItemSize.width * maxItemWidth);\n    // Compute the number of rows and columns needed to display the content\n    let columns = Math.floor(visibleWidth / (this.minItemSize.width + this.minSpace.width));\n    this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));\n    // Compute the available width (minus the space between items)\n    let width = visibleWidth - this.minSpace.width * Math.max(0, this.numColumns);\n    // Compute the item width based on the space available\n    let itemWidth = Math.floor(width / this.numColumns);\n    itemWidth = Math.max(this.minItemSize.width, Math.min(maxItemWidth, itemWidth));\n    // Compute the item height, which is proportional to the item width\n    let t = (itemWidth - this.minItemSize.width) / Math.max(1, maxItemWidth - this.minItemSize.width);\n    let itemHeight = this.minItemSize.height + Math.floor((maxItemHeight - this.minItemSize.height) * t);\n    itemHeight = Math.max(this.minItemSize.height, Math.min(maxItemHeight, itemHeight));\n    this.itemSize = new (0, $ipgKF$Size)(itemWidth, itemHeight);\n    // Compute the horizontal spacing and content height\n    this.horizontalSpacing = Math.floor((visibleWidth - this.numColumns * this.itemSize.width) / (this.numColumns + 1));\n    this.layoutInfos = [];\n    for (let node of this.virtualizer.collection) this.layoutInfos.push(this.getLayoutInfoForNode(node));\n  }\n  getVisibleLayoutInfos(rect) {\n    let firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);\n    let lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);\n    let result = this.layoutInfos.slice(firstVisibleItem, lastVisibleItem + 1);\n    let persistedIndices = [];\n    for (let key of this.virtualizer.persistedKeys) {\n      let item = this.virtualizer.collection.getItem(key);\n      if ((item === null || item === void 0 ? void 0 : item.index) != null) persistedIndices.push(item.index);\n    }\n    persistedIndices.sort((a, b) => a - b);\n    let persistedBefore = [];\n    for (let index of persistedIndices) {\n      if (index < firstVisibleItem) persistedBefore.push(this.layoutInfos[index]);else if (index > lastVisibleItem) result.push(this.layoutInfos[index]);\n    }\n    result.unshift(...persistedBefore);\n    return result;\n  }\n  getIndexAtPoint(x, y) {\n    let itemHeight = this.itemSize.height + this.minSpace.height;\n    let itemWidth = this.itemSize.width + this.horizontalSpacing;\n    return Math.max(0, Math.min(this.virtualizer.collection.size - 1, Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)));\n  }\n  getLayoutInfo(key) {\n    let node = this.virtualizer.collection.getItem(key);\n    return node ? this.layoutInfos[node.index] : null;\n  }\n  getLayoutInfoForNode(node) {\n    let idx = node.index;\n    let row = Math.floor(idx / this.numColumns);\n    let column = idx % this.numColumns;\n    let x = this.horizontalSpacing + column * (this.itemSize.width + this.horizontalSpacing);\n    let y = this.minSpace.height + row * (this.itemSize.height + this.minSpace.height);\n    let rect = new (0, $ipgKF$Rect)(x, y, this.itemSize.width, this.itemSize.height);\n    return new (0, $ipgKF$LayoutInfo)(node.type, node.key, rect);\n  }\n  getContentSize() {\n    let numRows = Math.ceil(this.virtualizer.collection.size / this.numColumns);\n    let contentHeight = this.minSpace.height + numRows * (this.itemSize.height + this.minSpace.height);\n    return new (0, $ipgKF$Size)(this.virtualizer.visibleRect.width, contentHeight);\n  }\n  getDropTargetFromPoint(x, y, isValidDropTarget) {\n    if (this.layoutInfos.length === 0) return {\n      type: 'root'\n    };\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    let index = this.getIndexAtPoint(x, y);\n    let layoutInfo = this.layoutInfos[index];\n    let target = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n    let pos = this.numColumns === 1 ? y : x;\n    let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n    let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n    if (isValidDropTarget(target)) {\n      // If dropping on the item is accepted, try the before/after positions\n      // if within 5px of the start or end of the item.\n      if (pos < layoutInfoPos + 5) target.dropPosition = 'before';else if (pos > layoutInfoPos + size - 5) target.dropPosition = 'after';\n    } else {\n      // If dropping on the item isn't accepted, try the target before or after depending on the position.\n      let mid = layoutInfoPos + size / 2;\n      if (pos <= mid && isValidDropTarget({\n        ...target,\n        dropPosition: 'before'\n      })) target.dropPosition = 'before';else if (pos >= mid && isValidDropTarget({\n        ...target,\n        dropPosition: 'after'\n      })) target.dropPosition = 'after';\n    }\n    return target;\n  }\n  getDropTargetLayoutInfo(target) {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect;\n    if (this.numColumns === 1)\n      // Flip from vertical to horizontal if only one column is visible.\n      rect = new (0, $ipgKF$Rect)(layoutInfo.rect.x, target.dropPosition === 'before' ? layoutInfo.rect.y - this.minSpace.height / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxY + this.minSpace.height / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);else rect = new (0, $ipgKF$Rect)(target.dropPosition === 'before' ? layoutInfo.rect.x - this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2 : layoutInfo.rect.maxX + this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2, layoutInfo.rect.y, this.dropIndicatorThickness, layoutInfo.rect.height);\n    return new (0, $ipgKF$LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n  constructor(options) {\n    super();\n    this.minItemSize = options.minItemSize || new (0, $ipgKF$Size)(200, 200);\n    this.maxItemSize = options.maxItemSize || new (0, $ipgKF$Size)(Infinity, Infinity);\n    this.minSpace = options.minSpace || new (0, $ipgKF$Size)(18, 18);\n    this.maxColumns = options.maxColumns || Infinity;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n  }\n}\nexport { $a58592d295a170a4$export$7d2b12578154a735 as GridLayout };","map":{"version":3,"names":["$a58592d295a170a4$export$7d2b12578154a735","$ipgKF$Layout","update","visibleWidth","virtualizer","visibleRect","width","maxItemWidth","Math","min","maxItemSize","maxItemHeight","Number","isFinite","height","floor","minItemSize","columns","minSpace","numColumns","max","maxColumns","itemWidth","t","itemHeight","itemSize","$ipgKF$Size","horizontalSpacing","layoutInfos","node","collection","push","getLayoutInfoForNode","getVisibleLayoutInfos","rect","firstVisibleItem","getIndexAtPoint","x","y","lastVisibleItem","maxX","maxY","result","slice","persistedIndices","key","persistedKeys","item","getItem","index","sort","a","b","persistedBefore","unshift","size","getLayoutInfo","idx","row","column","$ipgKF$Rect","$ipgKF$LayoutInfo","type","getContentSize","numRows","ceil","contentHeight","getDropTargetFromPoint","isValidDropTarget","length","layoutInfo","target","dropPosition","pos","layoutInfoPos","mid","getDropTargetLayoutInfo","dropIndicatorThickness","constructor","options","Infinity"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-stately/layout/dist/packages/@react-stately/layout/src/GridLayout.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface GridLayoutOptions {\n  /**\n   * The minimum item size.\n   * @default 200 x 200\n   */\n  minItemSize?: Size,\n  /**\n   * The maximum item size.\n   * @default Infinity\n   */\n  maxItemSize?: Size,\n  /**\n   * The minimum space required between items.\n   * @default 18 x 18\n   */\n  minSpace?: Size,\n  /**\n   * The maximum number of columns.\n   * @default Infinity\n   */\n  maxColumns?: number,\n  /**\n   * The thickness of the drop indicator.\n   * @default 2\n   */\n  dropIndicatorThickness?: number\n}\n\nexport class GridLayout<T, O = any> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected minItemSize: Size;\n  protected maxItemSize: Size;\n  protected minSpace: Size;\n  protected maxColumns: number;\n  protected dropIndicatorThickness: number;\n  protected itemSize: Size;\n  protected numColumns: number;\n  protected horizontalSpacing: number;\n  protected layoutInfos: LayoutInfo[];\n\n  constructor(options: GridLayoutOptions) {\n    super();\n    this.minItemSize = options.minItemSize || new Size(200, 200);\n    this.maxItemSize = options.maxItemSize || new Size(Infinity, Infinity);\n    this.minSpace = options.minSpace || new Size(18, 18);\n    this.maxColumns = options.maxColumns || Infinity;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n  }\n\n  update(): void {\n    let visibleWidth = this.virtualizer.visibleRect.width;\n\n    // The max item width is always the entire viewport.\n    // If the max item height is infinity, scale in proportion to the max width.\n    let maxItemWidth = Math.min(this.maxItemSize.width, visibleWidth);\n    let maxItemHeight = Number.isFinite(this.maxItemSize.height) \n      ? this.maxItemSize.height\n      : Math.floor((this.minItemSize.height / this.minItemSize.width) * maxItemWidth);\n\n    // Compute the number of rows and columns needed to display the content\n    let columns = Math.floor(visibleWidth / (this.minItemSize.width + this.minSpace.width));\n    this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));\n\n    // Compute the available width (minus the space between items)\n    let width = visibleWidth - (this.minSpace.width * Math.max(0, this.numColumns));\n\n    // Compute the item width based on the space available\n    let itemWidth = Math.floor(width / this.numColumns);\n    itemWidth = Math.max(this.minItemSize.width, Math.min(maxItemWidth, itemWidth));\n\n    // Compute the item height, which is proportional to the item width\n    let t = ((itemWidth - this.minItemSize.width) / Math.max(1, maxItemWidth - this.minItemSize.width));\n    let itemHeight = this.minItemSize.height +  Math.floor((maxItemHeight - this.minItemSize.height) * t);\n    itemHeight = Math.max(this.minItemSize.height, Math.min(maxItemHeight, itemHeight));\n    this.itemSize = new Size(itemWidth, itemHeight);\n\n    // Compute the horizontal spacing and content height\n    this.horizontalSpacing = Math.floor((visibleWidth - this.numColumns * this.itemSize.width) / (this.numColumns + 1));\n\n    this.layoutInfos = [];\n    for (let node of this.virtualizer.collection) {\n      this.layoutInfos.push(this.getLayoutInfoForNode(node));\n    }\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    let firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);\n    let lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);\n    let result = this.layoutInfos.slice(firstVisibleItem, lastVisibleItem + 1);\n    let persistedIndices: number[] = [];\n    for (let key of this.virtualizer.persistedKeys) {\n      let item = this.virtualizer.collection.getItem(key);\n      if (item?.index != null) {\n        persistedIndices.push(item.index);\n      }\n    }\n    persistedIndices.sort((a, b) => a - b);\n    \n    let persistedBefore: LayoutInfo[] = [];\n    for (let index of persistedIndices) {\n      if (index < firstVisibleItem) {\n        persistedBefore.push(this.layoutInfos[index]);\n      } else if (index > lastVisibleItem) {\n        result.push(this.layoutInfos[index]);\n      }\n    }\n    result.unshift(...persistedBefore);\n    return result;\n  }\n\n  protected getIndexAtPoint(x: number, y: number) {\n    let itemHeight = this.itemSize.height + this.minSpace.height;\n    let itemWidth = this.itemSize.width + this.horizontalSpacing;\n    return Math.max(0,\n      Math.min(\n        this.virtualizer.collection.size - 1,\n        Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)\n      )\n    );\n  }\n\n  getLayoutInfo(key: Key): LayoutInfo | null {\n    let node = this.virtualizer.collection.getItem(key);\n    return node ? this.layoutInfos[node.index] : null;\n  }\n\n  protected getLayoutInfoForNode(node: Node<T>): LayoutInfo {\n    let idx = node.index;\n    let row = Math.floor(idx / this.numColumns);\n    let column = idx % this.numColumns;\n    let x = this.horizontalSpacing + column * (this.itemSize.width + this.horizontalSpacing);\n    let y = this.minSpace.height + row * (this.itemSize.height + this.minSpace.height);\n    let rect = new Rect(x, y, this.itemSize.width, this.itemSize.height);\n    return new LayoutInfo(node.type, node.key, rect);\n  }\n\n  getContentSize(): Size {\n    let numRows = Math.ceil(this.virtualizer.collection.size / this.numColumns);\n    let contentHeight = this.minSpace.height + numRows * (this.itemSize.height + this.minSpace.height);  \n    return new Size(this.virtualizer.visibleRect.width, contentHeight);\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.layoutInfos.length === 0) {\n      return {type: 'root'};\n    }\n\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    let index = this.getIndexAtPoint(x, y);\n\n    let layoutInfo = this.layoutInfos[index];\n    let target: DropTarget =  {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    let pos = this.numColumns === 1 ? y : x;\n    let layoutInfoPos = this.numColumns === 1 ? layoutInfo.rect.y : layoutInfo.rect.x;\n    let size = this.numColumns === 1 ? layoutInfo.rect.height : layoutInfo.rect.width;\n    if (isValidDropTarget(target)) {\n      // If dropping on the item is accepted, try the before/after positions\n      // if within 5px of the start or end of the item.\n      if (pos < layoutInfoPos + 5) {\n        target.dropPosition = 'before';\n      } else if (pos > layoutInfoPos + size - 5) {\n        target.dropPosition = 'after';\n      }\n    } else {\n      // If dropping on the item isn't accepted, try the target before or after depending on the position.\n      let mid = layoutInfoPos + size / 2;\n      if (pos <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (pos >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect: Rect;\n    if (this.numColumns === 1) {\n      // Flip from vertical to horizontal if only one column is visible.\n      rect = new Rect(\n        layoutInfo.rect.x,\n        target.dropPosition === 'before' \n          ? layoutInfo.rect.y - this.minSpace.height / 2 - this.dropIndicatorThickness / 2\n          : layoutInfo.rect.maxY + this.minSpace.height / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.width,\n        this.dropIndicatorThickness\n      );\n    } else {\n      rect = new Rect(\n        target.dropPosition === 'before' \n          ? layoutInfo.rect.x - this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2 \n          : layoutInfo.rect.maxX + this.horizontalSpacing / 2 - this.dropIndicatorThickness / 2,\n        layoutInfo.rect.y,\n        this.dropIndicatorThickness,\n        layoutInfo.rect.height\n      );\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}