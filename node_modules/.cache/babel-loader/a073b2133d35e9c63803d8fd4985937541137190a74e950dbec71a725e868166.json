{"ast":null,"code":"import { createListActions as $0d86e9c8f07f9a7b$export$79c0c687a5963b0a } from \"./useListData.mjs\";\nimport { useReducer as $fh1mr$useReducer, useRef as $fh1mr$useRef, useEffect as $fh1mr$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _action_filterText, _action_sortDescriptor;\n          return {\n            ...data,\n            filterText: (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n          var _action_selectedKeys;\n          selectedKeys = (_action_selectedKeys = action.selectedKeys) !== null && _action_selectedKeys !== void 0 ? _action_selectedKeys : data.selectedKeys;\n          var _action_filterText1, _action_sortDescriptor1;\n          return {\n            ...data,\n            filterText: (_action_filterText1 = action.filterText) !== null && _action_filterText1 !== void 0 ? _action_filterText1 : data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_action_sortDescriptor1 = action.sortDescriptor) !== null && _action_sortDescriptor1 !== void 0 ? _action_sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          var _action_filterText2;\n          return {\n            ...data,\n            filterText: (_action_filterText2 = action.filterText) !== null && _action_filterText2 !== void 0 ? _action_filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _action_selectedKeys1;\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([...data.selectedKeys, ...((_action_selectedKeys1 = action.selectedKeys) !== null && _action_selectedKeys1 !== void 0 ? _action_selectedKeys1 : [])]);\n          var _action_sortDescriptor2;\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_action_sortDescriptor2 = action.sortDescriptor) !== null && _action_sortDescriptor2 !== void 0 ? _action_sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          var _action_filterText3;\n          return {\n            ...data,\n            filterText: (_action_filterText3 = action.filterText) !== null && _action_filterText3 !== void 0 ? _action_filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  const {\n    load: load,\n    sort: sort,\n    initialSelectedKeys: initialSelectedKeys,\n    initialSortDescriptor: initialSortDescriptor,\n    getKey = item => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n  let [data, dispatch] = (0, $fh1mr$useReducer)($f86e6c1ec7da6ebb$var$reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n  const dispatchFetch = async (action, fn) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({\n        ...action,\n        abortController: abortController\n      });\n      var _action_filterText;\n      let previousFilterText = (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText;\n      var _action_sortDescriptor;\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n      var _response_filterText;\n      let filterText = (_response_filterText = response.filterText) !== null && _response_filterText !== void 0 ? _response_filterText : previousFilterText;\n      dispatch({\n        type: 'success',\n        ...response,\n        abortController: abortController\n      });\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    } catch (e) {\n      dispatch({\n        type: 'error',\n        error: e,\n        abortController: abortController\n      });\n    }\n  };\n  let didDispatchInitialFetch = (0, $fh1mr$useRef)(false);\n  (0, $fh1mr$useEffect)(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n      didDispatchInitialFetch.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, sort || load);\n    },\n    ...(0, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a)({\n      ...options,\n      getKey: getKey,\n      cursor: data.cursor\n    }, fn => {\n      dispatch({\n        type: 'update',\n        updater: fn\n      });\n    }),\n    setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  };\n}\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList };","map":{"version":3,"names":["$f86e6c1ec7da6ebb$var$reducer","data","action","selectedKeys","state","type","_action_filterText","_action_sortDescriptor","filterText","items","sortDescriptor","abortController","updater","Error","_action_selectedKeys","_action_filterText1","_action_sortDescriptor1","Set","cursor","error","abort","_action_filterText2","_action_selectedKeys1","_action_sortDescriptor2","_action_filterText3","$f86e6c1ec7da6ebb$export$bc3384a35de93d66","options","load","sort","initialSelectedKeys","initialSortDescriptor","getKey","item","id","key","initialFilterText","dispatch","$fh1mr$useReducer","dispatchFetch","fn","AbortController","previousFilterText","response","slice","signal","_response_filterText","aborted","e","didDispatchInitialFetch","$fh1mr$useRef","$fh1mr$useEffect","current","isLoading","loadingState","getItem","find","reload","loadMore","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","setFilterText"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useAsyncList.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, LoadingState, Selection, SortDescriptor} from '@react-types/shared';\nimport {useEffect, useReducer, useRef} from 'react';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<AsyncListState<T, C>, [Action<T, C>]>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  let didDispatchInitialFetch = useRef(false);\n  useEffect(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({type: 'loading'}, load);\n      didDispatchInitialFetch.current = true;\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}