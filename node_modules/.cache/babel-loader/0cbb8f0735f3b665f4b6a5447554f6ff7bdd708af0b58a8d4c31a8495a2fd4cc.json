{"ast":null,"code":"// src/cache/createBrowserLocalStorageCache.ts\nfunction createBrowserLocalStorageCache(options) {\n  let storage;\n  const namespaceKey = `algolia-client-js-${options.key}`;\n  function getStorage() {\n    if (storage === void 0) {\n      storage = options.localStorage || window.localStorage;\n    }\n    return storage;\n  }\n  function getNamespace() {\n    return JSON.parse(getStorage().getItem(namespaceKey) || \"{}\");\n  }\n  function setNamespace(namespace) {\n    getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n  }\n  function removeOutdatedCacheItems() {\n    const timeToLive = options.timeToLive ? options.timeToLive * 1e3 : null;\n    const namespace = getNamespace();\n    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem]) => {\n      return cacheItem.timestamp !== void 0;\n    }));\n    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n    if (!timeToLive) {\n      return;\n    }\n    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\n      const currentTimestamp = (/* @__PURE__ */new Date()).getTime();\n      const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n      return !isExpired;\n    }));\n    setNamespace(filteredNamespaceWithoutExpiredItems);\n  }\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      return Promise.resolve().then(() => {\n        removeOutdatedCacheItems();\n        return getNamespace()[JSON.stringify(key)];\n      }).then(value => {\n        return Promise.all([value ? value.value : defaultValue(), value !== void 0]);\n      }).then(([value, exists]) => {\n        return Promise.all([value, exists || events.miss(value)]);\n      }).then(([value]) => value);\n    },\n    set(key, value) {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n        namespace[JSON.stringify(key)] = {\n          timestamp: (/* @__PURE__ */new Date()).getTime(),\n          value\n        };\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n        return value;\n      });\n    },\n    delete(key) {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n        delete namespace[JSON.stringify(key)];\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n      });\n    },\n    clear() {\n      return Promise.resolve().then(() => {\n        getStorage().removeItem(namespaceKey);\n      });\n    }\n  };\n}\n\n// src/cache/createNullCache.ts\nfunction createNullCache() {\n  return {\n    get(_key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      const value = defaultValue();\n      return value.then(result => Promise.all([result, events.miss(result)])).then(([result]) => result);\n    },\n    set(_key, value) {\n      return Promise.resolve(value);\n    },\n    delete(_key) {\n      return Promise.resolve();\n    },\n    clear() {\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/cache/createFallbackableCache.ts\nfunction createFallbackableCache(options) {\n  const caches = [...options.caches];\n  const current = caches.shift();\n  if (current === void 0) {\n    return createNullCache();\n  }\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      return current.get(key, defaultValue, events).catch(() => {\n        return createFallbackableCache({\n          caches\n        }).get(key, defaultValue, events);\n      });\n    },\n    set(key, value) {\n      return current.set(key, value).catch(() => {\n        return createFallbackableCache({\n          caches\n        }).set(key, value);\n      });\n    },\n    delete(key) {\n      return current.delete(key).catch(() => {\n        return createFallbackableCache({\n          caches\n        }).delete(key);\n      });\n    },\n    clear() {\n      return current.clear().catch(() => {\n        return createFallbackableCache({\n          caches\n        }).clear();\n      });\n    }\n  };\n}\n\n// src/cache/createMemoryCache.ts\nfunction createMemoryCache(options = {\n  serializable: true\n}) {\n  let cache = {};\n  return {\n    get(key, defaultValue, events = {\n      miss: () => Promise.resolve()\n    }) {\n      const keyAsString = JSON.stringify(key);\n      if (keyAsString in cache) {\n        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n      }\n      const promise = defaultValue();\n      return promise.then(value => events.miss(value)).then(() => promise);\n    },\n    set(key, value) {\n      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n      return Promise.resolve(value);\n    },\n    delete(key) {\n      delete cache[JSON.stringify(key)];\n      return Promise.resolve();\n    },\n    clear() {\n      cache = {};\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/constants.ts\nvar DEFAULT_CONNECT_TIMEOUT_BROWSER = 1e3;\nvar DEFAULT_READ_TIMEOUT_BROWSER = 2e3;\nvar DEFAULT_WRITE_TIMEOUT_BROWSER = 3e4;\nvar DEFAULT_CONNECT_TIMEOUT_NODE = 2e3;\nvar DEFAULT_READ_TIMEOUT_NODE = 5e3;\nvar DEFAULT_WRITE_TIMEOUT_NODE = 3e4;\n\n// src/createAlgoliaAgent.ts\nfunction createAlgoliaAgent(version) {\n  const algoliaAgent = {\n    value: `Algolia for JavaScript (${version})`,\n    add(options) {\n      const addedAlgoliaAgent = `; ${options.segment}${options.version !== void 0 ? ` (${options.version})` : \"\"}`;\n      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {\n        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;\n      }\n      return algoliaAgent;\n    }\n  };\n  return algoliaAgent;\n}\n\n// src/createAuth.ts\nfunction createAuth(appId, apiKey, authMode = \"WithinHeaders\") {\n  const credentials = {\n    \"x-algolia-api-key\": apiKey,\n    \"x-algolia-application-id\": appId\n  };\n  return {\n    headers() {\n      return authMode === \"WithinHeaders\" ? credentials : {};\n    },\n    queryParameters() {\n      return authMode === \"WithinQueryParameters\" ? credentials : {};\n    }\n  };\n}\n\n// src/createIterablePromise.ts\nfunction createIterablePromise({\n  func,\n  validate,\n  aggregator,\n  error,\n  timeout = () => 0\n}) {\n  const retry = previousResponse => {\n    return new Promise((resolve, reject) => {\n      func(previousResponse).then(response => {\n        if (aggregator) {\n          aggregator(response);\n        }\n        if (validate(response)) {\n          return resolve(response);\n        }\n        if (error && error.validate(response)) {\n          return reject(new Error(error.message(response)));\n        }\n        return setTimeout(() => {\n          retry(response).then(resolve).catch(reject);\n        }, timeout());\n      }).catch(err => {\n        reject(err);\n      });\n    });\n  };\n  return retry();\n}\n\n// src/getAlgoliaAgent.ts\nfunction getAlgoliaAgent({\n  algoliaAgents,\n  client,\n  version\n}) {\n  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({\n    segment: client,\n    version\n  });\n  algoliaAgents.forEach(algoliaAgent => defaultAlgoliaAgent.add(algoliaAgent));\n  return defaultAlgoliaAgent;\n}\n\n// src/logger/createNullLogger.ts\nfunction createNullLogger() {\n  return {\n    debug(_message, _args) {\n      return Promise.resolve();\n    },\n    info(_message, _args) {\n      return Promise.resolve();\n    },\n    error(_message, _args) {\n      return Promise.resolve();\n    }\n  };\n}\n\n// src/transporter/createStatefulHost.ts\nvar EXPIRATION_DELAY = 2 * 60 * 1e3;\nfunction createStatefulHost(host, status = \"up\") {\n  const lastUpdate = Date.now();\n  function isUp() {\n    return status === \"up\" || Date.now() - lastUpdate > EXPIRATION_DELAY;\n  }\n  function isTimedOut() {\n    return status === \"timed out\" && Date.now() - lastUpdate <= EXPIRATION_DELAY;\n  }\n  return {\n    ...host,\n    status,\n    lastUpdate,\n    isUp,\n    isTimedOut\n  };\n}\n\n// src/transporter/errors.ts\nvar AlgoliaError = class extends Error {\n  name = \"AlgoliaError\";\n  constructor(message, name) {\n    super(message);\n    if (name) {\n      this.name = name;\n    }\n  }\n};\nvar ErrorWithStackTrace = class extends AlgoliaError {\n  stackTrace;\n  constructor(message, stackTrace, name) {\n    super(message, name);\n    this.stackTrace = stackTrace;\n  }\n};\nvar RetryError = class extends ErrorWithStackTrace {\n  constructor(stackTrace) {\n    super(\"Unreachable hosts - your application id may be incorrect. If the error persists, please reach out to the Algolia Support team: https://alg.li/support.\", stackTrace, \"RetryError\");\n  }\n};\nvar ApiError = class extends ErrorWithStackTrace {\n  status;\n  constructor(message, status, stackTrace, name = \"ApiError\") {\n    super(message, stackTrace, name);\n    this.status = status;\n  }\n};\nvar DeserializationError = class extends AlgoliaError {\n  response;\n  constructor(message, response) {\n    super(message, \"DeserializationError\");\n    this.response = response;\n  }\n};\nvar DetailedApiError = class extends ApiError {\n  error;\n  constructor(message, status, error, stackTrace) {\n    super(message, status, stackTrace, \"DetailedApiError\");\n    this.error = error;\n  }\n};\n\n// src/transporter/helpers.ts\nfunction shuffle(array) {\n  const shuffledArray = array;\n  for (let c = array.length - 1; c > 0; c--) {\n    const b = Math.floor(Math.random() * (c + 1));\n    const a = array[c];\n    shuffledArray[c] = array[b];\n    shuffledArray[b] = a;\n  }\n  return shuffledArray;\n}\nfunction serializeUrl(host, path, queryParameters) {\n  const queryParametersAsString = serializeQueryParameters(queryParameters);\n  let url = `${host.protocol}://${host.url}${host.port ? `:${host.port}` : \"\"}/${path.charAt(0) === \"/\" ? path.substring(1) : path}`;\n  if (queryParametersAsString.length) {\n    url += `?${queryParametersAsString}`;\n  }\n  return url;\n}\nfunction serializeQueryParameters(parameters) {\n  return Object.keys(parameters).filter(key => parameters[key] !== void 0).sort().map(key => `${key}=${encodeURIComponent(Object.prototype.toString.call(parameters[key]) === \"[object Array]\" ? parameters[key].join(\",\") : parameters[key]).replace(/\\+/g, \"%20\")}`).join(\"&\");\n}\nfunction serializeData(request, requestOptions) {\n  if (request.method === \"GET\" || request.data === void 0 && requestOptions.data === void 0) {\n    return void 0;\n  }\n  const data = Array.isArray(request.data) ? request.data : {\n    ...request.data,\n    ...requestOptions.data\n  };\n  return JSON.stringify(data);\n}\nfunction serializeHeaders(baseHeaders, requestHeaders, requestOptionsHeaders) {\n  const headers = {\n    Accept: \"application/json\",\n    ...baseHeaders,\n    ...requestHeaders,\n    ...requestOptionsHeaders\n  };\n  const serializedHeaders = {};\n  Object.keys(headers).forEach(header => {\n    const value = headers[header];\n    serializedHeaders[header.toLowerCase()] = value;\n  });\n  return serializedHeaders;\n}\nfunction deserializeSuccess(response) {\n  try {\n    return JSON.parse(response.content);\n  } catch (e) {\n    throw new DeserializationError(e.message, response);\n  }\n}\nfunction deserializeFailure({\n  content,\n  status\n}, stackFrame) {\n  try {\n    const parsed = JSON.parse(content);\n    if (\"error\" in parsed) {\n      return new DetailedApiError(parsed.message, status, parsed.error, stackFrame);\n    }\n    return new ApiError(parsed.message, status, stackFrame);\n  } catch {}\n  return new ApiError(content, status, stackFrame);\n}\n\n// src/transporter/responses.ts\nfunction isNetworkError({\n  isTimedOut,\n  status\n}) {\n  return !isTimedOut && ~~status === 0;\n}\nfunction isRetryable({\n  isTimedOut,\n  status\n}) {\n  return isTimedOut || isNetworkError({\n    isTimedOut,\n    status\n  }) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;\n}\nfunction isSuccess({\n  status\n}) {\n  return ~~(status / 100) === 2;\n}\n\n// src/transporter/stackTrace.ts\nfunction stackTraceWithoutCredentials(stackTrace) {\n  return stackTrace.map(stackFrame => stackFrameWithoutCredentials(stackFrame));\n}\nfunction stackFrameWithoutCredentials(stackFrame) {\n  const modifiedHeaders = stackFrame.request.headers[\"x-algolia-api-key\"] ? {\n    \"x-algolia-api-key\": \"*****\"\n  } : {};\n  return {\n    ...stackFrame,\n    request: {\n      ...stackFrame.request,\n      headers: {\n        ...stackFrame.request.headers,\n        ...modifiedHeaders\n      }\n    }\n  };\n}\n\n// src/transporter/createTransporter.ts\nfunction createTransporter({\n  hosts,\n  hostsCache,\n  baseHeaders,\n  logger,\n  baseQueryParameters,\n  algoliaAgent,\n  timeouts,\n  requester,\n  requestsCache,\n  responsesCache\n}) {\n  async function createRetryableOptions(compatibleHosts) {\n    const statefulHosts = await Promise.all(compatibleHosts.map(compatibleHost => {\n      return hostsCache.get(compatibleHost, () => {\n        return Promise.resolve(createStatefulHost(compatibleHost));\n      });\n    }));\n    const hostsUp = statefulHosts.filter(host => host.isUp());\n    const hostsTimedOut = statefulHosts.filter(host => host.isTimedOut());\n    const hostsAvailable = [...hostsUp, ...hostsTimedOut];\n    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;\n    return {\n      hosts: compatibleHostsAvailable,\n      getTimeout(timeoutsCount, baseTimeout) {\n        const timeoutMultiplier = hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;\n        return timeoutMultiplier * baseTimeout;\n      }\n    };\n  }\n  async function retryableRequest(request, requestOptions, isRead = true) {\n    const stackTrace = [];\n    const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);\n    const dataQueryParameters = request.method === \"GET\" ? {\n      ...request.data,\n      ...requestOptions.data\n    } : {};\n    const queryParameters = {\n      ...baseQueryParameters,\n      ...request.queryParameters,\n      ...dataQueryParameters\n    };\n    if (algoliaAgent.value) {\n      queryParameters[\"x-algolia-agent\"] = algoliaAgent.value;\n    }\n    if (requestOptions && requestOptions.queryParameters) {\n      for (const key of Object.keys(requestOptions.queryParameters)) {\n        if (!requestOptions.queryParameters[key] || Object.prototype.toString.call(requestOptions.queryParameters[key]) === \"[object Object]\") {\n          queryParameters[key] = requestOptions.queryParameters[key];\n        } else {\n          queryParameters[key] = requestOptions.queryParameters[key].toString();\n        }\n      }\n    }\n    let timeoutsCount = 0;\n    const retry = async (retryableHosts, getTimeout) => {\n      const host = retryableHosts.pop();\n      if (host === void 0) {\n        throw new RetryError(stackTraceWithoutCredentials(stackTrace));\n      }\n      const timeout = {\n        ...timeouts,\n        ...requestOptions.timeouts\n      };\n      const payload = {\n        data,\n        headers,\n        method: request.method,\n        url: serializeUrl(host, request.path, queryParameters),\n        connectTimeout: getTimeout(timeoutsCount, timeout.connect),\n        responseTimeout: getTimeout(timeoutsCount, isRead ? timeout.read : timeout.write)\n      };\n      const pushToStackTrace = response2 => {\n        const stackFrame = {\n          request: payload,\n          response: response2,\n          host,\n          triesLeft: retryableHosts.length\n        };\n        stackTrace.push(stackFrame);\n        return stackFrame;\n      };\n      const response = await requester.send(payload);\n      if (isRetryable(response)) {\n        const stackFrame = pushToStackTrace(response);\n        if (response.isTimedOut) {\n          timeoutsCount++;\n        }\n        logger.info(\"Retryable failure\", stackFrameWithoutCredentials(stackFrame));\n        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? \"timed out\" : \"down\"));\n        return retry(retryableHosts, getTimeout);\n      }\n      if (isSuccess(response)) {\n        return deserializeSuccess(response);\n      }\n      pushToStackTrace(response);\n      throw deserializeFailure(response, stackTrace);\n    };\n    const compatibleHosts = hosts.filter(host => host.accept === \"readWrite\" || (isRead ? host.accept === \"read\" : host.accept === \"write\"));\n    const options = await createRetryableOptions(compatibleHosts);\n    return retry([...options.hosts].reverse(), options.getTimeout);\n  }\n  function createRequest(request, requestOptions = {}) {\n    const isRead = request.useReadTransporter || request.method === \"GET\";\n    if (!isRead) {\n      return retryableRequest(request, requestOptions, isRead);\n    }\n    const createRetryableRequest = () => {\n      return retryableRequest(request, requestOptions);\n    };\n    const cacheable = requestOptions.cacheable || request.cacheable;\n    if (cacheable !== true) {\n      return createRetryableRequest();\n    }\n    const key = {\n      request,\n      requestOptions,\n      transporter: {\n        queryParameters: baseQueryParameters,\n        headers: baseHeaders\n      }\n    };\n    return responsesCache.get(key, () => {\n      return requestsCache.get(key, () => (\n      /**\n       * Finally, if there is no request in progress with the same key,\n       * this `createRetryableRequest()` will actually trigger the\n       * retryable request.\n       */\n      requestsCache.set(key, createRetryableRequest()).then(response => Promise.all([requestsCache.delete(key), response]), err => Promise.all([requestsCache.delete(key), Promise.reject(err)])).then(([_, response]) => response)));\n    }, {\n      /**\n       * Of course, once we get this response back from the server, we\n       * tell response cache to actually store the received response\n       * to be used later.\n       */\n      miss: response => responsesCache.set(key, response)\n    });\n  }\n  return {\n    hostsCache,\n    requester,\n    timeouts,\n    logger,\n    algoliaAgent,\n    baseHeaders,\n    baseQueryParameters,\n    hosts,\n    request: createRequest,\n    requestsCache,\n    responsesCache\n  };\n}\n\n// src/types/logger.ts\nvar LogLevelEnum = {\n  Debug: 1,\n  Info: 2,\n  Error: 3\n};\nexport { AlgoliaError, ApiError, DEFAULT_CONNECT_TIMEOUT_BROWSER, DEFAULT_CONNECT_TIMEOUT_NODE, DEFAULT_READ_TIMEOUT_BROWSER, DEFAULT_READ_TIMEOUT_NODE, DEFAULT_WRITE_TIMEOUT_BROWSER, DEFAULT_WRITE_TIMEOUT_NODE, DeserializationError, DetailedApiError, ErrorWithStackTrace, LogLevelEnum, RetryError, createAlgoliaAgent, createAuth, createBrowserLocalStorageCache, createFallbackableCache, createIterablePromise, createMemoryCache, createNullCache, createNullLogger, createStatefulHost, createTransporter, deserializeFailure, deserializeSuccess, getAlgoliaAgent, isNetworkError, isRetryable, isSuccess, serializeData, serializeHeaders, serializeQueryParameters, serializeUrl, shuffle, stackFrameWithoutCredentials, stackTraceWithoutCredentials };","map":{"version":3,"names":["createBrowserLocalStorageCache","options","storage","namespaceKey","key","getStorage","localStorage","window","getNamespace","JSON","parse","getItem","setNamespace","namespace","setItem","stringify","removeOutdatedCacheItems","timeToLive","filteredNamespaceWithoutOldFormattedCacheItems","Object","fromEntries","entries","filter","cacheItem","timestamp","filteredNamespaceWithoutExpiredItems","currentTimestamp","Date","getTime","isExpired","get","defaultValue","events","miss","Promise","resolve","then","value","all","exists","set","delete","clear","removeItem","createNullCache","_key","result","createFallbackableCache","caches","current","shift","catch","createMemoryCache","serializable","cache","keyAsString","promise","DEFAULT_CONNECT_TIMEOUT_BROWSER","DEFAULT_READ_TIMEOUT_BROWSER","DEFAULT_WRITE_TIMEOUT_BROWSER","DEFAULT_CONNECT_TIMEOUT_NODE","DEFAULT_READ_TIMEOUT_NODE","DEFAULT_WRITE_TIMEOUT_NODE","createAlgoliaAgent","version","algoliaAgent","add","addedAlgoliaAgent","segment","indexOf","createAuth","appId","apiKey","authMode","credentials","headers","queryParameters","createIterablePromise","func","validate","aggregator","error","timeout","retry","previousResponse","reject","response","Error","message","setTimeout","err","getAlgoliaAgent","algoliaAgents","client","defaultAlgoliaAgent","forEach","createNullLogger","debug","_message","_args","info","EXPIRATION_DELAY","createStatefulHost","host","status","lastUpdate","now","isUp","isTimedOut","AlgoliaError","name","constructor","ErrorWithStackTrace","stackTrace","RetryError","ApiError","DeserializationError","DetailedApiError","shuffle","array","shuffledArray","c","length","b","Math","floor","random","a","serializeUrl","path","queryParametersAsString","serializeQueryParameters","url","protocol","port","charAt","substring","parameters","keys","sort","map","encodeURIComponent","prototype","toString","call","join","replace","serializeData","request","requestOptions","method","data","Array","isArray","serializeHeaders","baseHeaders","requestHeaders","requestOptionsHeaders","Accept","serializedHeaders","header","toLowerCase","deserializeSuccess","content","e","deserializeFailure","stackFrame","parsed","isNetworkError","isRetryable","isSuccess","stackTraceWithoutCredentials","stackFrameWithoutCredentials","modifiedHeaders","createTransporter","hosts","hostsCache","logger","baseQueryParameters","timeouts","requester","requestsCache","responsesCache","createRetryableOptions","compatibleHosts","statefulHosts","compatibleHost","hostsUp","hostsTimedOut","hostsAvailable","compatibleHostsAvailable","getTimeout","timeoutsCount","baseTimeout","timeoutMultiplier","retryableRequest","isRead","dataQueryParameters","retryableHosts","pop","payload","connectTimeout","connect","responseTimeout","read","write","pushToStackTrace","response2","triesLeft","push","send","accept","reverse","createRequest","useReadTransporter","createRetryableRequest","cacheable","transporter","_","LogLevelEnum","Debug","Info"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/cache/createBrowserLocalStorageCache.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/cache/createNullCache.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/cache/createFallbackableCache.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/cache/createMemoryCache.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/constants.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/createAlgoliaAgent.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/createAuth.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/createIterablePromise.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/getAlgoliaAgent.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/logger/createNullLogger.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/createStatefulHost.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/errors.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/helpers.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/responses.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/stackTrace.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/transporter/createTransporter.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@algolia/client-common/src/types/logger.ts"],"sourcesContent":["import type { BrowserLocalStorageCacheItem, BrowserLocalStorageOptions, Cache, CacheEvents } from '../types';\n\nexport function createBrowserLocalStorageCache(options: BrowserLocalStorageOptions): Cache {\n  let storage: Storage;\n  // We've changed the namespace to avoid conflicts with v4, as this version is a huge breaking change\n  const namespaceKey = `algolia-client-js-${options.key}`;\n\n  function getStorage(): Storage {\n    if (storage === undefined) {\n      storage = options.localStorage || window.localStorage;\n    }\n\n    return storage;\n  }\n\n  function getNamespace<TValue>(): Record<string, TValue> {\n    return JSON.parse(getStorage().getItem(namespaceKey) || '{}');\n  }\n\n  function setNamespace(namespace: Record<string, any>): void {\n    getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n  }\n\n  function removeOutdatedCacheItems(): void {\n    const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n    const namespace = getNamespace<BrowserLocalStorageCacheItem>();\n\n    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(\n      Object.entries(namespace).filter(([, cacheItem]) => {\n        return cacheItem.timestamp !== undefined;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n\n    if (!timeToLive) {\n      return;\n    }\n\n    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(\n      Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\n        const currentTimestamp = new Date().getTime();\n        const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n\n        return !isExpired;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutExpiredItems);\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: () => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return Promise.resolve()\n        .then(() => {\n          removeOutdatedCacheItems();\n\n          return getNamespace<Promise<BrowserLocalStorageCacheItem>>()[JSON.stringify(key)];\n        })\n        .then((value) => {\n          return Promise.all([value ? value.value : defaultValue(), value !== undefined]);\n        })\n        .then(([value, exists]) => {\n          return Promise.all([value, exists || events.miss(value)]);\n        })\n        .then(([value]) => value);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        namespace[JSON.stringify(key)] = {\n          timestamp: new Date().getTime(),\n          value,\n        };\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n\n        return value;\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        delete namespace[JSON.stringify(key)];\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n      });\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve().then(() => {\n        getStorage().removeItem(namespaceKey);\n      });\n    },\n  };\n}\n","import type { Cache, CacheEvents } from '../types';\n\nexport function createNullCache(): Cache {\n  return {\n    get<TValue>(\n      _key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const value = defaultValue();\n\n      return value.then((result) => Promise.all([result, events.miss(result)])).then(([result]) => result);\n    },\n\n    set<TValue>(_key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve(value);\n    },\n\n    delete(_key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n","import type { Cache, CacheEvents, FallbackableCacheOptions } from '../types';\nimport { createNullCache } from './createNullCache';\n\nexport function createFallbackableCache(options: FallbackableCacheOptions): Cache {\n  const caches = [...options.caches];\n  const current = caches.shift();\n\n  if (current === undefined) {\n    return createNullCache();\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return current.get(key, defaultValue, events).catch(() => {\n        return createFallbackableCache({ caches }).get(key, defaultValue, events);\n      });\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return current.set(key, value).catch(() => {\n        return createFallbackableCache({ caches }).set(key, value);\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return current.delete(key).catch(() => {\n        return createFallbackableCache({ caches }).delete(key);\n      });\n    },\n\n    clear(): Promise<void> {\n      return current.clear().catch(() => {\n        return createFallbackableCache({ caches }).clear();\n      });\n    },\n  };\n}\n","import type { Cache, CacheEvents, MemoryCacheOptions } from '../types';\n\nexport function createMemoryCache(options: MemoryCacheOptions = { serializable: true }): Cache {\n  let cache: Record<string, any> = {};\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const keyAsString = JSON.stringify(key);\n\n      if (keyAsString in cache) {\n        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n      }\n\n      const promise = defaultValue();\n\n      return promise.then((value: TValue) => events.miss(value)).then(() => promise);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n\n      return Promise.resolve(value);\n    },\n\n    delete(key: Record<string, unknown> | string): Promise<void> {\n      delete cache[JSON.stringify(key)];\n\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      cache = {};\n\n      return Promise.resolve();\n    },\n  };\n}\n","export const DEFAULT_CONNECT_TIMEOUT_BROWSER = 1000;\nexport const DEFAULT_READ_TIMEOUT_BROWSER = 2000;\nexport const DEFAULT_WRITE_TIMEOUT_BROWSER = 30000;\n\nexport const DEFAULT_CONNECT_TIMEOUT_NODE = 2000;\nexport const DEFAULT_READ_TIMEOUT_NODE = 5000;\nexport const DEFAULT_WRITE_TIMEOUT_NODE = 30000;\n","import type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport function createAlgoliaAgent(version: string): AlgoliaAgent {\n  const algoliaAgent = {\n    value: `Algolia for JavaScript (${version})`,\n    add(options: AlgoliaAgentOptions): AlgoliaAgent {\n      const addedAlgoliaAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;\n\n      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {\n        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;\n      }\n\n      return algoliaAgent;\n    },\n  };\n\n  return algoliaAgent;\n}\n","import type { AuthMode, Headers, QueryParameters } from './types';\n\nexport function createAuth(\n  appId: string,\n  apiKey: string,\n  authMode: AuthMode = 'WithinHeaders',\n): {\n  readonly headers: () => Headers;\n  readonly queryParameters: () => QueryParameters;\n} {\n  const credentials = {\n    'x-algolia-api-key': apiKey,\n    'x-algolia-application-id': appId,\n  };\n\n  return {\n    headers(): Headers {\n      return authMode === 'WithinHeaders' ? credentials : {};\n    },\n\n    queryParameters(): QueryParameters {\n      return authMode === 'WithinQueryParameters' ? credentials : {};\n    },\n  };\n}\n","import type { CreateIterablePromise } from './types/createIterablePromise';\n\n/**\n * Helper: Returns the promise of a given `func` to iterate on, based on a given `validate` condition.\n *\n * @param createIterator - The createIterator options.\n * @param createIterator.func - The function to run, which returns a promise.\n * @param createIterator.validate - The validator function. It receives the resolved return of `func`.\n * @param createIterator.aggregator - The function that runs right after the `func` method has been executed, allows you to do anything with the response before `validate`.\n * @param createIterator.error - The `validate` condition to throw an error, and its message.\n * @param createIterator.timeout - The function to decide how long to wait between iterations.\n */\nexport function createIterablePromise<TResponse>({\n  func,\n  validate,\n  aggregator,\n  error,\n  timeout = (): number => 0,\n}: CreateIterablePromise<TResponse>): Promise<TResponse> {\n  const retry = (previousResponse?: TResponse): Promise<TResponse> => {\n    return new Promise<TResponse>((resolve, reject) => {\n      func(previousResponse)\n        .then((response) => {\n          if (aggregator) {\n            aggregator(response);\n          }\n\n          if (validate(response)) {\n            return resolve(response);\n          }\n\n          if (error && error.validate(response)) {\n            return reject(new Error(error.message(response)));\n          }\n\n          return setTimeout(() => {\n            retry(response).then(resolve).catch(reject);\n          }, timeout());\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  };\n\n  return retry();\n}\n","import { createAlgoliaAgent } from './createAlgoliaAgent';\nimport type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport type GetAlgoliaAgent = {\n  algoliaAgents: AlgoliaAgentOptions[];\n  client: string;\n  version: string;\n};\n\nexport function getAlgoliaAgent({ algoliaAgents, client, version }: GetAlgoliaAgent): AlgoliaAgent {\n  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({\n    segment: client,\n    version,\n  });\n\n  algoliaAgents.forEach((algoliaAgent) => defaultAlgoliaAgent.add(algoliaAgent));\n\n  return defaultAlgoliaAgent;\n}\n","import type { Logger } from '../types/logger';\n\nexport function createNullLogger(): Logger {\n  return {\n    debug(_message: string, _args?: any): Promise<void> {\n      return Promise.resolve();\n    },\n    info(_message: string, _args?: any): Promise<void> {\n      return Promise.resolve();\n    },\n    error(_message: string, _args?: any): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n","import type { Host, StatefulHost } from '../types';\n\n// By default, API Clients at Algolia have expiration delay of 5 mins.\n// In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\n\nexport function createStatefulHost(host: Host, status: StatefulHost['status'] = 'up'): StatefulHost {\n  const lastUpdate = Date.now();\n\n  function isUp(): boolean {\n    return status === 'up' || Date.now() - lastUpdate > EXPIRATION_DELAY;\n  }\n\n  function isTimedOut(): boolean {\n    return status === 'timed out' && Date.now() - lastUpdate <= EXPIRATION_DELAY;\n  }\n\n  return { ...host, status, lastUpdate, isUp, isTimedOut };\n}\n","import type { Response, StackFrame } from '../types';\n\nexport class AlgoliaError extends Error {\n  override name: string = 'AlgoliaError';\n\n  constructor(message: string, name: string) {\n    super(message);\n\n    if (name) {\n      this.name = name;\n    }\n  }\n}\n\nexport class ErrorWithStackTrace extends AlgoliaError {\n  stackTrace: StackFrame[];\n\n  constructor(message: string, stackTrace: StackFrame[], name: string) {\n    super(message, name);\n    // the array and object should be frozen to reflect the stackTrace at the time of the error\n    this.stackTrace = stackTrace;\n  }\n}\n\nexport class RetryError extends ErrorWithStackTrace {\n  constructor(stackTrace: StackFrame[]) {\n    super(\n      'Unreachable hosts - your application id may be incorrect. If the error persists, please reach out to the Algolia Support team: https://alg.li/support.',\n      stackTrace,\n      'RetryError',\n    );\n  }\n}\n\nexport class ApiError extends ErrorWithStackTrace {\n  status: number;\n\n  constructor(message: string, status: number, stackTrace: StackFrame[], name = 'ApiError') {\n    super(message, stackTrace, name);\n    this.status = status;\n  }\n}\n\nexport class DeserializationError extends AlgoliaError {\n  response: Response;\n\n  constructor(message: string, response: Response) {\n    super(message, 'DeserializationError');\n    this.response = response;\n  }\n}\n\nexport type DetailedErrorWithMessage = {\n  message: string;\n  label: string;\n};\n\nexport type DetailedErrorWithTypeID = {\n  id: string;\n  type: string;\n  name?: string;\n};\n\nexport type DetailedError = {\n  code: string;\n  details?: DetailedErrorWithMessage[] | DetailedErrorWithTypeID[];\n};\n\n// DetailedApiError is only used by the ingestion client to return more informative error, other clients will use ApiClient.\nexport class DetailedApiError extends ApiError {\n  error: DetailedError;\n\n  constructor(message: string, status: number, error: DetailedError, stackTrace: StackFrame[]) {\n    super(message, status, stackTrace, 'DetailedApiError');\n    this.error = error;\n  }\n}\n","import type { Headers, Host, QueryParameters, Request, RequestOptions, Response, StackFrame } from '../types';\nimport { ApiError, DeserializationError, DetailedApiError } from './errors';\n\nexport function shuffle<TData>(array: TData[]): TData[] {\n  const shuffledArray = array;\n\n  for (let c = array.length - 1; c > 0; c--) {\n    const b = Math.floor(Math.random() * (c + 1));\n    const a = array[c];\n\n    shuffledArray[c] = array[b];\n    shuffledArray[b] = a;\n  }\n\n  return shuffledArray;\n}\n\nexport function serializeUrl(host: Host, path: string, queryParameters: QueryParameters): string {\n  const queryParametersAsString = serializeQueryParameters(queryParameters);\n  let url = `${host.protocol}://${host.url}${host.port ? `:${host.port}` : ''}/${\n    path.charAt(0) === '/' ? path.substring(1) : path\n  }`;\n\n  if (queryParametersAsString.length) {\n    url += `?${queryParametersAsString}`;\n  }\n\n  return url;\n}\n\nexport function serializeQueryParameters(parameters: QueryParameters): string {\n  return Object.keys(parameters)\n    .filter((key) => parameters[key] !== undefined)\n    .sort()\n    .map(\n      (key) =>\n        `${key}=${encodeURIComponent(\n          Object.prototype.toString.call(parameters[key]) === '[object Array]'\n            ? parameters[key].join(',')\n            : parameters[key],\n        ).replace(/\\+/g, '%20')}`,\n    )\n    .join('&');\n}\n\nexport function serializeData(request: Request, requestOptions: RequestOptions): string | undefined {\n  if (request.method === 'GET' || (request.data === undefined && requestOptions.data === undefined)) {\n    return undefined;\n  }\n\n  const data = Array.isArray(request.data) ? request.data : { ...request.data, ...requestOptions.data };\n\n  return JSON.stringify(data);\n}\n\nexport function serializeHeaders(\n  baseHeaders: Headers,\n  requestHeaders: Headers,\n  requestOptionsHeaders?: Headers,\n): Headers {\n  const headers: Headers = {\n    Accept: 'application/json',\n    ...baseHeaders,\n    ...requestHeaders,\n    ...requestOptionsHeaders,\n  };\n  const serializedHeaders: Headers = {};\n\n  Object.keys(headers).forEach((header) => {\n    const value = headers[header];\n    serializedHeaders[header.toLowerCase()] = value;\n  });\n\n  return serializedHeaders;\n}\n\nexport function deserializeSuccess<TObject>(response: Response): TObject {\n  try {\n    return JSON.parse(response.content);\n  } catch (e) {\n    throw new DeserializationError((e as Error).message, response);\n  }\n}\n\nexport function deserializeFailure({ content, status }: Response, stackFrame: StackFrame[]): Error {\n  try {\n    const parsed = JSON.parse(content);\n    if ('error' in parsed) {\n      return new DetailedApiError(parsed.message, status, parsed.error, stackFrame);\n    }\n    return new ApiError(parsed.message, status, stackFrame);\n  } catch {\n    // ..\n  }\n  return new ApiError(content, status, stackFrame);\n}\n","import type { Response } from '../types';\n\nexport function isNetworkError({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return !isTimedOut && ~~status === 0;\n}\n\nexport function isRetryable({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return isTimedOut || isNetworkError({ isTimedOut, status }) || (~~(status / 100) !== 2 && ~~(status / 100) !== 4);\n}\n\nexport function isSuccess({ status }: Pick<Response, 'status'>): boolean {\n  return ~~(status / 100) === 2;\n}\n","import type { Headers, StackFrame } from '../types';\n\nexport function stackTraceWithoutCredentials(stackTrace: StackFrame[]): StackFrame[] {\n  return stackTrace.map((stackFrame) => stackFrameWithoutCredentials(stackFrame));\n}\n\nexport function stackFrameWithoutCredentials(stackFrame: StackFrame): StackFrame {\n  const modifiedHeaders: Headers = stackFrame.request.headers['x-algolia-api-key']\n    ? { 'x-algolia-api-key': '*****' }\n    : {};\n\n  return {\n    ...stackFrame,\n    request: {\n      ...stackFrame.request,\n      headers: {\n        ...stackFrame.request.headers,\n        ...modifiedHeaders,\n      },\n    },\n  };\n}\n","import type {\n  EndRequest,\n  Host,\n  QueryParameters,\n  Request,\n  RequestOptions,\n  Response,\n  StackFrame,\n  Transporter,\n  TransporterOptions,\n} from '../types';\nimport { createStatefulHost } from './createStatefulHost';\nimport { RetryError } from './errors';\nimport { deserializeFailure, deserializeSuccess, serializeData, serializeHeaders, serializeUrl } from './helpers';\nimport { isRetryable, isSuccess } from './responses';\nimport { stackFrameWithoutCredentials, stackTraceWithoutCredentials } from './stackTrace';\n\ntype RetryableOptions = {\n  hosts: Host[];\n  getTimeout: (retryCount: number, timeout: number) => number;\n};\n\nexport function createTransporter({\n  hosts,\n  hostsCache,\n  baseHeaders,\n  logger,\n  baseQueryParameters,\n  algoliaAgent,\n  timeouts,\n  requester,\n  requestsCache,\n  responsesCache,\n}: TransporterOptions): Transporter {\n  async function createRetryableOptions(compatibleHosts: Host[]): Promise<RetryableOptions> {\n    const statefulHosts = await Promise.all(\n      compatibleHosts.map((compatibleHost) => {\n        return hostsCache.get(compatibleHost, () => {\n          return Promise.resolve(createStatefulHost(compatibleHost));\n        });\n      }),\n    );\n    const hostsUp = statefulHosts.filter((host) => host.isUp());\n    const hostsTimedOut = statefulHosts.filter((host) => host.isTimedOut());\n\n    // Note, we put the hosts that previously timed out on the end of the list.\n    const hostsAvailable = [...hostsUp, ...hostsTimedOut];\n    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;\n\n    return {\n      hosts: compatibleHostsAvailable,\n      getTimeout(timeoutsCount: number, baseTimeout: number): number {\n        /**\n         * Imagine that you have 4 hosts, if timeouts will increase\n         * on the following way: 1 (timed out) > 4 (timed out) > 5 (200).\n         *\n         * Note that, the very next request, we start from the previous timeout.\n         *\n         *  5 (timed out) > 6 (timed out) > 7 ...\n         *\n         * This strategy may need to be reviewed, but is the strategy on the our\n         * current v3 version.\n         */\n        const timeoutMultiplier =\n          hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;\n\n        return timeoutMultiplier * baseTimeout;\n      },\n    };\n  }\n\n  async function retryableRequest<TResponse>(\n    request: Request,\n    requestOptions: RequestOptions,\n    isRead = true,\n  ): Promise<TResponse> {\n    const stackTrace: StackFrame[] = [];\n\n    /**\n     * First we prepare the payload that do not depend from hosts.\n     */\n    const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);\n\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters: QueryParameters =\n      request.method === 'GET'\n        ? {\n            ...request.data,\n            ...requestOptions.data,\n          }\n        : {};\n\n    const queryParameters: QueryParameters = {\n      ...baseQueryParameters,\n      ...request.queryParameters,\n      ...dataQueryParameters,\n    };\n\n    if (algoliaAgent.value) {\n      queryParameters['x-algolia-agent'] = algoliaAgent.value;\n    }\n\n    if (requestOptions && requestOptions.queryParameters) {\n      for (const key of Object.keys(requestOptions.queryParameters)) {\n        // We want to keep `undefined` and `null` values,\n        // but also avoid stringifying `object`s, as they are\n        // handled in the `serializeUrl` step right after.\n        if (\n          !requestOptions.queryParameters[key] ||\n          Object.prototype.toString.call(requestOptions.queryParameters[key]) === '[object Object]'\n        ) {\n          queryParameters[key] = requestOptions.queryParameters[key];\n        } else {\n          queryParameters[key] = requestOptions.queryParameters[key].toString();\n        }\n      }\n    }\n\n    let timeoutsCount = 0;\n\n    const retry = async (\n      retryableHosts: Host[],\n      getTimeout: (timeoutsCount: number, timeout: number) => number,\n    ): Promise<TResponse> => {\n      /**\n       * We iterate on each host, until there is no host left.\n       */\n      const host = retryableHosts.pop();\n      if (host === undefined) {\n        throw new RetryError(stackTraceWithoutCredentials(stackTrace));\n      }\n\n      const timeout = { ...timeouts, ...requestOptions.timeouts };\n\n      const payload: EndRequest = {\n        data,\n        headers,\n        method: request.method,\n        url: serializeUrl(host, request.path, queryParameters),\n        connectTimeout: getTimeout(timeoutsCount, timeout.connect),\n        responseTimeout: getTimeout(timeoutsCount, isRead ? timeout.read : timeout.write),\n      };\n\n      /**\n       * The stackFrame is pushed to the stackTrace so we\n       * can have information about onRetry and onFailure\n       * decisions.\n       */\n      const pushToStackTrace = (response: Response): StackFrame => {\n        const stackFrame: StackFrame = {\n          request: payload,\n          response,\n          host,\n          triesLeft: retryableHosts.length,\n        };\n\n        stackTrace.push(stackFrame);\n\n        return stackFrame;\n      };\n\n      const response = await requester.send(payload);\n\n      if (isRetryable(response)) {\n        const stackFrame = pushToStackTrace(response);\n\n        // If response is a timeout, we increase the number of timeouts so we can increase the timeout later.\n        if (response.isTimedOut) {\n          timeoutsCount++;\n        }\n        /**\n         * Failures are individually sent to the logger, allowing\n         * the end user to debug / store stack frames even\n         * when a retry error does not happen.\n         */\n        logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame));\n\n        /**\n         * We also store the state of the host in failure cases. If the host, is\n         * down it will remain down for the next 2 minutes. In a timeout situation,\n         * this host will be added end of the list of hosts on the next request.\n         */\n        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? 'timed out' : 'down'));\n\n        return retry(retryableHosts, getTimeout);\n      }\n\n      if (isSuccess(response)) {\n        return deserializeSuccess(response);\n      }\n\n      pushToStackTrace(response);\n      throw deserializeFailure(response, stackTrace);\n    };\n\n    /**\n     * Finally, for each retryable host perform request until we got a non\n     * retryable response. Some notes here:\n     *\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\n     * for the current context.\n     */\n    const compatibleHosts = hosts.filter(\n      (host) => host.accept === 'readWrite' || (isRead ? host.accept === 'read' : host.accept === 'write'),\n    );\n    const options = await createRetryableOptions(compatibleHosts);\n\n    return retry([...options.hosts].reverse(), options.getTimeout);\n  }\n\n  function createRequest<TResponse>(request: Request, requestOptions: RequestOptions = {}): Promise<TResponse> {\n    /**\n     * A read request is either a `GET` request, or a request that we make\n     * via the `read` transporter (e.g. `search`).\n     */\n    const isRead = request.useReadTransporter || request.method === 'GET';\n    if (!isRead) {\n      /**\n       * On write requests, no cache mechanisms are applied, and we\n       * proxy the request immediately to the requester.\n       */\n      return retryableRequest<TResponse>(request, requestOptions, isRead);\n    }\n\n    const createRetryableRequest = (): Promise<TResponse> => {\n      /**\n       * Then, we prepare a function factory that contains the construction of\n       * the retryable request. At this point, we may *not* perform the actual\n       * request. But we want to have the function factory ready.\n       */\n      return retryableRequest<TResponse>(request, requestOptions);\n    };\n\n    /**\n     * Once we have the function factory ready, we need to determine of the\n     * request is \"cacheable\" - should be cached. Note that, once again,\n     * the user can force this option.\n     */\n    const cacheable = requestOptions.cacheable || request.cacheable;\n\n    /**\n     * If is not \"cacheable\", we immediately trigger the retryable request, no\n     * need to check cache implementations.\n     */\n    if (cacheable !== true) {\n      return createRetryableRequest();\n    }\n\n    /**\n     * If the request is \"cacheable\", we need to first compute the key to ask\n     * the cache implementations if this request is on progress or if the\n     * response already exists on the cache.\n     */\n    const key = {\n      request,\n      requestOptions,\n      transporter: {\n        queryParameters: baseQueryParameters,\n        headers: baseHeaders,\n      },\n    };\n\n    /**\n     * With the computed key, we first ask the responses cache\n     * implementation if this request was been resolved before.\n     */\n    return responsesCache.get(\n      key,\n      () => {\n        /**\n         * If the request has never resolved before, we actually ask if there\n         * is a current request with the same key on progress.\n         */\n        return requestsCache.get(key, () =>\n          /**\n           * Finally, if there is no request in progress with the same key,\n           * this `createRetryableRequest()` will actually trigger the\n           * retryable request.\n           */\n          requestsCache\n            .set(key, createRetryableRequest())\n            .then(\n              (response) => Promise.all([requestsCache.delete(key), response]),\n              (err) => Promise.all([requestsCache.delete(key), Promise.reject(err)]),\n            )\n            .then(([_, response]) => response),\n        );\n      },\n      {\n        /**\n         * Of course, once we get this response back from the server, we\n         * tell response cache to actually store the received response\n         * to be used later.\n         */\n        miss: (response) => responsesCache.set(key, response),\n      },\n    );\n  }\n\n  return {\n    hostsCache,\n    requester,\n    timeouts,\n    logger,\n    algoliaAgent,\n    baseHeaders,\n    baseQueryParameters,\n    hosts,\n    request: createRequest,\n    requestsCache,\n    responsesCache,\n  };\n}\n","export const LogLevelEnum: Readonly<Record<string, LogLevelType>> = {\n  Debug: 1,\n  Info: 2,\n  Error: 3,\n};\n\nexport type LogLevelType = 1 | 2 | 3;\n\nexport type Logger = {\n  /**\n   * Logs debug messages.\n   */\n  debug: (message: string, args?: any) => Promise<void>;\n\n  /**\n   * Logs info messages.\n   */\n  info: (message: string, args?: any) => Promise<void>;\n\n  /**\n   * Logs error messages.\n   */\n  error: (message: string, args?: any) => Promise<void>;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}