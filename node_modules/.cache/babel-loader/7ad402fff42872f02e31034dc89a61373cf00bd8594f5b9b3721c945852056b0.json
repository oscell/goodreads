{"ast":null,"code":"import $8t1z9$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useColorAreaGradient as $40297c24c53588e6$export$dd62420467d245ca } from \"./useColorAreaGradient.mjs\";\nimport { useGlobalListeners as $8t1z9$useGlobalListeners, focusWithoutScrolling as $8t1z9$focusWithoutScrolling, useFormReset as $8t1z9$useFormReset, mergeProps as $8t1z9$mergeProps, isIOS as $8t1z9$isIOS, isAndroid as $8t1z9$isAndroid, useLabels as $8t1z9$useLabels } from \"@react-aria/utils\";\nimport { useState as $8t1z9$useState, useCallback as $8t1z9$useCallback, useRef as $8t1z9$useRef } from \"react\";\nimport { useKeyboard as $8t1z9$useKeyboard, useMove as $8t1z9$useMove, useFocusWithin as $8t1z9$useFocusWithin, useFocus as $8t1z9$useFocus } from \"@react-aria/interactions\";\nimport { useLocalizedStringFormatter as $8t1z9$useLocalizedStringFormatter, useLocale as $8t1z9$useLocale } from \"@react-aria/i18n\";\nimport { useVisuallyHidden as $8t1z9$useVisuallyHidden } from \"@react-aria/visually-hidden\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $60bd7d6e45dcddfa$export$2f92a7a615a014f6(props, state) {\n  let {\n    isDisabled: isDisabled,\n    inputXRef: inputXRef,\n    inputYRef: inputYRef,\n    containerRef: containerRef,\n    'aria-label': ariaLabel,\n    xName: xName,\n    yName: yName\n  } = props;\n  let stringFormatter = (0, $8t1z9$useLocalizedStringFormatter)((0, $parcel$interopDefault($8t1z9$intlStringsmodulejs)), '@react-aria/color');\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $8t1z9$useGlobalListeners)();\n  let {\n    direction: direction,\n    locale: locale\n  } = (0, $8t1z9$useLocale)();\n  let [focusedInput, setFocusedInput] = (0, $8t1z9$useState)(null);\n  let focusInput = (0, $8t1z9$useCallback)((inputRef = inputXRef) => {\n    if (inputRef.current) (0, $8t1z9$focusWithoutScrolling)(inputRef.current);\n  }, [inputXRef]);\n  (0, $8t1z9$useFormReset)(inputXRef, [state.xValue, state.yValue], ([x, y]) => {\n    let newColor = state.value.withChannelValue(state.channels.xChannel, x).withChannelValue(state.channels.yChannel, y);\n    state.setValue(newColor);\n  });\n  let [valueChangedViaKeyboard, setValueChangedViaKeyboard] = (0, $8t1z9$useState)(false);\n  let [valueChangedViaInputChangeEvent, setValueChangedViaInputChangeEvent] = (0, $8t1z9$useState)(false);\n  let {\n    xChannel: xChannel,\n    yChannel: yChannel,\n    zChannel: zChannel\n  } = state.channels;\n  let xChannelStep = state.xChannelStep;\n  let yChannelStep = state.yChannelStep;\n  let currentPosition = (0, $8t1z9$useRef)(null);\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $8t1z9$useKeyboard)({\n    onKeyDown(e) {\n      // these are the cases that useMove doesn't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us\n      e.preventDefault();\n      // remember to set this and unset it so that onChangeEnd is fired\n      state.setDragging(true);\n      setValueChangedViaKeyboard(true);\n      let dir;\n      switch (e.key) {\n        case 'PageUp':\n          state.incrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'PageDown':\n          state.decrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'Home':\n          direction === 'rtl' ? state.incrementX(state.xChannelPageStep) : state.decrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n        case 'End':\n          direction === 'rtl' ? state.decrementX(state.xChannelPageStep) : state.incrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n      }\n      state.setDragging(false);\n      if (dir) {\n        let input = dir === 'x' ? inputXRef : inputYRef;\n        focusInput(input);\n        setFocusedInput(dir);\n      }\n    }\n  });\n  let moveHandler = {\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setDragging(true);\n    },\n    onMove({\n      deltaX: deltaX,\n      deltaY: deltaY,\n      pointerType: pointerType,\n      shiftKey: shiftKey\n    }) {\n      var _containerRef_current;\n      let {\n        incrementX: incrementX,\n        decrementX: decrementX,\n        incrementY: incrementY,\n        decrementY: decrementY,\n        xChannelPageStep: xChannelPageStep,\n        xChannelStep: xChannelStep,\n        yChannelPageStep: yChannelPageStep,\n        yChannelStep: yChannelStep,\n        getThumbPosition: getThumbPosition,\n        setColorFromPoint: setColorFromPoint\n      } = state;\n      if (currentPosition.current == null) currentPosition.current = getThumbPosition();\n      let {\n        width: width,\n        height: height\n      } = ((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0\n      };\n      let valueChanged = deltaX !== 0 || deltaY !== 0;\n      if (pointerType === 'keyboard') {\n        let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;\n        let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;\n        if (deltaX > 0 && direction === 'ltr' || deltaX < 0 && direction === 'rtl') incrementX(deltaXValue);else if (deltaX < 0 && direction === 'ltr' || deltaX > 0 && direction === 'rtl') decrementX(deltaXValue);else if (deltaY > 0) decrementY(deltaYValue);else if (deltaY < 0) incrementY(deltaYValue);\n        setValueChangedViaKeyboard(valueChanged);\n        // set the focused input based on which axis has the greater delta\n        focusedInput = valueChanged && Math.abs(deltaY) > Math.abs(deltaX) ? 'y' : 'x';\n        setFocusedInput(focusedInput);\n      } else {\n        currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width;\n        currentPosition.current.y += deltaY / height;\n        setColorFromPoint(currentPosition.current.x, currentPosition.current.y);\n      }\n    },\n    onMoveEnd() {\n      isOnColorArea.current = false;\n      state.setDragging(false);\n      let input = focusedInput === 'x' ? inputXRef : inputYRef;\n      focusInput(input);\n    }\n  };\n  let {\n    moveProps: movePropsThumb\n  } = (0, $8t1z9$useMove)(moveHandler);\n  let {\n    focusWithinProps: focusWithinProps\n  } = (0, $8t1z9$useFocusWithin)({\n    onFocusWithinChange: focusWithin => {\n      if (!focusWithin) {\n        setValueChangedViaKeyboard(false);\n        setValueChangedViaInputChangeEvent(false);\n      }\n    }\n  });\n  let currentPointer = (0, $8t1z9$useRef)(undefined);\n  let isOnColorArea = (0, $8t1z9$useRef)(false);\n  let {\n    moveProps: movePropsContainer\n  } = (0, $8t1z9$useMove)({\n    onMoveStart() {\n      if (isOnColorArea.current) moveHandler.onMoveStart();\n    },\n    onMove(e) {\n      if (isOnColorArea.current) moveHandler.onMove(e);\n    },\n    onMoveEnd() {\n      if (isOnColorArea.current) moveHandler.onMoveEnd();\n    }\n  });\n  let onThumbDown = id => {\n    if (!state.isDragging) {\n      currentPointer.current = id;\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onThumbUp, false);else {\n        addGlobalListener(window, 'mouseup', onThumbUp, false);\n        addGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n  let onThumbUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(false);\n      currentPointer.current = undefined;\n      isOnColorArea.current = false;\n      if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onThumbUp, false);else {\n        removeGlobalListener(window, 'mouseup', onThumbUp, false);\n        removeGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n  let onColorAreaDown = (colorArea, id, clientX, clientY) => {\n    let rect = colorArea.getBoundingClientRect();\n    let {\n      width: width,\n      height: height\n    } = rect;\n    let x = (clientX - rect.x) / width;\n    let y = (clientY - rect.y) / height;\n    if (direction === 'rtl') x = 1 - x;\n    if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {\n      isOnColorArea.current = true;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = id;\n      state.setColorFromPoint(x, y);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') addGlobalListener(window, 'pointerup', onColorAreaUp, false);else {\n        addGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        addGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n  let onColorAreaUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (isOnColorArea.current && id === currentPointer.current) {\n      isOnColorArea.current = false;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = undefined;\n      state.setDragging(false);\n      focusInput();\n      if (typeof PointerEvent !== 'undefined') removeGlobalListener(window, 'pointerup', onColorAreaUp, false);else {\n        removeGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        removeGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n  let colorAreaInteractions = isDisabled ? {} : (0, $8t1z9$mergeProps)({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: e => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);\n      }\n    } : {\n      onMouseDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);\n      },\n      onTouchStart: e => {\n        onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      }\n    })\n  }, movePropsContainer);\n  let thumbInteractions = isDisabled ? {} : (0, $8t1z9$mergeProps)({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: e => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onThumbDown(e.pointerId);\n      }\n    } : {\n      onMouseDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onThumbDown(undefined);\n      },\n      onTouchStart: e => {\n        onThumbDown(e.changedTouches[0].identifier);\n      }\n    })\n  }, focusWithinProps, keyboardProps, movePropsThumb);\n  let {\n    focusProps: xInputFocusProps\n  } = (0, $8t1z9$useFocus)({\n    onFocus: () => {\n      setFocusedInput('x');\n    }\n  });\n  let {\n    focusProps: yInputFocusProps\n  } = (0, $8t1z9$useFocus)({\n    onFocus: () => {\n      setFocusedInput('y');\n    }\n  });\n  const onChange = e => {\n    const {\n      target: target\n    } = e;\n    setValueChangedViaInputChangeEvent(true);\n    if (target === inputXRef.current) state.setXValue(parseFloat(target.value));else if (target === inputYRef.current) state.setYValue(parseFloat(target.value));\n  };\n  let isMobile = (0, $8t1z9$isIOS)() || (0, $8t1z9$isAndroid)();\n  let value = state.getDisplayColor();\n  const getAriaValueTextForChannel = (0, $8t1z9$useCallback)(channel => {\n    const isAfterInput = valueChangedViaInputChangeEvent || valueChangedViaKeyboard;\n    return `${isAfterInput ? stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel, locale),\n      value: value.formatChannelValue(channel, locale)\n    }) : [stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel, locale),\n      value: value.formatChannelValue(channel, locale)\n    }), stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(channel === yChannel ? xChannel : yChannel, locale),\n      value: value.formatChannelValue(channel === yChannel ? xChannel : yChannel, locale)\n    }), stringFormatter.format('colorNameAndValue', {\n      name: value.getChannelName(zChannel, locale),\n      value: value.formatChannelValue(zChannel, locale)\n    })].join(', ')}, ${value.getColorName(locale)}`;\n  }, [locale, value, stringFormatter, valueChangedViaInputChangeEvent, valueChangedViaKeyboard, xChannel, yChannel, zChannel]);\n  let colorPickerLabel = stringFormatter.format('colorPicker');\n  let xInputLabellingProps = (0, $8t1z9$useLabels)({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {\n      label: ariaLabel,\n      channelLabel: colorPickerLabel\n    }) : colorPickerLabel\n  });\n  let yInputLabellingProps = (0, $8t1z9$useLabels)({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {\n      label: ariaLabel,\n      channelLabel: colorPickerLabel\n    }) : colorPickerLabel\n  });\n  let colorAreaLabellingProps = (0, $8t1z9$useLabels)({\n    ...props,\n    'aria-label': ariaLabel ? `${ariaLabel}, ${colorPickerLabel}` : undefined\n  }, isMobile ? colorPickerLabel : undefined);\n  let ariaRoleDescription = stringFormatter.format('twoDimensionalSlider');\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = (0, $8t1z9$useVisuallyHidden)({\n    style: {\n      opacity: '0.0001',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none'\n    }\n  });\n  let {\n    colorAreaStyleProps: colorAreaStyleProps,\n    thumbStyleProps: thumbStyleProps\n  } = (0, $40297c24c53588e6$export$dd62420467d245ca)({\n    direction: direction,\n    state: state,\n    xChannel: xChannel,\n    yChannel: yChannel,\n    zChannel: zChannel\n  });\n  return {\n    colorAreaProps: {\n      ...colorAreaLabellingProps,\n      ...colorAreaInteractions,\n      ...colorAreaStyleProps,\n      role: 'group'\n    },\n    thumbProps: {\n      ...thumbInteractions,\n      ...thumbStyleProps,\n      role: 'presentation'\n    },\n    xInputProps: {\n      ...xInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...xInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(xChannel).minValue,\n      max: state.value.getChannelRange(xChannel).maxValue,\n      step: xChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(xChannel),\n      'aria-orientation': 'horizontal',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(xChannel),\n      name: xName,\n      tabIndex: isMobile || !focusedInput || focusedInput === 'x' ? undefined : -1,\n      /*\n      So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n      add aria-hidden=\"true\" to the unfocused control when the value has not changed via the keyboard,\n      but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': isMobile || !focusedInput || focusedInput === 'x' || valueChangedViaKeyboard ? undefined : 'true',\n      onChange: onChange\n    },\n    yInputProps: {\n      ...yInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...yInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(yChannel).minValue,\n      max: state.value.getChannelRange(yChannel).maxValue,\n      step: yChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(yChannel),\n      'aria-orientation': 'vertical',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(yChannel),\n      name: yName,\n      tabIndex: isMobile || focusedInput === 'y' ? undefined : -1,\n      /*\n      So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n      add aria-hidden=\"true\" to the unfocused input when the value has not changed via the keyboard,\n      but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': isMobile || focusedInput === 'y' || valueChangedViaKeyboard ? undefined : 'true',\n      onChange: onChange\n    }\n  };\n}\nexport { $60bd7d6e45dcddfa$export$2f92a7a615a014f6 as useColorArea };","map":{"version":3,"names":["$60bd7d6e45dcddfa$export$2f92a7a615a014f6","props","state","isDisabled","inputXRef","inputYRef","containerRef","ariaLabel","xName","yName","stringFormatter","$8t1z9$useLocalizedStringFormatter","$parcel$interopDefault","$8t1z9$intlStringsmodulejs","addGlobalListener","removeGlobalListener","$8t1z9$useGlobalListeners","direction","locale","$8t1z9$useLocale","focusedInput","setFocusedInput","$8t1z9$useState","focusInput","$8t1z9$useCallback","inputRef","current","$8t1z9$focusWithoutScrolling","$8t1z9$useFormReset","xValue","yValue","x","y","newColor","value","withChannelValue","channels","xChannel","yChannel","setValue","valueChangedViaKeyboard","setValueChangedViaKeyboard","valueChangedViaInputChangeEvent","setValueChangedViaInputChangeEvent","zChannel","xChannelStep","yChannelStep","currentPosition","$8t1z9$useRef","keyboardProps","$8t1z9$useKeyboard","onKeyDown","e","test","key","continuePropagation","preventDefault","setDragging","dir","incrementY","yChannelPageStep","decrementY","incrementX","xChannelPageStep","decrementX","input","moveHandler","onMoveStart","onMove","deltaX","deltaY","pointerType","shiftKey","_containerRef_current","getThumbPosition","setColorFromPoint","width","height","getBoundingClientRect","valueChanged","deltaXValue","deltaYValue","Math","abs","onMoveEnd","isOnColorArea","moveProps","movePropsThumb","$8t1z9$useMove","focusWithinProps","$8t1z9$useFocusWithin","onFocusWithinChange","focusWithin","currentPointer","undefined","movePropsContainer","onThumbDown","id","isDragging","PointerEvent","window","onThumbUp","_e_changedTouches","_e_pointerId","pointerId","changedTouches","identifier","onColorAreaDown","colorArea","clientX","clientY","rect","onColorAreaUp","colorAreaInteractions","$8t1z9$mergeProps","onPointerDown","button","altKey","ctrlKey","metaKey","currentTarget","onMouseDown","onTouchStart","thumbInteractions","focusProps","xInputFocusProps","$8t1z9$useFocus","onFocus","yInputFocusProps","onChange","target","setXValue","parseFloat","setYValue","isMobile","$8t1z9$isIOS","$8t1z9$isAndroid","getDisplayColor","getAriaValueTextForChannel","channel","isAfterInput","format","name","getChannelName","formatChannelValue","join","getColorName","colorPickerLabel","xInputLabellingProps","$8t1z9$useLabels","label","channelLabel","yInputLabellingProps","colorAreaLabellingProps","ariaRoleDescription","visuallyHiddenProps","$8t1z9$useVisuallyHidden","style","opacity","pointerEvents","colorAreaStyleProps","thumbStyleProps","$40297c24c53588e6$export$dd62420467d245ca","colorAreaProps","role","thumbProps","xInputProps","type","min","getChannelRange","minValue","max","maxValue","step","disabled","getChannelValue","tabIndex","yInputProps"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-aria/color/dist/packages/@react-aria/color/src/useColorArea.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaColorAreaProps, ColorChannel} from '@react-types/color';\nimport {ColorAreaState} from '@react-stately/color';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {focusWithoutScrolling, isAndroid, isIOS, mergeProps, useFormReset, useGlobalListeners, useLabels} from '@react-aria/utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport React, {ChangeEvent, InputHTMLAttributes, useCallback, useRef, useState} from 'react';\nimport {useColorAreaGradient} from './useColorAreaGradient';\nimport {useFocus, useFocusWithin, useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLocale, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface ColorAreaAria {\n  /** Props for the color area container element. */\n  colorAreaProps: DOMAttributes,\n  /** Props for the thumb element. */\n  thumbProps: DOMAttributes,\n  /** Props for the visually hidden horizontal range input element. */\n  xInputProps: InputHTMLAttributes<HTMLInputElement>,\n  /** Props for the visually hidden vertical range input element. */\n  yInputProps: InputHTMLAttributes<HTMLInputElement>\n}\n\nexport interface AriaColorAreaOptions extends AriaColorAreaProps {\n  /** A ref to the input that represents the x axis of the color area. */\n  inputXRef: RefObject<HTMLInputElement | null>,\n  /** A ref to the input that represents the y axis of the color area. */\n  inputYRef: RefObject<HTMLInputElement | null>,\n  /** A ref to the color area containing element. */\n  containerRef: RefObject<Element | null>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a color area component.\n * Color area allows users to adjust two channels of an RGB, HSL or HSB color value against a two-dimensional gradient background.\n */\nexport function useColorArea(props: AriaColorAreaOptions, state: ColorAreaState): ColorAreaAria {\n  let {\n    isDisabled,\n    inputXRef,\n    inputYRef,\n    containerRef,\n    'aria-label': ariaLabel,\n    xName,\n    yName\n  } = props;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/color');\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let {direction, locale} = useLocale();\n\n  let [focusedInput, setFocusedInput] = useState<'x' | 'y' | null>(null);\n  let focusInput = useCallback((inputRef:RefObject<HTMLInputElement | null> = inputXRef) => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputXRef]);\n\n  useFormReset(inputXRef, [state.xValue, state.yValue], ([x, y]) => {\n    let newColor = state.value\n      .withChannelValue(state.channels.xChannel, x)\n      .withChannelValue(state.channels.yChannel, y);\n    state.setValue(newColor);\n  });\n\n  let [valueChangedViaKeyboard, setValueChangedViaKeyboard] = useState(false);\n  let [valueChangedViaInputChangeEvent, setValueChangedViaInputChangeEvent] = useState(false);\n  let {xChannel, yChannel, zChannel} = state.channels;\n  let xChannelStep = state.xChannelStep;\n  let yChannelStep = state.yChannelStep;\n\n  let currentPosition = useRef<{x: number, y: number} | null>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      // these are the cases that useMove doesn't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, don't need to stop propagation, useKeyboard will do that for us\n      e.preventDefault();\n      // remember to set this and unset it so that onChangeEnd is fired\n      state.setDragging(true);\n      setValueChangedViaKeyboard(true);\n      let dir;\n      switch (e.key) {\n        case 'PageUp':\n          state.incrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'PageDown':\n          state.decrementY(state.yChannelPageStep);\n          dir = 'y';\n          break;\n        case 'Home':\n          direction === 'rtl' ? state.incrementX(state.xChannelPageStep) : state.decrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n        case 'End':\n          direction === 'rtl' ? state.decrementX(state.xChannelPageStep) : state.incrementX(state.xChannelPageStep);\n          dir = 'x';\n          break;\n      }\n      state.setDragging(false);\n      if (dir) {\n        let input = dir === 'x' ? inputXRef : inputYRef;\n        focusInput(input);\n        setFocusedInput(dir);\n      }\n    }\n  });\n\n  let moveHandler = {\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setDragging(true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      let {\n        incrementX,\n        decrementX,\n        incrementY,\n        decrementY,\n        xChannelPageStep,\n        xChannelStep,\n        yChannelPageStep,\n        yChannelStep,\n        getThumbPosition,\n        setColorFromPoint\n      } = state;\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPosition();\n      }\n      let {width, height} = containerRef.current?.getBoundingClientRect() || {width: 0, height: 0};\n      let valueChanged = deltaX !== 0 || deltaY !== 0;\n      if (pointerType === 'keyboard') {\n        let deltaXValue = shiftKey && xChannelPageStep > xChannelStep ? xChannelPageStep : xChannelStep;\n        let deltaYValue = shiftKey && yChannelPageStep > yChannelStep ? yChannelPageStep : yChannelStep;\n        if ((deltaX > 0 && direction === 'ltr') || (deltaX < 0 && direction === 'rtl')) {\n          incrementX(deltaXValue);\n        } else if ((deltaX < 0 && direction === 'ltr') || (deltaX > 0 && direction === 'rtl')) {\n          decrementX(deltaXValue);\n        } else if (deltaY > 0) {\n          decrementY(deltaYValue);\n        } else if (deltaY < 0) {\n          incrementY(deltaYValue);\n        }\n        setValueChangedViaKeyboard(valueChanged);\n        // set the focused input based on which axis has the greater delta\n        focusedInput = valueChanged && Math.abs(deltaY) > Math.abs(deltaX) ? 'y' : 'x';\n        setFocusedInput(focusedInput);\n      } else {\n        currentPosition.current.x += (direction === 'rtl' ? -1 : 1) * deltaX / width ;\n        currentPosition.current.y += deltaY / height;\n        setColorFromPoint(currentPosition.current.x, currentPosition.current.y);\n      }\n    },\n    onMoveEnd() {\n      isOnColorArea.current = false;\n      state.setDragging(false);\n      let input = focusedInput === 'x' ? inputXRef : inputYRef;\n      focusInput(input);\n    }\n  };\n  let {moveProps: movePropsThumb} = useMove(moveHandler);\n\n  let {focusWithinProps} = useFocusWithin({\n    onFocusWithinChange: (focusWithin:boolean) => {\n      if (!focusWithin) {\n        setValueChangedViaKeyboard(false);\n        setValueChangedViaInputChangeEvent(false);\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let isOnColorArea = useRef<boolean>(false);\n  let {moveProps: movePropsContainer} = useMove({\n    onMoveStart() {\n      if (isOnColorArea.current) {\n        moveHandler.onMoveStart();\n      }\n    },\n    onMove(e) {\n      if (isOnColorArea.current) {\n        moveHandler.onMove(e);\n      }\n    },\n    onMoveEnd() {\n      if (isOnColorArea.current) {\n        moveHandler.onMoveEnd();\n      }\n    }\n  });\n\n  let onThumbDown = (id: number | null | undefined) => {\n    if (!state.isDragging) {\n      currentPointer.current = id;\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(true);\n      if (typeof PointerEvent !== 'undefined') {\n        addGlobalListener(window, 'pointerup', onThumbUp, false);\n      } else {\n        addGlobalListener(window, 'mouseup', onThumbUp, false);\n        addGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n\n  let onThumbUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      setValueChangedViaKeyboard(false);\n      focusInput();\n      state.setDragging(false);\n      currentPointer.current = undefined;\n      isOnColorArea.current = false;\n\n      if (typeof PointerEvent !== 'undefined') {\n        removeGlobalListener(window, 'pointerup', onThumbUp, false);\n      } else {\n        removeGlobalListener(window, 'mouseup', onThumbUp, false);\n        removeGlobalListener(window, 'touchend', onThumbUp, false);\n      }\n    }\n  };\n\n  let onColorAreaDown = (colorArea: Element, id: number | null | undefined, clientX: number, clientY: number) => {\n    let rect = colorArea.getBoundingClientRect();\n    let {width, height} = rect;\n    let x = (clientX - rect.x) / width;\n    let y = (clientY - rect.y) / height;\n    if (direction === 'rtl') {\n      x = 1 - x;\n    }\n    if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && !state.isDragging && currentPointer.current === undefined) {\n      isOnColorArea.current = true;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = id;\n      state.setColorFromPoint(x, y);\n\n      focusInput();\n      state.setDragging(true);\n\n      if (typeof PointerEvent !== 'undefined') {\n        addGlobalListener(window, 'pointerup', onColorAreaUp, false);\n      } else {\n        addGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        addGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n\n  let onColorAreaUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (isOnColorArea.current && id === currentPointer.current) {\n      isOnColorArea.current = false;\n      setValueChangedViaKeyboard(false);\n      currentPointer.current = undefined;\n      state.setDragging(false);\n      focusInput();\n\n      if (typeof PointerEvent !== 'undefined') {\n        removeGlobalListener(window, 'pointerup', onColorAreaUp, false);\n      } else {\n        removeGlobalListener(window, 'mouseup', onColorAreaUp, false);\n        removeGlobalListener(window, 'touchend', onColorAreaUp, false);\n      }\n    }\n  };\n\n  let colorAreaInteractions = isDisabled ? {} : mergeProps({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onColorAreaDown(e.currentTarget, e.pointerId, e.clientX, e.clientY);\n      }} : {\n        onMouseDown: (e: React.MouseEvent) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onColorAreaDown(e.currentTarget, undefined, e.clientX, e.clientY);\n        },\n        onTouchStart: (e: React.TouchEvent) => {\n          onColorAreaDown(e.currentTarget, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n        }\n      })\n  }, movePropsContainer);\n\n  let thumbInteractions = isDisabled ? {} : mergeProps({\n    ...(typeof PointerEvent !== 'undefined' ? {\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onThumbDown(e.pointerId);\n      }} : {\n        onMouseDown: (e: React.MouseEvent) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onThumbDown(undefined);\n        },\n        onTouchStart: (e: React.TouchEvent) => {\n          onThumbDown(e.changedTouches[0].identifier);\n        }\n      })\n  }, focusWithinProps, keyboardProps, movePropsThumb);\n\n  let {focusProps: xInputFocusProps} = useFocus({\n    onFocus: () => {\n      setFocusedInput('x');\n    }\n  });\n\n  let {focusProps: yInputFocusProps} = useFocus({\n    onFocus: () => {\n      setFocusedInput('y');\n    }\n  });\n\n  const onChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const {target} = e;\n    setValueChangedViaInputChangeEvent(true);\n    if (target === inputXRef.current) {\n      state.setXValue(parseFloat(target.value));\n    } else if (target === inputYRef.current) {\n      state.setYValue(parseFloat(target.value));\n    }\n  };\n\n  let isMobile = isIOS() || isAndroid();\n\n  let value = state.getDisplayColor();\n  const getAriaValueTextForChannel = useCallback((channel:ColorChannel) => {\n    const isAfterInput = valueChangedViaInputChangeEvent || valueChangedViaKeyboard;\n    return `${\n      isAfterInput ?\n      stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel, locale), value: value.formatChannelValue(channel, locale)})\n      :\n      [\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel, locale), value: value.formatChannelValue(channel, locale)}),\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(channel === yChannel ? xChannel : yChannel, locale), value: value.formatChannelValue(channel === yChannel ? xChannel : yChannel, locale)}),\n        stringFormatter.format('colorNameAndValue', {name: value.getChannelName(zChannel, locale), value: value.formatChannelValue(zChannel, locale)})\n      ].join(', ')\n    }, ${value.getColorName(locale)}`;\n  }, [locale, value, stringFormatter, valueChangedViaInputChangeEvent, valueChangedViaKeyboard, xChannel, yChannel, zChannel]);\n\n  let colorPickerLabel = stringFormatter.format('colorPicker');\n\n  let xInputLabellingProps = useLabels({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {label: ariaLabel, channelLabel: colorPickerLabel}) : colorPickerLabel\n  });\n\n  let yInputLabellingProps = useLabels({\n    ...props,\n    'aria-label': ariaLabel ? stringFormatter.format('colorInputLabel', {label: ariaLabel, channelLabel: colorPickerLabel}) : colorPickerLabel\n  });\n\n  let colorAreaLabellingProps = useLabels(\n    {\n      ...props,\n      'aria-label': ariaLabel ? `${ariaLabel}, ${colorPickerLabel}` : undefined\n    },\n    isMobile ? colorPickerLabel : undefined\n  );\n\n  let ariaRoleDescription = stringFormatter.format('twoDimensionalSlider');\n\n  let {visuallyHiddenProps} = useVisuallyHidden({style: {\n    opacity: '0.0001',\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none'\n  }});\n\n  let {\n    colorAreaStyleProps,\n    thumbStyleProps\n  } = useColorAreaGradient({\n    direction,\n    state,\n    xChannel,\n    yChannel,\n    zChannel\n  });\n\n  return {\n    colorAreaProps: {\n      ...colorAreaLabellingProps,\n      ...colorAreaInteractions,\n      ...colorAreaStyleProps,\n      role: 'group'\n    },\n    thumbProps: {\n      ...thumbInteractions,\n      ...thumbStyleProps,\n      role: 'presentation'\n    },\n    xInputProps: {\n      ...xInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...xInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(xChannel).minValue,\n      max: state.value.getChannelRange(xChannel).maxValue,\n      step: xChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(xChannel),\n      'aria-orientation': 'horizontal',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(xChannel),\n      name: xName,\n      tabIndex: (isMobile || !focusedInput || focusedInput === 'x' ? undefined : -1),\n      /*\n        So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n        add aria-hidden=\"true\" to the unfocused control when the value has not changed via the keyboard,\n        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': (isMobile || !focusedInput || focusedInput === 'x' || valueChangedViaKeyboard ? undefined : 'true'),\n      onChange\n    },\n    yInputProps: {\n      ...yInputLabellingProps,\n      ...visuallyHiddenProps,\n      ...yInputFocusProps,\n      type: 'range',\n      min: state.value.getChannelRange(yChannel).minValue,\n      max: state.value.getChannelRange(yChannel).maxValue,\n      step: yChannelStep,\n      'aria-roledescription': ariaRoleDescription,\n      'aria-valuetext': getAriaValueTextForChannel(yChannel),\n      'aria-orientation': 'vertical',\n      'aria-describedby': props['aria-describedby'],\n      'aria-details': props['aria-details'],\n      disabled: isDisabled,\n      value: state.value.getChannelValue(yChannel),\n      name: yName,\n      tabIndex: (isMobile || focusedInput === 'y' ? undefined : -1),\n      /*\n        So that only a single \"2d slider\" control shows up when listing form elements for screen readers,\n        add aria-hidden=\"true\" to the unfocused input when the value has not changed via the keyboard,\n        but remove aria-hidden to reveal the input for each channel when the value has changed with the keyboard.\n      */\n      'aria-hidden': (isMobile || focusedInput === 'y' || valueChangedViaKeyboard ? undefined : 'true'),\n      onChange\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}