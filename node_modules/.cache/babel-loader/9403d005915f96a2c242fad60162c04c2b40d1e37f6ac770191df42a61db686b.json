{"ast":null,"code":"import { beginDragging as $67560de7c78cb232$export$549dbcf8649bf3b2 } from \"./DragManager.mjs\";\nimport { DROP_EFFECT_TO_DROP_OPERATION as $103790afe9474d1c$export$608ecc6f1b23c35d, DROP_OPERATION as $103790afe9474d1c$export$60b7b4bcf3903d8e, EFFECT_ALLOWED as $103790afe9474d1c$export$dd0165308d8bff45 } from \"./constants.mjs\";\nimport { globalDropEffect as $7252cd45fc48c07c$export$8e6636520ac15722, setGlobalAllowedDropOperations as $7252cd45fc48c07c$export$6539bc8c3a0a2d67, setGlobalDropEffect as $7252cd45fc48c07c$export$64f52ed7349ddb84, useDragModality as $7252cd45fc48c07c$export$49bac5d6d4b352ea, writeToDataTransfer as $7252cd45fc48c07c$export$f9c1490890ddd063 } from \"./utils.mjs\";\nimport $72Evg$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useRef as $72Evg$useRef, useState as $72Evg$useState } from \"react\";\nimport { useGlobalListeners as $72Evg$useGlobalListeners, useLayoutEffect as $72Evg$useLayoutEffect, useDescription as $72Evg$useDescription, isVirtualPointerEvent as $72Evg$isVirtualPointerEvent, isVirtualClick as $72Evg$isVirtualClick } from \"@react-aria/utils\";\nimport { useLocalizedStringFormatter as $72Evg$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $8253ed7ece74b463$var$MESSAGES = {\n  keyboard: {\n    start: 'dragDescriptionKeyboard',\n    end: 'endDragKeyboard'\n  },\n  touch: {\n    start: 'dragDescriptionTouch',\n    end: 'endDragTouch'\n  },\n  virtual: {\n    start: 'dragDescriptionVirtual',\n    end: 'endDragVirtual'\n  }\n};\nfunction $8253ed7ece74b463$export$7941f8aafa4b6021(options) {\n  let {\n    hasDragButton: hasDragButton,\n    isDisabled: isDisabled\n  } = options;\n  let stringFormatter = (0, $72Evg$useLocalizedStringFormatter)((0, $parcel$interopDefault($72Evg$intlStringsmodulejs)), '@react-aria/dnd');\n  let state = (0, $72Evg$useRef)({\n    options: options,\n    x: 0,\n    y: 0\n  }).current;\n  state.options = options;\n  let isDraggingRef = (0, $72Evg$useRef)(false);\n  let [isDragging, setDraggingState] = (0, $72Evg$useState)(false);\n  let setDragging = isDragging => {\n    isDraggingRef.current = isDragging;\n    setDraggingState(isDragging);\n  };\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $72Evg$useGlobalListeners)();\n  let modalityOnPointerDown = (0, $72Evg$useRef)(null);\n  let onDragStart = e => {\n    var _options_preview;\n    if (e.defaultPrevented) return;\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n    // If this drag was initiated by a mobile screen reader (e.g. VoiceOver or TalkBack), enter virtual dragging mode.\n    if (modalityOnPointerDown.current === 'virtual') {\n      e.preventDefault();\n      startDragging(e.target);\n      modalityOnPointerDown.current = null;\n      return;\n    }\n    if (typeof options.onDragStart === 'function') options.onDragStart({\n      type: 'dragstart',\n      x: e.clientX,\n      y: e.clientY\n    });\n    let items = options.getItems();\n    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e.dataTransfer, items);\n    let allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all;\n    if (typeof options.getAllowedDropOperations === 'function') {\n      let allowedOperations = options.getAllowedDropOperations();\n      allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;\n      for (let operation of allowedOperations) allowed |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation] || (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;\n    }\n    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)(allowed);\n    e.dataTransfer.effectAllowed = (0, $103790afe9474d1c$export$dd0165308d8bff45)[allowed] || 'none';\n    // If there is a preview option, use it to render a custom preview image that will\n    // appear under the pointer while dragging. If not, the element itself is dragged by the browser.\n    if (typeof ((_options_preview = options.preview) === null || _options_preview === void 0 ? void 0 : _options_preview.current) === 'function') options.preview.current(items, node => {\n      // Compute the offset that the preview will appear under the mouse.\n      // If possible, this is based on the point the user clicked on the target.\n      // If the preview is much smaller, then just use the center point of the preview.\n      let size = node.getBoundingClientRect();\n      let rect = e.currentTarget.getBoundingClientRect();\n      let x = e.clientX - rect.x;\n      let y = e.clientY - rect.y;\n      if (x > size.width || y > size.height) {\n        x = size.width / 2;\n        y = size.height / 2;\n      }\n      // Rounding height to an even number prevents blurry preview seen on some screens\n      let height = 2 * Math.round(size.height / 2);\n      node.style.height = `${height}px`;\n      e.dataTransfer.setDragImage(node, x, y);\n    });\n    // Enforce that drops are handled by useDrop.\n    addGlobalListener(window, 'drop', e => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.warn('Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.');\n    }, {\n      once: true\n    });\n    state.x = e.clientX;\n    state.y = e.clientY;\n    // Wait a frame before we set dragging to true so that the browser has time to\n    // render the preview image before we update the element that has been dragged.\n    requestAnimationFrame(() => {\n      setDragging(true);\n    });\n  };\n  let onDrag = e => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n    if (e.clientX === state.x && e.clientY === state.y) return;\n    if (typeof options.onDragMove === 'function') options.onDragMove({\n      type: 'dragmove',\n      x: e.clientX,\n      y: e.clientY\n    });\n    state.x = e.clientX;\n    state.y = e.clientY;\n  };\n  let onDragEnd = e => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n    if (typeof options.onDragEnd === 'function') {\n      let event = {\n        type: 'dragend',\n        x: e.clientX,\n        y: e.clientY,\n        dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[e.dataTransfer.dropEffect]\n      };\n      // Chrome Android always returns none as its dropEffect so we use the drop effect set in useDrop via\n      // onDragEnter/onDragOver instead. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951\n      if (0, $7252cd45fc48c07c$export$8e6636520ac15722) event.dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[0, $7252cd45fc48c07c$export$8e6636520ac15722];\n      options.onDragEnd(event);\n    }\n    setDragging(false);\n    removeAllGlobalListeners();\n    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);\n    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(undefined);\n  };\n  // If the dragged element is removed from the DOM via onDrop, onDragEnd won't fire: https://bugzilla.mozilla.org/show_bug.cgi?id=460801\n  // In this case, we need to manually call onDragEnd on cleanup\n  // eslint-disable-next-line arrow-body-style\n  (0, $72Evg$useLayoutEffect)(() => {\n    return () => {\n      if (isDraggingRef.current) {\n        if (typeof state.options.onDragEnd === 'function') {\n          let event = {\n            type: 'dragend',\n            x: 0,\n            y: 0,\n            dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[(0, $7252cd45fc48c07c$export$8e6636520ac15722) || 'none']\n          };\n          state.options.onDragEnd(event);\n        }\n        setDragging(false);\n        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);\n        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(undefined);\n      }\n    };\n  }, [state]);\n  let onPress = e => {\n    if (e.pointerType !== 'keyboard' && e.pointerType !== 'virtual') return;\n    startDragging(e.target);\n  };\n  let startDragging = target => {\n    if (typeof state.options.onDragStart === 'function') {\n      let rect = target.getBoundingClientRect();\n      state.options.onDragStart({\n        type: 'dragstart',\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height / 2\n      });\n    }\n    $67560de7c78cb232$export$549dbcf8649bf3b2({\n      element: target,\n      items: state.options.getItems(),\n      allowedDropOperations: typeof state.options.getAllowedDropOperations === 'function' ? state.options.getAllowedDropOperations() : ['move', 'copy', 'link'],\n      onDragEnd(e) {\n        setDragging(false);\n        if (typeof state.options.onDragEnd === 'function') state.options.onDragEnd(e);\n      }\n    }, stringFormatter);\n    setDragging(true);\n  };\n  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();\n  let message = !isDragging ? $8253ed7ece74b463$var$MESSAGES[modality].start : $8253ed7ece74b463$var$MESSAGES[modality].end;\n  let descriptionProps = (0, $72Evg$useDescription)(stringFormatter.format(message));\n  let interactions;\n  if (!hasDragButton)\n    // If there's no separate button to trigger accessible drag and drop mode,\n    // then add event handlers to the draggable element itself to start dragging.\n    // For keyboard, we use the Enter key in a capturing listener to prevent other\n    // events such as selection from also occurring. We attempt to infer whether a\n    // pointer event (e.g. long press) came from a touch screen reader, and then initiate\n    // dragging in the native onDragStart listener above.\n    interactions = {\n      ...descriptionProps,\n      onPointerDown(e) {\n        modalityOnPointerDown.current = (0, $72Evg$isVirtualPointerEvent)(e.nativeEvent) ? 'virtual' : e.pointerType;\n        // Try to detect virtual drag passthrough gestures.\n        if (e.width < 1 && e.height < 1)\n          // iOS VoiceOver.\n          modalityOnPointerDown.current = 'virtual';else {\n          let rect = e.currentTarget.getBoundingClientRect();\n          let offsetX = e.clientX - rect.x;\n          let offsetY = e.clientY - rect.y;\n          let centerX = rect.width / 2;\n          let centerY = rect.height / 2;\n          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5)\n            // Android TalkBack.\n            modalityOnPointerDown.current = 'virtual';else modalityOnPointerDown.current = e.pointerType;\n        }\n      },\n      onKeyDownCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      },\n      onKeyUpCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target);\n        }\n      },\n      onClick(e) {\n        // Handle NVDA/JAWS in browse mode, and touch screen readers. In this case, no keyboard events are fired.\n        if ((0, $72Evg$isVirtualClick)(e.nativeEvent) || modalityOnPointerDown.current === 'virtual') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target);\n        }\n      }\n    };\n  if (isDisabled) return {\n    dragProps: {\n      draggable: 'false'\n    },\n    dragButtonProps: {},\n    isDragging: false\n  };\n  return {\n    dragProps: {\n      ...interactions,\n      draggable: 'true',\n      onDragStart: onDragStart,\n      onDrag: onDrag,\n      onDragEnd: onDragEnd\n    },\n    dragButtonProps: {\n      ...descriptionProps,\n      onPress: onPress\n    },\n    isDragging: isDragging\n  };\n}\nexport { $8253ed7ece74b463$export$7941f8aafa4b6021 as useDrag };","map":{"version":3,"names":["$8253ed7ece74b463$var$MESSAGES","keyboard","start","end","touch","virtual","$8253ed7ece74b463$export$7941f8aafa4b6021","options","hasDragButton","isDisabled","stringFormatter","$72Evg$useLocalizedStringFormatter","$parcel$interopDefault","$72Evg$intlStringsmodulejs","state","$72Evg$useRef","x","y","current","isDraggingRef","isDragging","setDraggingState","$72Evg$useState","setDragging","addGlobalListener","removeAllGlobalListeners","$72Evg$useGlobalListeners","modalityOnPointerDown","onDragStart","e","_options_preview","defaultPrevented","stopPropagation","preventDefault","startDragging","target","type","clientX","clientY","items","getItems","$7252cd45fc48c07c$export$f9c1490890ddd063","dataTransfer","allowed","$103790afe9474d1c$export$60b7b4bcf3903d8e","all","getAllowedDropOperations","allowedOperations","none","operation","$7252cd45fc48c07c$export$6539bc8c3a0a2d67","effectAllowed","$103790afe9474d1c$export$dd0165308d8bff45","preview","node","size","getBoundingClientRect","rect","currentTarget","width","height","Math","round","style","setDragImage","window","console","warn","once","requestAnimationFrame","onDrag","onDragMove","onDragEnd","event","dropOperation","$103790afe9474d1c$export$608ecc6f1b23c35d","dropEffect","$7252cd45fc48c07c$export$8e6636520ac15722","$7252cd45fc48c07c$export$64f52ed7349ddb84","undefined","$72Evg$useLayoutEffect","onPress","pointerType","$67560de7c78cb232$export$549dbcf8649bf3b2","element","allowedDropOperations","modality","$7252cd45fc48c07c$export$49bac5d6d4b352ea","message","descriptionProps","$72Evg$useDescription","format","interactions","onPointerDown","$72Evg$isVirtualPointerEvent","nativeEvent","offsetX","offsetY","centerX","centerY","abs","onKeyDownCapture","key","onKeyUpCapture","onClick","$72Evg$isVirtualClick","dragProps","draggable","dragButtonProps"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-aria/dnd/dist/packages/@react-aria/dnd/src/useDrag.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {DragEndEvent, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, PressEvent, RefObject} from '@react-types/shared';\nimport {DragEvent, HTMLAttributes, useRef, useState} from 'react';\nimport * as DragManager from './DragManager';\nimport {DROP_EFFECT_TO_DROP_OPERATION, DROP_OPERATION, EFFECT_ALLOWED} from './constants';\nimport {globalDropEffect, setGlobalAllowedDropOperations, setGlobalDropEffect, useDragModality, writeToDataTransfer} from './utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {isVirtualClick, isVirtualPointerEvent, useDescription, useGlobalListeners, useLayoutEffect} from '@react-aria/utils';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface DragOptions {\n  /** Handler that is called when a drag operation is started. */\n  onDragStart?: (e: DragStartEvent) => void,\n  /** Handler that is called when the drag is moved. */\n  onDragMove?: (e: DragMoveEvent) => void,\n  /** Handler that is called when the drag operation is ended, either as a result of a drop or a cancellation. */\n  onDragEnd?: (e: DragEndEvent) => void,\n  /** A function that returns the items being dragged. */\n  getItems: () => DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer | null>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /**\n   * Whether the item has an explicit focusable drag affordance to initiate accessible drag and drop mode.\n   * If true, the dragProps will omit these event handlers, and they will be applied to dragButtonProps instead.\n   */\n  hasDragButton?: boolean,\n  /**\n   * Whether the drag operation is disabled. If true, the element will not be draggable.\n   */\n  isDisabled?: boolean\n}\n\nexport interface DragResult {\n  /** Props for the draggable element. */\n  dragProps: HTMLAttributes<HTMLElement>,\n  /** Props for the explicit drag button affordance, if any. */\n  dragButtonProps: AriaButtonProps,\n  /** Whether the element is currently being dragged. */\n  isDragging: boolean\n}\n\nconst MESSAGES = {\n  keyboard: {\n    start: 'dragDescriptionKeyboard',\n    end: 'endDragKeyboard'\n  },\n  touch: {\n    start: 'dragDescriptionTouch',\n    end: 'endDragTouch'\n  },\n  virtual: {\n    start: 'dragDescriptionVirtual',\n    end: 'endDragVirtual'\n  }\n};\n\n/**\n * Handles drag interactions for an element, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDrag(options: DragOptions): DragResult {\n  let {hasDragButton, isDisabled} = options;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/dnd');\n  let state = useRef({\n    options,\n    x: 0,\n    y: 0\n  }).current;\n  state.options = options;\n  let isDraggingRef = useRef(false);\n  let [isDragging, setDraggingState] = useState(false);\n  let setDragging = (isDragging) => {\n    isDraggingRef.current = isDragging;\n    setDraggingState(isDragging);\n  };\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n  let modalityOnPointerDown = useRef<string>(null);\n\n  let onDragStart = (e: DragEvent) => {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    // If this drag was initiated by a mobile screen reader (e.g. VoiceOver or TalkBack), enter virtual dragging mode.\n    if (modalityOnPointerDown.current === 'virtual') {\n      e.preventDefault();\n      startDragging(e.target as HTMLElement);\n      modalityOnPointerDown.current = null;\n      return;\n    }\n\n    if (typeof options.onDragStart === 'function') {\n      options.onDragStart({\n        type: 'dragstart',\n        x: e.clientX,\n        y: e.clientY\n      });\n    }\n\n    let items = options.getItems();\n    writeToDataTransfer(e.dataTransfer, items);\n\n    let allowed = DROP_OPERATION.all;\n    if (typeof options.getAllowedDropOperations === 'function') {\n      let allowedOperations = options.getAllowedDropOperations();\n      allowed = DROP_OPERATION.none;\n      for (let operation of allowedOperations) {\n        allowed |= DROP_OPERATION[operation] || DROP_OPERATION.none;\n      }\n    }\n\n    setGlobalAllowedDropOperations(allowed);\n    e.dataTransfer.effectAllowed = EFFECT_ALLOWED[allowed] || 'none';\n\n    // If there is a preview option, use it to render a custom preview image that will\n    // appear under the pointer while dragging. If not, the element itself is dragged by the browser.\n    if (typeof options.preview?.current === 'function') {\n      options.preview.current(items, node => {\n        // Compute the offset that the preview will appear under the mouse.\n        // If possible, this is based on the point the user clicked on the target.\n        // If the preview is much smaller, then just use the center point of the preview.\n        let size = node.getBoundingClientRect();\n        let rect = e.currentTarget.getBoundingClientRect();\n        let x = e.clientX - rect.x;\n        let y = e.clientY - rect.y;\n        if (x > size.width || y > size.height) {\n          x = size.width / 2;\n          y = size.height / 2;\n        }\n\n        // Rounding height to an even number prevents blurry preview seen on some screens\n        let height = 2 * Math.round(size.height / 2);\n        node.style.height = `${height}px`;\n\n        e.dataTransfer.setDragImage(node, x, y);\n      });\n    }\n\n    // Enforce that drops are handled by useDrop.\n    addGlobalListener(window, 'drop', e => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.warn('Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.');\n    }, {once: true});\n    state.x = e.clientX;\n    state.y = e.clientY;\n\n    // Wait a frame before we set dragging to true so that the browser has time to\n    // render the preview image before we update the element that has been dragged.\n    requestAnimationFrame(() => {\n      setDragging(true);\n    });\n  };\n\n  let onDrag = (e: DragEvent) => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    if (e.clientX === state.x && e.clientY === state.y) {\n      return;\n    }\n\n    if (typeof options.onDragMove === 'function') {\n      options.onDragMove({\n        type: 'dragmove',\n        x: e.clientX,\n        y: e.clientY\n      });\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n  };\n\n  let onDragEnd = (e: DragEvent) => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    if (typeof options.onDragEnd === 'function') {\n      let event: DragEndEvent = {\n        type: 'dragend',\n        x: e.clientX,\n        y: e.clientY,\n        dropOperation: DROP_EFFECT_TO_DROP_OPERATION[e.dataTransfer.dropEffect]\n      };\n\n      // Chrome Android always returns none as its dropEffect so we use the drop effect set in useDrop via\n      // onDragEnter/onDragOver instead. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951\n      if (globalDropEffect) {\n        event.dropOperation = DROP_EFFECT_TO_DROP_OPERATION[globalDropEffect];\n      }\n      options.onDragEnd(event);\n    }\n\n    setDragging(false);\n    removeAllGlobalListeners();\n    setGlobalAllowedDropOperations(DROP_OPERATION.none);\n    setGlobalDropEffect(undefined);\n  };\n\n  // If the dragged element is removed from the DOM via onDrop, onDragEnd won't fire: https://bugzilla.mozilla.org/show_bug.cgi?id=460801\n  // In this case, we need to manually call onDragEnd on cleanup\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (isDraggingRef.current) {\n        if (typeof state.options.onDragEnd === 'function') {\n          let event: DragEndEvent = {\n            type: 'dragend',\n            x: 0,\n            y: 0,\n            dropOperation: DROP_EFFECT_TO_DROP_OPERATION[globalDropEffect || 'none']\n          };\n          state.options.onDragEnd(event);\n        }\n\n        setDragging(false);\n        setGlobalAllowedDropOperations(DROP_OPERATION.none);\n        setGlobalDropEffect(undefined);\n      }\n    };\n  }, [state]);\n\n  let onPress = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard' && e.pointerType !== 'virtual') {\n      return;\n    }\n\n    startDragging(e.target as HTMLElement);\n  };\n\n  let startDragging = (target: HTMLElement) => {\n    if (typeof state.options.onDragStart === 'function') {\n      let rect = target.getBoundingClientRect();\n      state.options.onDragStart({\n        type: 'dragstart',\n        x: rect.x + (rect.width / 2),\n        y: rect.y + (rect.height / 2)\n      });\n    }\n\n    DragManager.beginDragging({\n      element: target,\n      items: state.options.getItems(),\n      allowedDropOperations: typeof state.options.getAllowedDropOperations === 'function'\n        ? state.options.getAllowedDropOperations()\n        : ['move', 'copy', 'link'],\n      onDragEnd(e) {\n        setDragging(false);\n        if (typeof state.options.onDragEnd === 'function') {\n          state.options.onDragEnd(e);\n        }\n      }\n    }, stringFormatter);\n\n    setDragging(true);\n  };\n\n  let modality = useDragModality();\n  let message = !isDragging ? MESSAGES[modality].start : MESSAGES[modality].end;\n\n  let descriptionProps = useDescription(stringFormatter.format(message));\n\n  let interactions: HTMLAttributes<HTMLElement>;\n  if (!hasDragButton) {\n    // If there's no separate button to trigger accessible drag and drop mode,\n    // then add event handlers to the draggable element itself to start dragging.\n    // For keyboard, we use the Enter key in a capturing listener to prevent other\n    // events such as selection from also occurring. We attempt to infer whether a\n    // pointer event (e.g. long press) came from a touch screen reader, and then initiate\n    // dragging in the native onDragStart listener above.\n\n    interactions = {\n      ...descriptionProps,\n      onPointerDown(e) {\n        modalityOnPointerDown.current = isVirtualPointerEvent(e.nativeEvent) ? 'virtual' : e.pointerType;\n\n        // Try to detect virtual drag passthrough gestures.\n        if (e.width < 1 && e.height < 1) {\n          // iOS VoiceOver.\n          modalityOnPointerDown.current = 'virtual';\n        } else {\n          let rect = e.currentTarget.getBoundingClientRect();\n          let offsetX = e.clientX - rect.x;\n          let offsetY = e.clientY - rect.y;\n          let centerX = rect.width / 2;\n          let centerY = rect.height / 2;\n\n          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5) {\n            // Android TalkBack.\n            modalityOnPointerDown.current = 'virtual';\n          } else {\n            modalityOnPointerDown.current = e.pointerType;\n          }\n        }\n      },\n      onKeyDownCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      },\n      onKeyUpCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target as HTMLElement);\n        }\n      },\n      onClick(e) {\n        // Handle NVDA/JAWS in browse mode, and touch screen readers. In this case, no keyboard events are fired.\n        if (isVirtualClick(e.nativeEvent) || modalityOnPointerDown.current === 'virtual') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target as HTMLElement);\n        }\n      }\n    };\n  }\n\n  if (isDisabled) {\n    return {\n      dragProps: {\n        draggable: 'false'\n      },\n      dragButtonProps: {},\n      isDragging: false\n    };\n  }\n\n  return {\n    dragProps: {\n      ...interactions,\n      draggable: 'true',\n      onDragStart,\n      onDrag,\n      onDragEnd\n    },\n    dragButtonProps: {\n      ...descriptionProps,\n      onPress\n    },\n    isDragging\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}