{"ast":null,"code":"import \"./vars.5816edba.css\";\nimport $lajJX$button_vars_cssmodulejs from \"./button_vars_css.mjs\";\nimport \"./vars.fc4aa55a.css\";\nimport $lajJX$actiongroup_vars_cssmodulejs from \"./actiongroup_vars_css.mjs\";\nimport { ActionButton as $lajJX$ActionButton } from \"@react-spectrum/button\";\nimport $lajJX$spectrumiconsuiChevronDownMedium from \"@spectrum-icons/ui/ChevronDownMedium\";\nimport { useSlotProps as $lajJX$useSlotProps, useDOMRef as $lajJX$useDOMRef, useStyleProps as $lajJX$useStyleProps, classNames as $lajJX$classNames, ClearSlots as $lajJX$ClearSlots, SlotProvider as $lajJX$SlotProvider } from \"@react-spectrum/utils\";\nimport { useValueEffect as $lajJX$useValueEffect, useResizeObserver as $lajJX$useResizeObserver, useLayoutEffect as $lajJX$useLayoutEffect, filterDOMProps as $lajJX$filterDOMProps, mergeProps as $lajJX$mergeProps, useId as $lajJX$useId } from \"@react-aria/utils\";\nimport { FocusScope as $lajJX$FocusScope } from \"@react-aria/focus\";\nimport { MenuTrigger as $lajJX$MenuTrigger, Menu as $lajJX$Menu, Item as $lajJX$Item } from \"@react-spectrum/menu\";\nimport { useListState as $lajJX$useListState } from \"@react-stately/list\";\nimport $lajJX$spectrumiconsworkflowMore from \"@spectrum-icons/workflow/More\";\nimport { useHover as $lajJX$useHover, PressResponder as $lajJX$PressResponder } from \"@react-aria/interactions\";\nimport { useProviderProps as $lajJX$useProviderProps, Provider as $lajJX$Provider } from \"@react-spectrum/provider\";\nimport $lajJX$react, { useRef as $lajJX$useRef, useMemo as $lajJX$useMemo, useCallback as $lajJX$useCallback, forwardRef as $lajJX$forwardRef, useState as $lajJX$useState } from \"react\";\nimport { Text as $lajJX$Text } from \"@react-spectrum/text\";\nimport { TooltipTrigger as $lajJX$TooltipTrigger, Tooltip as $lajJX$Tooltip } from \"@react-spectrum/tooltip\";\nimport { useActionGroup as $lajJX$useActionGroup, useActionGroupItem as $lajJX$useActionGroupItem } from \"@react-aria/actiongroup\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $a04ee251ffcc2690$var$ActionGroup(props, ref) {\n  props = (0, $lajJX$useProviderProps)(props);\n  props = (0, $lajJX$useSlotProps)(props, 'actionGroup');\n  let {\n    isEmphasized: isEmphasized,\n    density: density,\n    isJustified: isJustified,\n    isDisabled: isDisabled,\n    orientation = 'horizontal',\n    isQuiet: isQuiet,\n    staticColor: staticColor,\n    overflowMode = 'wrap',\n    onAction: onAction,\n    buttonLabelBehavior: buttonLabelBehavior,\n    summaryIcon: summaryIcon,\n    ...otherProps\n  } = props;\n  let domRef = (0, $lajJX$useDOMRef)(ref);\n  let wrapperRef = (0, $lajJX$useRef)(null);\n  let state = (0, $lajJX$useListState)({\n    ...props,\n    suppressTextValueWarning: true\n  });\n  let {\n    actionGroupProps: actionGroupProps\n  } = (0, $lajJX$useActionGroup)(props, state, domRef);\n  let isVertical = orientation === 'vertical';\n  let providerProps = {\n    isEmphasized: isEmphasized,\n    isDisabled: isDisabled,\n    isQuiet: isQuiet\n  };\n  let {\n    styleProps: styleProps\n  } = (0, $lajJX$useStyleProps)(props);\n  // Only hide button text if every item contains more than just plain text (we assume an icon).\n  let isIconCollapsible = (0, $lajJX$useMemo)(() => [...state.collection].every(item => typeof item.rendered !== 'string'), [state.collection]);\n  let [{\n    visibleItems: visibleItems,\n    hideButtonText: hideButtonText,\n    isMeasuring: isMeasuring\n  }, setVisibleItems] = (0, $lajJX$useValueEffect)({\n    visibleItems: state.collection.size,\n    hideButtonText: buttonLabelBehavior === 'hide' && isIconCollapsible,\n    isMeasuring: false\n  });\n  let selectionMode = state.selectionManager.selectionMode;\n  let updateOverflow = (0, $lajJX$useCallback)(() => {\n    if (overflowMode === 'wrap') return;\n    if (orientation === 'vertical' && selectionMode !== 'none')\n      // Collapsing vertical action groups with selection is currently unsupported by Spectrum.\n      return;\n    let computeVisibleItems = visibleItems => {\n      if (domRef.current && wrapperRef.current) {\n        let listItems = Array.from(domRef.current.children);\n        let containerSize = orientation === 'horizontal' ? wrapperRef.current.getBoundingClientRect().width : wrapperRef.current.getBoundingClientRect().height;\n        let isShowingMenu = visibleItems < state.collection.size;\n        let calculatedSize = 0;\n        let newVisibleItems = 0;\n        if (isShowingMenu) {\n          let item = listItems.pop();\n          if (item) calculatedSize += orientation === 'horizontal' ? $a04ee251ffcc2690$var$outerWidth(item, false, true) : $a04ee251ffcc2690$var$outerHeight(item, false, true);\n        }\n        for (let [i, item] of listItems.entries()) {\n          calculatedSize += orientation === 'horizontal' ? $a04ee251ffcc2690$var$outerWidth(item, i === 0, i === listItems.length - 1) : $a04ee251ffcc2690$var$outerHeight(item, i === 0, i === listItems.length - 1);\n          if (Math.round(calculatedSize) <= Math.round(containerSize)) newVisibleItems++;else break;\n        }\n        // If selection is enabled, and not all of the items fit, collapse all of them into a dropdown\n        // immediately rather than having some visible and some not.\n        if (selectionMode !== 'none' && newVisibleItems < state.collection.size) return 0;\n        return newVisibleItems;\n      }\n      return visibleItems;\n    };\n    setVisibleItems(function* () {\n      let hideButtonText = buttonLabelBehavior === 'hide' && isIconCollapsible;\n      // Update to show all items.\n      yield {\n        visibleItems: state.collection.size,\n        hideButtonText: hideButtonText,\n        isMeasuring: true\n      };\n      // Measure, and update to show the items that fit.\n      let newVisibleItems = computeVisibleItems(state.collection.size);\n      let isMeasuring = newVisibleItems < state.collection.size && newVisibleItems > 0;\n      // If not all of the buttons fit, and buttonLabelBehavior is 'collapse', then first try hiding\n      // the button text and only showing icons. Only if that still doesn't fit collapse into a menu.\n      if (newVisibleItems < state.collection.size && buttonLabelBehavior === 'collapse' && isIconCollapsible) {\n        yield {\n          visibleItems: state.collection.size,\n          hideButtonText: true,\n          isMeasuring: true\n        };\n        newVisibleItems = computeVisibleItems(state.collection.size);\n        isMeasuring = newVisibleItems < state.collection.size && newVisibleItems > 0;\n        hideButtonText = true;\n      }\n      yield {\n        visibleItems: newVisibleItems,\n        hideButtonText: hideButtonText,\n        isMeasuring: isMeasuring\n      };\n      // If the number of items is less than the number of children,\n      // then update again to ensure that the menu fits.\n      if (isMeasuring) yield {\n        visibleItems: computeVisibleItems(newVisibleItems),\n        hideButtonText: hideButtonText,\n        isMeasuring: false\n      };\n    });\n  }, [domRef, state.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);\n  // Watch the parent element for size changes. Watching only the action group itself may not work\n  // in all scenarios because it may not shrink when available space is reduced.\n  let parentRef = (0, $lajJX$useMemo)(() => ({\n    get current() {\n      var _wrapperRef_current;\n      return (_wrapperRef_current = wrapperRef.current) === null || _wrapperRef_current === void 0 ? void 0 : _wrapperRef_current.parentElement;\n    }\n  }), [wrapperRef]);\n  (0, $lajJX$useResizeObserver)({\n    ref: overflowMode !== 'wrap' ? parentRef : undefined,\n    onResize: updateOverflow\n  });\n  (0, $lajJX$useLayoutEffect)(updateOverflow, [updateOverflow, state.collection]);\n  let children = [...state.collection];\n  let menuItem = null;\n  let menuProps = {};\n  // If there are no visible items, don't apply any props to the action group container\n  // and pass all aria labeling props through to the menu button.\n  if (overflowMode === 'collapse' && visibleItems === 0) {\n    menuProps = (0, $lajJX$filterDOMProps)(props, {\n      labelable: true\n    });\n    actionGroupProps = {};\n  }\n  if (overflowMode === 'collapse' && visibleItems < state.collection.size) {\n    let menuChildren = children.slice(visibleItems);\n    children = children.slice(0, visibleItems);\n    menuItem = /*#__PURE__*/(0, $lajJX$react).createElement($a04ee251ffcc2690$var$ActionGroupMenu, {\n      ...menuProps,\n      items: menuChildren,\n      onAction: onAction,\n      isDisabled: isDisabled,\n      isEmphasized: isEmphasized,\n      staticColor: staticColor,\n      state: state,\n      summaryIcon: summaryIcon,\n      hideButtonText: hideButtonText,\n      isOnlyItem: visibleItems === 0,\n      orientation: orientation\n    });\n  }\n  let style = {\n    ...styleProps.style,\n    // While measuring, take up as much space as possible.\n    flexBasis: isMeasuring ? '100%' : undefined\n  };\n  return /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$FocusScope), null, /*#__PURE__*/(0, $lajJX$react).createElement(\"div\", {\n    ...styleProps,\n    style: style,\n    className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'flex-container', styleProps.className),\n    ref: wrapperRef\n  }, /*#__PURE__*/(0, $lajJX$react).createElement(\"div\", {\n    ...actionGroupProps,\n    ref: domRef,\n    className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'flex-gap', 'spectrum-ActionGroup', {\n      'spectrum-ActionGroup--quiet': isQuiet,\n      'spectrum-ActionGroup--vertical': isVertical,\n      'spectrum-ActionGroup--compact': density === 'compact',\n      'spectrum-ActionGroup--justified': isJustified && !isMeasuring,\n      'spectrum-ActionGroup--overflowCollapse': overflowMode === 'collapse'\n    }, otherProps.UNSAFE_className)\n  }, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$Provider), providerProps, children.map(item => /*#__PURE__*/(0, $lajJX$react).createElement($a04ee251ffcc2690$var$ActionGroupItem, {\n    key: item.key,\n    onAction: onAction,\n    isDisabled: isDisabled,\n    isEmphasized: isEmphasized,\n    staticColor: staticColor,\n    item: item,\n    state: state,\n    hideButtonText: hideButtonText,\n    orientation: orientation\n  })), menuItem))));\n}\n/**\n * An ActionGroup is a grouping of ActionButtons that are related to one another.\n */\nconst $a04ee251ffcc2690$export$c21a5597f732a168 = /*#__PURE__*/(0, $lajJX$forwardRef)($a04ee251ffcc2690$var$ActionGroup);\nfunction $a04ee251ffcc2690$var$ActionGroupItem({\n  item: item,\n  state: state,\n  isDisabled: isDisabled,\n  isEmphasized: isEmphasized,\n  staticColor: staticColor,\n  onAction: onAction,\n  hideButtonText: hideButtonText,\n  orientation: orientation\n}) {\n  let ref = (0, $lajJX$useRef)(null);\n  let {\n    buttonProps: buttonProps\n  } = (0, $lajJX$useActionGroupItem)({\n    key: item.key\n  }, state);\n  isDisabled = isDisabled || state.disabledKeys.has(item.key);\n  let isSelected = state.selectionManager.isSelected(item.key);\n  let {\n    hoverProps: hoverProps,\n    isHovered: isHovered\n  } = (0, $lajJX$useHover)({\n    isDisabled: isDisabled\n  });\n  let domProps = (0, $lajJX$filterDOMProps)(item.props);\n  if (onAction && !isDisabled) buttonProps = (0, $lajJX$mergeProps)(buttonProps, {\n    onPress: () => onAction(item.key)\n  });\n  // If button text is hidden, we need to show it as a tooltip instead, so\n  // go find the text element in the DOM after rendering.\n  let textId = (0, $lajJX$useId)();\n  let [textContent, setTextContent] = (0, $lajJX$useState)('');\n  (0, $lajJX$useLayoutEffect)(() => {\n    var _document_getElementById;\n    if (hideButtonText) setTextContent((_document_getElementById = document.getElementById(textId)) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.textContent);\n  }, [hideButtonText, item.rendered, textId]);\n  let button =\n  // Use a PressResponder to send DOM props through.\n  // ActionButton doesn't allow overriding the role by default.\n  /*#__PURE__*/\n  (0, $lajJX$react).createElement((0, $lajJX$PressResponder), (0, $lajJX$mergeProps)(buttonProps, hoverProps, domProps), /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$ClearSlots), null, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$SlotProvider), {\n    slots: {\n      text: {\n        id: hideButtonText ? textId : null,\n        isHidden: hideButtonText\n      }\n    }\n  }, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$ActionButton), {\n    ref: ref,\n    // @ts-ignore (private)\n    hideButtonText: hideButtonText,\n    UNSAFE_className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'spectrum-ActionGroup-item', {\n      'is-selected': isSelected,\n      'is-hovered': isHovered,\n      'spectrum-ActionGroup-item--iconOnly': hideButtonText,\n      'spectrum-ActionGroup-item--isDisabled': isDisabled\n    }, (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$button_vars_cssmodulejs)), {\n      'spectrum-ActionButton--emphasized': isEmphasized,\n      'is-selected': isSelected\n    })),\n    isDisabled: isDisabled,\n    staticColor: staticColor,\n    \"aria-label\": item['aria-label'],\n    \"aria-labelledby\": item['aria-label'] == null && hideButtonText ? textId : undefined\n  }, item.rendered))));\n  if (hideButtonText && textContent) button = /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$TooltipTrigger), {\n    placement: orientation === 'vertical' ? 'end' : 'top'\n  }, button, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$Tooltip), null, textContent));\n  if (item.wrapper) button = item.wrapper(button);\n  return button;\n}\nfunction $a04ee251ffcc2690$var$ActionGroupMenu({\n  state: state,\n  isDisabled: isDisabled,\n  isEmphasized: isEmphasized,\n  staticColor: staticColor,\n  items: items,\n  onAction: onAction,\n  summaryIcon: summaryIcon,\n  hideButtonText: hideButtonText,\n  isOnlyItem: isOnlyItem,\n  orientation: orientation,\n  ...otherProps\n}) {\n  // Use the key of the first item within the menu as the key of the button.\n  // The key must actually exist in the collection for focus to work correctly.\n  let key = items[0].key;\n  let {\n    buttonProps: buttonProps\n  } = (0, $lajJX$useActionGroupItem)({\n    key: key\n  }, state);\n  // The menu button shouldn't act like an actual action group item.\n  delete buttonProps.onPress;\n  delete buttonProps.role;\n  delete buttonProps['aria-checked'];\n  let {\n    hoverProps: hoverProps,\n    isHovered: isHovered\n  } = (0, $lajJX$useHover)({\n    isDisabled: isDisabled\n  });\n  // If no aria-label or aria-labelledby is given, provide a default one.\n  let ariaLabel = otherProps['aria-label'] || (otherProps['aria-labelledby'] ? undefined : \"\\u2026\");\n  let ariaLabelledby = otherProps['aria-labelledby'];\n  let textId = (0, $lajJX$useId)();\n  let id = (0, $lajJX$useId)();\n  // Summary icon only applies when selection is enabled.\n  if (state.selectionManager.selectionMode === 'none') summaryIcon = null;\n  let iconOnly = false;\n  // If there is a selection, show the selected state on the menu button.\n  let isSelected = state.selectionManager.selectionMode !== 'none' && !state.selectionManager.isEmpty;\n  // If single selection and empty selection is not allowed, swap the contents of the button to the selected item (like a Picker).\n  if (!summaryIcon && state.selectionManager.selectionMode === 'single' && state.selectionManager.disallowEmptySelection && state.selectionManager.firstSelectedKey != null) {\n    let selectedItem = state.collection.getItem(state.selectionManager.firstSelectedKey);\n    if (selectedItem) {\n      summaryIcon = selectedItem.rendered;\n      if (typeof summaryIcon === 'string') summaryIcon = /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$Text), null, summaryIcon);\n      iconOnly = !!hideButtonText;\n      ariaLabelledby = `${ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : id} ${textId}`;\n    }\n  }\n  if (summaryIcon)\n    // If there's a custom summary icon, also add a chevron.\n    summaryIcon = /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$react).Fragment, null, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$spectrumiconsuiChevronDownMedium), {\n      UNSAFE_className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'spectrum-ActionGroup-menu-chevron')\n    }), /*#__PURE__*/(0, $lajJX$react).createElement(\"span\", {\n      className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'spectrum-ActionGroup-menu-contents', {\n        'spectrum-ActionGroup-item--iconOnly': iconOnly\n      })\n    }, summaryIcon));\n  return (\n    // Use a PressResponder to send DOM props through.\n    /*#__PURE__*/\n    (0, $lajJX$react).createElement((0, $lajJX$MenuTrigger), {\n      align: isOnlyItem ? 'start' : 'end',\n      direction: orientation === 'vertical' ? 'end' : 'bottom'\n    }, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$SlotProvider), {\n      slots: {\n        text: {\n          id: hideButtonText ? textId : null,\n          isHidden: hideButtonText,\n          UNSAFE_className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'spectrum-ActionGroup-menu-text')\n        }\n      }\n    }, /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$PressResponder), (0, $lajJX$mergeProps)(buttonProps, hoverProps), /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$ActionButton), {\n      ...otherProps,\n      id: id,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledby,\n      UNSAFE_className: (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$actiongroup_vars_cssmodulejs)), 'spectrum-ActionGroup-item', 'spectrum-ActionGroup-menu', {\n        'is-hovered': isHovered,\n        'is-selected': isSelected\n      }, (0, $lajJX$classNames)((0, $parcel$interopDefault($lajJX$button_vars_cssmodulejs)), {\n        'is-selected': isSelected,\n        'spectrum-ActionButton--emphasized': isEmphasized\n      })),\n      isDisabled: isDisabled,\n      staticColor: staticColor\n    }, summaryIcon || /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$spectrumiconsworkflowMore), null)))), /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$Menu), {\n      items: items,\n      disabledKeys: state.disabledKeys,\n      selectionMode: state.selectionManager.selectionMode,\n      selectedKeys: state.selectionManager.selectedKeys,\n      disallowEmptySelection: state.selectionManager.disallowEmptySelection,\n      onSelectionChange: keys => state.selectionManager.setSelectedKeys(keys),\n      onAction: onAction\n    }, node => /*#__PURE__*/(0, $lajJX$react).createElement((0, $lajJX$Item), {\n      textValue: node.textValue,\n      ...(0, $lajJX$filterDOMProps)(node.props)\n    }, node.rendered)))\n  );\n}\nfunction $a04ee251ffcc2690$var$outerWidth(element, ignoreLeftMargin, ignoreRightMargin) {\n  let style = window.getComputedStyle(element);\n  return element.getBoundingClientRect().width + (ignoreLeftMargin ? 0 : $a04ee251ffcc2690$var$toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : $a04ee251ffcc2690$var$toNumber(style.marginRight));\n}\nfunction $a04ee251ffcc2690$var$outerHeight(element, ignoreTopMargin, ignoreBottomMargin) {\n  let style = window.getComputedStyle(element);\n  return element.getBoundingClientRect().height + (ignoreTopMargin ? 0 : $a04ee251ffcc2690$var$toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : $a04ee251ffcc2690$var$toNumber(style.marginBottom));\n}\nfunction $a04ee251ffcc2690$var$toNumber(value) {\n  let parsed = parseInt(value, 10);\n  return isNaN(parsed) ? 0 : parsed;\n}\nexport { $a04ee251ffcc2690$export$c21a5597f732a168 as ActionGroup };","map":{"version":3,"names":["$a04ee251ffcc2690$var$ActionGroup","props","ref","$lajJX$useProviderProps","$lajJX$useSlotProps","isEmphasized","density","isJustified","isDisabled","orientation","isQuiet","staticColor","overflowMode","onAction","buttonLabelBehavior","summaryIcon","otherProps","domRef","$lajJX$useDOMRef","wrapperRef","$lajJX$useRef","state","$lajJX$useListState","suppressTextValueWarning","actionGroupProps","$lajJX$useActionGroup","isVertical","providerProps","styleProps","$lajJX$useStyleProps","isIconCollapsible","$lajJX$useMemo","collection","every","item","rendered","visibleItems","hideButtonText","isMeasuring","setVisibleItems","$lajJX$useValueEffect","size","selectionMode","selectionManager","updateOverflow","$lajJX$useCallback","computeVisibleItems","current","listItems","Array","from","children","containerSize","getBoundingClientRect","width","height","isShowingMenu","calculatedSize","newVisibleItems","pop","$a04ee251ffcc2690$var$outerWidth","$a04ee251ffcc2690$var$outerHeight","i","entries","length","Math","round","parentRef","_wrapperRef_current","parentElement","$lajJX$useResizeObserver","undefined","onResize","$lajJX$useLayoutEffect","menuItem","menuProps","$lajJX$filterDOMProps","labelable","menuChildren","slice","$lajJX$react","createElement","$a04ee251ffcc2690$var$ActionGroupMenu","items","isOnlyItem","style","flexBasis","$lajJX$FocusScope","className","$lajJX$classNames","$parcel$interopDefault","$lajJX$actiongroup_vars_cssmodulejs","UNSAFE_className","$lajJX$Provider","map","$a04ee251ffcc2690$var$ActionGroupItem","key","$a04ee251ffcc2690$export$c21a5597f732a168","$lajJX$forwardRef","buttonProps","$lajJX$useActionGroupItem","disabledKeys","has","isSelected","hoverProps","isHovered","$lajJX$useHover","domProps","$lajJX$mergeProps","onPress","textId","$lajJX$useId","textContent","setTextContent","$lajJX$useState","_document_getElementById","document","getElementById","button","$lajJX$PressResponder","$lajJX$ClearSlots","$lajJX$SlotProvider","slots","text","id","isHidden","$lajJX$ActionButton","$lajJX$button_vars_cssmodulejs","$lajJX$TooltipTrigger","placement","$lajJX$Tooltip","wrapper","role","ariaLabel","ariaLabelledby","iconOnly","isEmpty","disallowEmptySelection","firstSelectedKey","selectedItem","getItem","$lajJX$Text","Fragment","$lajJX$spectrumiconsuiChevronDownMedium","$lajJX$MenuTrigger","align","direction","$lajJX$spectrumiconsworkflowMore","$lajJX$Menu","selectedKeys","onSelectionChange","keys","setSelectedKeys","node","$lajJX$Item","textValue","element","ignoreLeftMargin","ignoreRightMargin","window","getComputedStyle","$a04ee251ffcc2690$var$toNumber","marginLeft","marginRight","ignoreTopMargin","ignoreBottomMargin","marginTop","marginBottom","value","parsed","parseInt","isNaN"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-spectrum/actiongroup/dist/packages/@react-spectrum/actiongroup/src/ActionGroup.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ActionButton} from '@react-spectrum/button';\nimport {AriaLabelingProps, DOMProps, DOMRef, Key, Node, StyleProps} from '@react-types/shared';\nimport buttonStyles from '@adobe/spectrum-css-temp/components/button/vars.css';\nimport ChevronDownMedium from '@spectrum-icons/ui/ChevronDownMedium';\nimport {\n  classNames,\n  ClearSlots,\n  SlotProvider,\n  useDOMRef,\n  useSlotProps,\n  useStyleProps\n} from '@react-spectrum/utils';\nimport {filterDOMProps, mergeProps, useId, useLayoutEffect, useResizeObserver, useValueEffect} from '@react-aria/utils';\nimport {FocusScope} from '@react-aria/focus';\nimport {Item, Menu, MenuTrigger} from '@react-spectrum/menu';\nimport {ListState, useListState} from '@react-stately/list';\nimport More from '@spectrum-icons/workflow/More';\nimport {PressResponder, useHover} from '@react-aria/interactions';\nimport {Provider, useProviderProps} from '@react-spectrum/provider';\nimport React, {forwardRef, ReactElement, ReactNode, useCallback, useMemo, useRef, useState} from 'react';\nimport {SpectrumActionGroupProps} from '@react-types/actiongroup';\nimport styles from '@adobe/spectrum-css-temp/components/actiongroup/vars.css';\nimport {Text} from '@react-spectrum/text';\nimport {Tooltip, TooltipTrigger} from '@react-spectrum/tooltip';\nimport {useActionGroup, useActionGroupItem} from '@react-aria/actiongroup';\n\n\nfunction ActionGroup<T extends object>(props: SpectrumActionGroupProps<T>, ref: DOMRef<HTMLDivElement>) {\n  props = useProviderProps(props);\n  props = useSlotProps(props, 'actionGroup');\n\n  let {\n    isEmphasized,\n    density,\n    isJustified,\n    isDisabled,\n    orientation = 'horizontal',\n    isQuiet,\n    staticColor,\n    overflowMode = 'wrap',\n    onAction,\n    buttonLabelBehavior,\n    summaryIcon,\n    ...otherProps\n  } = props;\n\n  let domRef = useDOMRef(ref);\n  let wrapperRef = useRef<HTMLDivElement>(null);\n  let state = useListState({...props, suppressTextValueWarning: true});\n  let {actionGroupProps} = useActionGroup(props, state, domRef);\n  let isVertical = orientation === 'vertical';\n  let providerProps = {isEmphasized, isDisabled, isQuiet};\n  let {styleProps} = useStyleProps(props);\n\n  // Only hide button text if every item contains more than just plain text (we assume an icon).\n  let isIconCollapsible = useMemo(() => [...state.collection].every(item => typeof item.rendered !== 'string'), [state.collection]);\n  let [{visibleItems, hideButtonText, isMeasuring}, setVisibleItems] = useValueEffect({\n    visibleItems: state.collection.size,\n    hideButtonText: buttonLabelBehavior === 'hide' && isIconCollapsible,\n    isMeasuring: false\n  });\n\n  let selectionMode = state.selectionManager.selectionMode;\n  let updateOverflow = useCallback(() => {\n    if (overflowMode === 'wrap') {\n      return;\n    }\n\n    if (orientation === 'vertical' && selectionMode !== 'none') {\n      // Collapsing vertical action groups with selection is currently unsupported by Spectrum.\n      return;\n    }\n\n    let computeVisibleItems = (visibleItems: number) => {\n      if (domRef.current && wrapperRef.current) {\n        let listItems = Array.from(domRef.current.children) as HTMLLIElement[];\n        let containerSize = orientation === 'horizontal' ? wrapperRef.current.getBoundingClientRect().width : wrapperRef.current.getBoundingClientRect().height;\n\n        let isShowingMenu = visibleItems < state.collection.size;\n        let calculatedSize = 0;\n        let newVisibleItems = 0;\n\n        if (isShowingMenu) {\n          let item = listItems.pop();\n          if (item) {\n            calculatedSize += orientation === 'horizontal'\n              ? outerWidth(item, false, true)\n              : outerHeight(item, false, true);\n          }\n        }\n\n        for (let [i, item] of listItems.entries()) {\n          calculatedSize += orientation === 'horizontal'\n            ? outerWidth(item, i === 0, i === listItems.length - 1)\n            : outerHeight(item, i === 0, i === listItems.length - 1);\n          if (Math.round(calculatedSize) <= Math.round(containerSize)) {\n            newVisibleItems++;\n          } else {\n            break;\n          }\n        }\n\n        // If selection is enabled, and not all of the items fit, collapse all of them into a dropdown\n        // immediately rather than having some visible and some not.\n        if (selectionMode !== 'none' && newVisibleItems < state.collection.size) {\n          return 0;\n        }\n\n        return newVisibleItems;\n      }\n      return visibleItems;\n    };\n\n    setVisibleItems(function *() {\n      let hideButtonText = buttonLabelBehavior === 'hide' && isIconCollapsible;\n\n      // Update to show all items.\n      yield {\n        visibleItems: state.collection.size,\n        hideButtonText,\n        isMeasuring: true\n      };\n\n      // Measure, and update to show the items that fit.\n      let newVisibleItems = computeVisibleItems(state.collection.size);\n      let isMeasuring = newVisibleItems < state.collection.size && newVisibleItems > 0;\n\n      // If not all of the buttons fit, and buttonLabelBehavior is 'collapse', then first try hiding\n      // the button text and only showing icons. Only if that still doesn't fit collapse into a menu.\n      if (newVisibleItems < state.collection.size && buttonLabelBehavior === 'collapse' && isIconCollapsible) {\n        yield {\n          visibleItems: state.collection.size,\n          hideButtonText: true,\n          isMeasuring: true\n        };\n\n        newVisibleItems = computeVisibleItems(state.collection.size);\n        isMeasuring = newVisibleItems < state.collection.size && newVisibleItems > 0;\n        hideButtonText = true;\n      }\n\n      yield {\n        visibleItems: newVisibleItems,\n        hideButtonText,\n        isMeasuring\n      };\n\n      // If the number of items is less than the number of children,\n      // then update again to ensure that the menu fits.\n      if (isMeasuring) {\n        yield {\n          visibleItems: computeVisibleItems(newVisibleItems),\n          hideButtonText,\n          isMeasuring: false\n        };\n      }\n    });\n  }, [domRef, state.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);\n\n  // Watch the parent element for size changes. Watching only the action group itself may not work\n  // in all scenarios because it may not shrink when available space is reduced.\n  let parentRef = useMemo(() => ({\n    get current() {\n      return wrapperRef.current?.parentElement;\n    }\n  }), [wrapperRef]);\n  useResizeObserver({ref: overflowMode !== 'wrap' ? parentRef : undefined, onResize: updateOverflow});\n  useLayoutEffect(updateOverflow, [updateOverflow, state.collection]);\n\n  let children = [...state.collection];\n  let menuItem: ReactElement | null = null;\n  let menuProps = {};\n\n  // If there are no visible items, don't apply any props to the action group container\n  // and pass all aria labeling props through to the menu button.\n  if (overflowMode === 'collapse' && visibleItems === 0) {\n    menuProps = filterDOMProps(props, {labelable: true});\n    actionGroupProps = {};\n  }\n\n  if (overflowMode === 'collapse' && visibleItems < state.collection.size) {\n    let menuChildren = children.slice(visibleItems);\n    children = children.slice(0, visibleItems);\n    menuItem = (\n      <ActionGroupMenu\n        {...menuProps}\n        items={menuChildren}\n        onAction={onAction}\n        isDisabled={isDisabled}\n        isEmphasized={isEmphasized}\n        staticColor={staticColor}\n        state={state}\n        summaryIcon={summaryIcon}\n        hideButtonText={hideButtonText}\n        isOnlyItem={visibleItems === 0}\n        orientation={orientation} />\n    );\n  }\n\n  let style = {\n    ...styleProps.style,\n    // While measuring, take up as much space as possible.\n    flexBasis: isMeasuring ? '100%' : undefined\n  };\n\n  return (\n    <FocusScope>\n      <div {...styleProps} style={style} className={classNames(styles, 'flex-container', styleProps.className)} ref={wrapperRef}>\n        <div\n          {...actionGroupProps}\n          ref={domRef}\n          className={\n            classNames(\n              styles,\n              'flex-gap',\n              'spectrum-ActionGroup',\n              {\n                'spectrum-ActionGroup--quiet': isQuiet,\n                'spectrum-ActionGroup--vertical': isVertical,\n                'spectrum-ActionGroup--compact': density === 'compact',\n                'spectrum-ActionGroup--justified': isJustified && !isMeasuring,\n                'spectrum-ActionGroup--overflowCollapse': overflowMode === 'collapse'\n              },\n              otherProps.UNSAFE_className\n            )\n          }>\n          <Provider {...providerProps}>\n            {children.map((item) => (\n              <ActionGroupItem\n                key={item.key}\n                onAction={onAction}\n                isDisabled={isDisabled}\n                isEmphasized={isEmphasized}\n                staticColor={staticColor}\n                item={item}\n                state={state}\n                hideButtonText={hideButtonText}\n                orientation={orientation} />\n            ))}\n            {menuItem}\n          </Provider>\n        </div>\n      </div>\n    </FocusScope>\n  );\n}\n\n/**\n * An ActionGroup is a grouping of ActionButtons that are related to one another.\n */\nconst _ActionGroup = forwardRef(ActionGroup) as <T>(props: SpectrumActionGroupProps<T> & {ref?: DOMRef<HTMLDivElement>}) => ReactElement;\nexport {_ActionGroup as ActionGroup};\n\ninterface ActionGroupItemProps<T> extends DOMProps, StyleProps {\n  item: Node<T>,\n  state: ListState<T>,\n  isDisabled?: boolean,\n  isEmphasized?: boolean,\n  staticColor?: 'white' | 'black',\n  hideButtonText?: boolean,\n  orientation?: 'horizontal' | 'vertical',\n  onAction?: (key: Key) => void\n}\n\nfunction ActionGroupItem<T>({item, state, isDisabled, isEmphasized, staticColor, onAction, hideButtonText, orientation}: ActionGroupItemProps<T>) {\n  let ref = useRef(null);\n  let {buttonProps} = useActionGroupItem({key: item.key}, state);\n  isDisabled = isDisabled || state.disabledKeys.has(item.key);\n  let isSelected = state.selectionManager.isSelected(item.key);\n  let {hoverProps, isHovered} = useHover({isDisabled});\n  let domProps = filterDOMProps(item.props);\n\n  if (onAction && !isDisabled) {\n    buttonProps = mergeProps(buttonProps, {\n      onPress: () => onAction(item.key)\n    });\n  }\n\n  // If button text is hidden, we need to show it as a tooltip instead, so\n  // go find the text element in the DOM after rendering.\n  let textId = useId();\n  let [textContent, setTextContent] = useState<string | null | undefined>('');\n  useLayoutEffect(() => {\n    if (hideButtonText) {\n      setTextContent(document.getElementById(textId)?.textContent);\n    }\n  }, [hideButtonText, item.rendered, textId]);\n\n  let button = (\n    // Use a PressResponder to send DOM props through.\n    // ActionButton doesn't allow overriding the role by default.\n    <PressResponder {...mergeProps(buttonProps, hoverProps, domProps)}>\n      <ClearSlots>\n        <SlotProvider\n          slots={{\n            text: {\n              id: hideButtonText ? textId : null,\n              isHidden: hideButtonText\n            }\n          }}>\n          <ActionButton\n            ref={ref}\n            // @ts-ignore (private)\n            hideButtonText={hideButtonText}\n            UNSAFE_className={\n              classNames(\n                styles,\n                'spectrum-ActionGroup-item',\n                {\n                  'is-selected': isSelected,\n                  'is-hovered': isHovered,\n                  'spectrum-ActionGroup-item--iconOnly': hideButtonText,\n                  'spectrum-ActionGroup-item--isDisabled': isDisabled\n                },\n                classNames(\n                  buttonStyles,\n                  {\n                    'spectrum-ActionButton--emphasized': isEmphasized,\n                    'is-selected': isSelected\n                  }\n                )\n              )\n            }\n            isDisabled={isDisabled}\n            staticColor={staticColor}\n            aria-label={item['aria-label']}\n            aria-labelledby={item['aria-label'] == null && hideButtonText ? textId : undefined}>\n            {item.rendered}\n          </ActionButton>\n        </SlotProvider>\n      </ClearSlots>\n    </PressResponder>\n  );\n\n  if (hideButtonText && textContent) {\n    button = (\n      <TooltipTrigger placement={orientation === 'vertical' ? 'end' : 'top'}>\n        {button}\n        <Tooltip>{textContent}</Tooltip>\n      </TooltipTrigger>\n    );\n  }\n\n  if (item.wrapper) {\n    button = item.wrapper(button);\n  }\n\n  return button;\n}\n\ninterface ActionGroupMenuProps<T> extends AriaLabelingProps {\n  state: ListState<T>,\n  isDisabled?: boolean,\n  isEmphasized?: boolean,\n  staticColor?: 'white' | 'black',\n  items: Node<T>[],\n  hideButtonText?: boolean,\n  summaryIcon?: ReactNode,\n  isOnlyItem?: boolean,\n  orientation?: 'horizontal' | 'vertical',\n  onAction?: (key: Key) => void\n}\n\nfunction ActionGroupMenu<T>({state, isDisabled, isEmphasized, staticColor, items, onAction, summaryIcon, hideButtonText, isOnlyItem, orientation, ...otherProps}: ActionGroupMenuProps<T>) {\n  // Use the key of the first item within the menu as the key of the button.\n  // The key must actually exist in the collection for focus to work correctly.\n  let key = items[0].key;\n  let {buttonProps} = useActionGroupItem({key}, state);\n\n  // The menu button shouldn't act like an actual action group item.\n  delete buttonProps.onPress;\n  delete buttonProps.role;\n  delete buttonProps['aria-checked'];\n\n  let {hoverProps, isHovered} = useHover({isDisabled});\n\n  // If no aria-label or aria-labelledby is given, provide a default one.\n  let ariaLabel = otherProps['aria-label'] || (otherProps['aria-labelledby'] ? undefined : '…');\n  let ariaLabelledby = otherProps['aria-labelledby'];\n  let textId = useId();\n  let id = useId();\n\n  // Summary icon only applies when selection is enabled.\n  if (state.selectionManager.selectionMode === 'none') {\n    summaryIcon = null;\n  }\n\n  let iconOnly = false;\n\n  // If there is a selection, show the selected state on the menu button.\n  let isSelected = state.selectionManager.selectionMode !== 'none' && !state.selectionManager.isEmpty;\n\n  // If single selection and empty selection is not allowed, swap the contents of the button to the selected item (like a Picker).\n  if (!summaryIcon && state.selectionManager.selectionMode === 'single' && state.selectionManager.disallowEmptySelection && state.selectionManager.firstSelectedKey != null) {\n    let selectedItem = state.collection.getItem(state.selectionManager.firstSelectedKey);\n    if (selectedItem) {\n      summaryIcon = selectedItem.rendered;\n      if (typeof summaryIcon === 'string') {\n        summaryIcon = <Text>{summaryIcon}</Text>;\n      }\n      iconOnly = !!hideButtonText;\n      ariaLabelledby = `${ariaLabelledby ?? id} ${textId}`;\n    }\n  }\n\n  if (summaryIcon) {\n    // If there's a custom summary icon, also add a chevron.\n    summaryIcon = (\n      <>\n        <ChevronDownMedium UNSAFE_className={classNames(styles, 'spectrum-ActionGroup-menu-chevron')} />\n        <span className={classNames(styles, 'spectrum-ActionGroup-menu-contents', {'spectrum-ActionGroup-item--iconOnly': iconOnly})}>\n          {summaryIcon}\n        </span>\n      </>\n    );\n  }\n\n  return (\n    // Use a PressResponder to send DOM props through.\n    <MenuTrigger align={isOnlyItem ? 'start' : 'end'} direction={orientation === 'vertical' ? 'end' : 'bottom'}>\n      <SlotProvider\n        slots={{\n          text: {\n            id: hideButtonText ? textId : null,\n            isHidden: hideButtonText,\n            UNSAFE_className: classNames(styles, 'spectrum-ActionGroup-menu-text')\n          }\n        }}>\n        <PressResponder {...mergeProps(buttonProps, hoverProps)}>\n          <ActionButton\n            {...otherProps}\n            id={id}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledby}\n            UNSAFE_className={\n              classNames(\n                styles,\n                'spectrum-ActionGroup-item',\n                'spectrum-ActionGroup-menu',\n                {\n                  'is-hovered': isHovered,\n                  'is-selected': isSelected\n                },\n                classNames(\n                  buttonStyles,\n                  {\n                    'is-selected': isSelected,\n                    'spectrum-ActionButton--emphasized': isEmphasized\n                  }\n                )\n              )\n            }\n            isDisabled={isDisabled}\n            staticColor={staticColor}>\n            {summaryIcon || <More />}\n          </ActionButton>\n        </PressResponder>\n      </SlotProvider>\n      <Menu\n        items={items}\n        disabledKeys={state.disabledKeys}\n        selectionMode={state.selectionManager.selectionMode}\n        selectedKeys={state.selectionManager.selectedKeys}\n        disallowEmptySelection={state.selectionManager.disallowEmptySelection}\n        onSelectionChange={(keys) => state.selectionManager.setSelectedKeys(keys)}\n        onAction={onAction}>\n        {node => <Item textValue={node.textValue} {...filterDOMProps(node.props)}>{node.rendered}</Item>}\n      </Menu>\n    </MenuTrigger>\n  );\n}\n\nfunction outerWidth(element: HTMLElement, ignoreLeftMargin: boolean, ignoreRightMargin: boolean) {\n  let style = window.getComputedStyle(element);\n  return element.getBoundingClientRect().width + (ignoreLeftMargin ? 0 : toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : toNumber(style.marginRight));\n}\n\n\nfunction outerHeight(element: HTMLElement, ignoreTopMargin: boolean, ignoreBottomMargin: boolean) {\n  let style = window.getComputedStyle(element);\n  return element.getBoundingClientRect().height + (ignoreTopMargin ? 0 : toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : toNumber(style.marginBottom));\n}\n\nfunction toNumber(value: string) {\n  let parsed = parseInt(value, 10);\n  return isNaN(parsed) ? 0 : parsed;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;AAuCA,SAASA,kCAA8BC,KAAkC,EAAEC,GAA2B;EACpGD,KAAA,GAAQ,IAAAE,uBAAe,EAAEF,KAAA;EACzBA,KAAA,GAAQ,IAAAG,mBAAW,EAAEH,KAAA,EAAO;EAE5B,IAAI;IAAAI,YAAA,EACFA,YAAY;IAAAC,OAAA,EACZA,OAAO;IAAAC,WAAA,EACPA,WAAW;IAAAC,UAAA,EACXA,UAAU;IACVC,WAAA,GAAc;IAAAC,OAAA,EACdA,OAAO;IAAAC,WAAA,EACPA,WAAW;IACXC,YAAA,GAAe;IAAAC,QAAA,EACfA,QAAQ;IAAAC,mBAAA,EACRA,mBAAmB;IAAAC,WAAA,EACnBA,WAAW;IACX,GAAGC;EAAA,CACJ,GAAGf,KAAA;EAEJ,IAAIgB,MAAA,GAAS,IAAAC,gBAAQ,EAAEhB,GAAA;EACvB,IAAIiB,UAAA,GAAa,IAAAC,aAAK,EAAkB;EACxC,IAAIC,KAAA,GAAQ,IAAAC,mBAAW,EAAE;IAAC,GAAGrB,KAAK;IAAEsB,wBAAA,EAA0B;EAAI;EAClE,IAAI;IAAAC,gBAAA,EAACA;EAAgB,CAAC,GAAG,IAAAC,qBAAa,EAAExB,KAAA,EAAOoB,KAAA,EAAOJ,MAAA;EACtD,IAAIS,UAAA,GAAajB,WAAA,KAAgB;EACjC,IAAIkB,aAAA,GAAgB;kBAACtB,YAAA;gBAAcG,UAAA;aAAYE;EAAO;EACtD,IAAI;IAAAkB,UAAA,EAACA;EAAU,CAAC,GAAG,IAAAC,oBAAY,EAAE5B,KAAA;EAEjC;EACA,IAAI6B,iBAAA,GAAoB,IAAAC,cAAM,EAAE,MAAM,C,GAAIV,KAAA,CAAMW,UAAU,CAAC,CAACC,KAAK,CAACC,IAAA,IAAQ,OAAOA,IAAA,CAAKC,QAAQ,KAAK,WAAW,CAACd,KAAA,CAAMW,UAAU,CAAC;EAChI,IAAI,CAAC;IAAAI,YAAA,EAACA,YAAY;IAAAC,cAAA,EAAEA,cAAc;IAAAC,WAAA,EAAEA;EAAW,CAAC,EAAEC,eAAA,CAAgB,GAAG,IAAAC,qBAAa,EAAE;IAClFJ,YAAA,EAAcf,KAAA,CAAMW,UAAU,CAACS,IAAI;IACnCJ,cAAA,EAAgBvB,mBAAA,KAAwB,UAAUgB,iBAAA;IAClDQ,WAAA,EAAa;EACf;EAEA,IAAII,aAAA,GAAgBrB,KAAA,CAAMsB,gBAAgB,CAACD,aAAa;EACxD,IAAIE,cAAA,GAAiB,IAAAC,kBAAU,EAAE;IAC/B,IAAIjC,YAAA,KAAiB,QACnB;IAGF,IAAIH,WAAA,KAAgB,cAAciC,aAAA,KAAkB;MAClD;MACA;IAGF,IAAII,mBAAA,GAAuBV,YAAA;MACzB,IAAInB,MAAA,CAAO8B,OAAO,IAAI5B,UAAA,CAAW4B,OAAO,EAAE;QACxC,IAAIC,SAAA,GAAYC,KAAA,CAAMC,IAAI,CAACjC,MAAA,CAAO8B,OAAO,CAACI,QAAQ;QAClD,IAAIC,aAAA,GAAgB3C,WAAA,KAAgB,eAAeU,UAAA,CAAW4B,OAAO,CAACM,qBAAqB,GAAGC,KAAK,GAAGnC,UAAA,CAAW4B,OAAO,CAACM,qBAAqB,GAAGE,MAAM;QAEvJ,IAAIC,aAAA,GAAgBpB,YAAA,GAAef,KAAA,CAAMW,UAAU,CAACS,IAAI;QACxD,IAAIgB,cAAA,GAAiB;QACrB,IAAIC,eAAA,GAAkB;QAEtB,IAAIF,aAAA,EAAe;UACjB,IAAItB,IAAA,GAAOc,SAAA,CAAUW,GAAG;UACxB,IAAIzB,IAAA,EACFuB,cAAA,IAAkBhD,WAAA,KAAgB,eAC9BmD,gCAAA,CAAW1B,IAAA,EAAM,OAAO,QACxB2B,iCAAA,CAAY3B,IAAA,EAAM,OAAO;QAEjC;QAEA,KAAK,IAAI,CAAC4B,CAAA,EAAG5B,IAAA,CAAK,IAAIc,SAAA,CAAUe,OAAO,IAAI;UACzCN,cAAA,IAAkBhD,WAAA,KAAgB,eAC9BmD,gCAAA,CAAW1B,IAAA,EAAM4B,CAAA,KAAM,GAAGA,CAAA,KAAMd,SAAA,CAAUgB,MAAM,GAAG,KACnDH,iCAAA,CAAY3B,IAAA,EAAM4B,CAAA,KAAM,GAAGA,CAAA,KAAMd,SAAA,CAAUgB,MAAM,GAAG;UACxD,IAAIC,IAAA,CAAKC,KAAK,CAACT,cAAA,KAAmBQ,IAAA,CAAKC,KAAK,CAACd,aAAA,GAC3CM,eAAA,QAEA;QAEJ;QAEA;QACA;QACA,IAAIhB,aAAA,KAAkB,UAAUgB,eAAA,GAAkBrC,KAAA,CAAMW,UAAU,CAACS,IAAI,EACrE,OAAO;QAGT,OAAOiB,eAAA;MACT;MACA,OAAOtB,YAAA;IACT;IAEAG,eAAA,CAAgB;MACd,IAAIF,cAAA,GAAiBvB,mBAAA,KAAwB,UAAUgB,iBAAA;MAEvD;MACA,MAAM;QACJM,YAAA,EAAcf,KAAA,CAAMW,UAAU,CAACS,IAAI;wBACnCJ,cAAA;QACAC,WAAA,EAAa;MACf;MAEA;MACA,IAAIoB,eAAA,GAAkBZ,mBAAA,CAAoBzB,KAAA,CAAMW,UAAU,CAACS,IAAI;MAC/D,IAAIH,WAAA,GAAcoB,eAAA,GAAkBrC,KAAA,CAAMW,UAAU,CAACS,IAAI,IAAIiB,eAAA,GAAkB;MAE/E;MACA;MACA,IAAIA,eAAA,GAAkBrC,KAAA,CAAMW,UAAU,CAACS,IAAI,IAAI3B,mBAAA,KAAwB,cAAcgB,iBAAA,EAAmB;QACtG,MAAM;UACJM,YAAA,EAAcf,KAAA,CAAMW,UAAU,CAACS,IAAI;UACnCJ,cAAA,EAAgB;UAChBC,WAAA,EAAa;QACf;QAEAoB,eAAA,GAAkBZ,mBAAA,CAAoBzB,KAAA,CAAMW,UAAU,CAACS,IAAI;QAC3DH,WAAA,GAAcoB,eAAA,GAAkBrC,KAAA,CAAMW,UAAU,CAACS,IAAI,IAAIiB,eAAA,GAAkB;QAC3ErB,cAAA,GAAiB;MACnB;MAEA,MAAM;QACJD,YAAA,EAAcsB,eAAA;wBACdrB,cAAA;qBACAC;MACF;MAEA;MACA;MACA,IAAIA,WAAA,EACF,MAAM;QACJF,YAAA,EAAcU,mBAAA,CAAoBY,eAAA;wBAClCrB,cAAA;QACAC,WAAA,EAAa;MACf;IAEJ;EACF,GAAG,CAACrB,MAAA,EAAQI,KAAA,CAAMW,UAAU,EAAEO,eAAA,EAAiB3B,YAAA,EAAc8B,aAAA,EAAe5B,mBAAA,EAAqBgB,iBAAA,EAAmBrB,WAAA,CAAY;EAEhI;EACA;EACA,IAAI0D,SAAA,GAAY,IAAApC,cAAM,EAAE,OAAO;IAC7B,IAAIgB,QAAA,EAAU;UACLqB,mBAAA;MAAP,QAAOA,mBAAA,GAAAjD,UAAA,CAAW4B,OAAO,cAAlBqB,mBAAA,uBAAAA,mBAAA,CAAoBC,aAAa;IAC1C;EACF,IAAI,CAAClD,UAAA,CAAW;EAChB,IAAAmD,wBAAgB,EAAE;IAACpE,GAAA,EAAKU,YAAA,KAAiB,SAASuD,SAAA,GAAYI,SAAA;IAAWC,QAAA,EAAU5B;EAAc;EACjG,IAAA6B,sBAAc,EAAE7B,cAAA,EAAgB,CAACA,cAAA,EAAgBvB,KAAA,CAAMW,UAAU,CAAC;EAElE,IAAImB,QAAA,GAAW,C,GAAI9B,KAAA,CAAMW,UAAU,CAAC;EACpC,IAAI0C,QAAA,GAAgC;EACpC,IAAIC,SAAA,GAAY,CAAC;EAEjB;EACA;EACA,IAAI/D,YAAA,KAAiB,cAAcwB,YAAA,KAAiB,GAAG;IACrDuC,SAAA,GAAY,IAAAC,qBAAa,EAAE3E,KAAA,EAAO;MAAC4E,SAAA,EAAW;IAAI;IAClDrD,gBAAA,GAAmB,CAAC;EACtB;EAEA,IAAIZ,YAAA,KAAiB,cAAcwB,YAAA,GAAef,KAAA,CAAMW,UAAU,CAACS,IAAI,EAAE;IACvE,IAAIqC,YAAA,GAAe3B,QAAA,CAAS4B,KAAK,CAAC3C,YAAA;IAClCe,QAAA,GAAWA,QAAA,CAAS4B,KAAK,CAAC,GAAG3C,YAAA;IAC7BsC,QAAA,gBACE,IAAAM,YAAA,EAAAC,aAAA,CAACC,qCAAA;MACE,GAAGP,SAAS;MACbQ,KAAA,EAAOL,YAAA;MACPjE,QAAA,EAAUA,QAAA;MACVL,UAAA,EAAYA,UAAA;MACZH,YAAA,EAAcA,YAAA;MACdM,WAAA,EAAaA,WAAA;MACbU,KAAA,EAAOA,KAAA;MACPN,WAAA,EAAaA,WAAA;MACbsB,cAAA,EAAgBA,cAAA;MAChB+C,UAAA,EAAYhD,YAAA,KAAiB;MAC7B3B,WAAA,EAAaA;;EAEnB;EAEA,IAAI4E,KAAA,GAAQ;IACV,GAAGzD,UAAA,CAAWyD,KAAK;IACnB;IACAC,SAAA,EAAWhD,WAAA,GAAc,SAASiC;EACpC;EAEA,oBACE,IAAAS,YAAA,EAAAC,aAAA,EAAC,GAAAM,iBAAS,sBACR,IAAAP,YAAA,EAAAC,aAAA,CAAC;IAAK,GAAGrD,UAAU;IAAEyD,KAAA,EAAOA,KAAA;IAAOG,SAAA,EAAW,IAAAC,iBAAS,GAAE,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GAAG,kBAAkB/D,UAAA,CAAW4D,SAAS;IAAGtF,GAAA,EAAKiB;kBAC7G,IAAA6D,YAAA,EAAAC,aAAA,CAAC;IACE,GAAGzD,gBAAgB;IACpBtB,GAAA,EAAKe,MAAA;IACLuE,SAAA,EACE,IAAAC,iBAAS,GACP,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GACL,YACA,wBACA;MACE,+BAA+BjF,OAAA;MAC/B,kCAAkCgB,UAAA;MAClC,iCAAiCpB,OAAA,KAAY;MAC7C,mCAAmCC,WAAA,IAAe,CAAC+B,WAAA;MACnD,0CAA0C1B,YAAA,KAAiB;IAC7D,GACAI,UAAA,CAAW4E,gBAAgB;kBAG/B,IAAAZ,YAAA,EAAAC,aAAA,EAAC,GAAAY,eAAO,GAAMlE,aAAA,EACXwB,QAAA,CAAS2C,GAAG,CAAE5D,IAAA,iBACb,IAAA8C,YAAA,EAAAC,aAAA,CAACc,qCAAA;IACCC,GAAA,EAAK9D,IAAA,CAAK8D,GAAG;IACbnF,QAAA,EAAUA,QAAA;IACVL,UAAA,EAAYA,UAAA;IACZH,YAAA,EAAcA,YAAA;IACdM,WAAA,EAAaA,WAAA;IACbuB,IAAA,EAAMA,IAAA;IACNb,KAAA,EAAOA,KAAA;IACPgB,cAAA,EAAgBA,cAAA;IAChB5B,WAAA,EAAaA;OAEhBiE,QAAA;AAMb;AAEA;;;AAGA,MAAMuB,yCAAA,gBAAe,IAAAC,iBAAS,EAAElG,iCAAA;AAchC,SAAS+F,sCAAmB;EAAA7D,IAAA,EAACA,IAAI;EAAAb,KAAA,EAAEA,KAAK;EAAAb,UAAA,EAAEA,UAAU;EAAAH,YAAA,EAAEA,YAAY;EAAAM,WAAA,EAAEA,WAAW;EAAAE,QAAA,EAAEA,QAAQ;EAAAwB,cAAA,EAAEA,cAAc;EAAA5B,WAAA,EAAEA;AAAW,CAA0B;EAC9I,IAAIP,GAAA,GAAM,IAAAkB,aAAK,EAAE;EACjB,IAAI;IAAA+E,WAAA,EAACA;EAAW,CAAC,GAAG,IAAAC,yBAAiB,EAAE;IAACJ,GAAA,EAAK9D,IAAA,CAAK8D;EAAG,GAAG3E,KAAA;EACxDb,UAAA,GAAaA,UAAA,IAAca,KAAA,CAAMgF,YAAY,CAACC,GAAG,CAACpE,IAAA,CAAK8D,GAAG;EAC1D,IAAIO,UAAA,GAAalF,KAAA,CAAMsB,gBAAgB,CAAC4D,UAAU,CAACrE,IAAA,CAAK8D,GAAG;EAC3D,IAAI;IAAAQ,UAAA,EAACA,UAAU;IAAAC,SAAA,EAAEA;EAAS,CAAC,GAAG,IAAAC,eAAO,EAAE;gBAAClG;EAAU;EAClD,IAAImG,QAAA,GAAW,IAAA/B,qBAAa,EAAE1C,IAAA,CAAKjC,KAAK;EAExC,IAAIY,QAAA,IAAY,CAACL,UAAA,EACf2F,WAAA,GAAc,IAAAS,iBAAS,EAAET,WAAA,EAAa;IACpCU,OAAA,EAASA,CAAA,KAAMhG,QAAA,CAASqB,IAAA,CAAK8D,GAAG;EAClC;EAGF;EACA;EACA,IAAIc,MAAA,GAAS,IAAAC,YAAI;EACjB,IAAI,CAACC,WAAA,EAAaC,cAAA,CAAe,GAAG,IAAAC,eAAO,EAA6B;EACxE,IAAAzC,sBAAc,EAAE;QAEG0C,wBAAA;IADjB,IAAI9E,cAAA,EACF4E,cAAA,EAAeE,wBAAA,GAAAC,QAAA,CAASC,cAAc,CAACP,MAAA,eAAxBK,wBAAA,uBAAAA,wBAAA,CAAiCH,WAAW;EAE/D,GAAG,CAAC3E,cAAA,EAAgBH,IAAA,CAAKC,QAAQ,EAAE2E,MAAA,CAAO;EAE1C,IAAIQ,MAAA;EACF;EACA;;EACA,IAAAtC,YAAA,EAAAC,aAAA,EAAC,GAAAsC,qBAAa,GAAM,IAAAX,iBAAS,EAAET,WAAA,EAAaK,UAAA,EAAYG,QAAA,gBACtD,IAAA3B,YAAA,EAAAC,aAAA,EAAC,GAAAuC,iBAAS,sBACR,IAAAxC,YAAA,EAAAC,aAAA,EAAC,GAAAwC,mBAAW;IACVC,KAAA,EAAO;MACLC,IAAA,EAAM;QACJC,EAAA,EAAIvF,cAAA,GAAiByE,MAAA,GAAS;QAC9Be,QAAA,EAAUxF;MACZ;IACF;kBACA,IAAA2C,YAAA,EAAAC,aAAA,EAAC,GAAA6C,mBAAW;IACV5H,GAAA,EAAKA,GAAA;IACL;IACAmC,cAAA,EAAgBA,cAAA;IAChBuD,gBAAA,EACE,IAAAH,iBAAS,GACP,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GACL,6BACA;MACE,eAAeY,UAAA;MACf,cAAcE,SAAA;MACd,uCAAuCpE,cAAA;MACvC,yCAAyC7B;IAC3C,GACA,IAAAiF,iBAAS,GACP,GAAAC,sBAAA,CAAAqC,8BAAA,CAAW,GACX;MACE,qCAAqC1H,YAAA;MACrC,eAAekG;IACjB;IAIN/F,UAAA,EAAYA,UAAA;IACZG,WAAA,EAAaA,WAAA;IACb,cAAYuB,IAAI,CAAC,aAAa;IAC9B,mBAAiBA,IAAI,CAAC,aAAa,IAAI,QAAQG,cAAA,GAAiByE,MAAA,GAASvC;KACxErC,IAAA,CAAKC,QAAQ;EAOxB,IAAIE,cAAA,IAAkB2E,WAAA,EACpBM,MAAA,gBACE,IAAAtC,YAAA,EAAAC,aAAA,EAAC,GAAA+C,qBAAa;IAAEC,SAAA,EAAWxH,WAAA,KAAgB,aAAa,QAAQ;KAC7D6G,MAAA,eACD,IAAAtC,YAAA,EAAAC,aAAA,EAAC,GAAAiD,cAAM,SAAGlB,WAAA;EAKhB,IAAI9E,IAAA,CAAKiG,OAAO,EACdb,MAAA,GAASpF,IAAA,CAAKiG,OAAO,CAACb,MAAA;EAGxB,OAAOA,MAAA;AACT;AAeA,SAASpC,sCAAmB;EAAA7D,KAAA,EAACA,KAAK;EAAAb,UAAA,EAAEA,UAAU;EAAAH,YAAA,EAAEA,YAAY;EAAAM,WAAA,EAAEA,WAAW;EAAAwE,KAAA,EAAEA,KAAK;EAAAtE,QAAA,EAAEA,QAAQ;EAAAE,WAAA,EAAEA,WAAW;EAAAsB,cAAA,EAAEA,cAAc;EAAA+C,UAAA,EAAEA,UAAU;EAAA3E,WAAA,EAAEA,WAAW;EAAE,GAAGO;AAAA,CAAoC;EACvL;EACA;EACA,IAAIgF,GAAA,GAAMb,KAAK,CAAC,EAAE,CAACa,GAAG;EACtB,IAAI;IAAAG,WAAA,EAACA;EAAW,CAAC,GAAG,IAAAC,yBAAiB,EAAE;SAACJ;EAAG,GAAG3E,KAAA;EAE9C;EACA,OAAO8E,WAAA,CAAYU,OAAO;EAC1B,OAAOV,WAAA,CAAYiC,IAAI;EACvB,OAAOjC,WAAW,CAAC,eAAe;EAElC,IAAI;IAAAK,UAAA,EAACA,UAAU;IAAAC,SAAA,EAAEA;EAAS,CAAC,GAAG,IAAAC,eAAO,EAAE;gBAAClG;EAAU;EAElD;EACA,IAAI6H,SAAA,GAAYrH,UAAU,CAAC,aAAa,KAAKA,UAAU,CAAC,kBAAkB,GAAGuD,SAAA,GAAY,QAAE;EAC3F,IAAI+D,cAAA,GAAiBtH,UAAU,CAAC,kBAAkB;EAClD,IAAI8F,MAAA,GAAS,IAAAC,YAAI;EACjB,IAAIa,EAAA,GAAK,IAAAb,YAAI;EAEb;EACA,IAAI1F,KAAA,CAAMsB,gBAAgB,CAACD,aAAa,KAAK,QAC3C3B,WAAA,GAAc;EAGhB,IAAIwH,QAAA,GAAW;EAEf;EACA,IAAIhC,UAAA,GAAalF,KAAA,CAAMsB,gBAAgB,CAACD,aAAa,KAAK,UAAU,CAACrB,KAAA,CAAMsB,gBAAgB,CAAC6F,OAAO;EAEnG;EACA,IAAI,CAACzH,WAAA,IAAeM,KAAA,CAAMsB,gBAAgB,CAACD,aAAa,KAAK,YAAYrB,KAAA,CAAMsB,gBAAgB,CAAC8F,sBAAsB,IAAIpH,KAAA,CAAMsB,gBAAgB,CAAC+F,gBAAgB,IAAI,MAAM;IACzK,IAAIC,YAAA,GAAetH,KAAA,CAAMW,UAAU,CAAC4G,OAAO,CAACvH,KAAA,CAAMsB,gBAAgB,CAAC+F,gBAAgB;IACnF,IAAIC,YAAA,EAAc;MAChB5H,WAAA,GAAc4H,YAAA,CAAaxG,QAAQ;MACnC,IAAI,OAAOpB,WAAA,KAAgB,UACzBA,WAAA,gBAAc,IAAAiE,YAAA,EAAAC,aAAA,EAAC,GAAA4D,WAAG,SAAG9H,WAAA;MAEvBwH,QAAA,GAAW,CAAC,CAAClG,cAAA;MACbiG,cAAA,GAAiB,GAAGA,cAAA,aAAAA,cAAA,cAAAA,cAAA,GAAkBV,EAAA,IAAMd,MAAA,EAAQ;IACtD;EACF;EAEA,IAAI/F,WAAA;IACF;IACAA,WAAA,gBACE,IAAAiE,YAAA,EAAAC,aAAA,KAAAD,YAAA,EAAA8D,QAAA,qBACE,IAAA9D,YAAA,EAAAC,aAAA,EAAC,GAAA8D,uCAAgB;MAAEnD,gBAAA,EAAkB,IAAAH,iBAAS,GAAE,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GAAG;qBACxD,IAAAX,YAAA,EAAAC,aAAA,CAAC;MAAKO,SAAA,EAAW,IAAAC,iBAAS,GAAE,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GAAG,sCAAsC;QAAC,uCAAuC4C;MAAQ;OACvHxH,WAAA;EAMT;IACE;;IACA,IAAAiE,YAAA,EAAAC,aAAA,EAAC,GAAA+D,kBAAU;MAAEC,KAAA,EAAO7D,UAAA,GAAa,UAAU;MAAO8D,SAAA,EAAWzI,WAAA,KAAgB,aAAa,QAAQ;oBAChG,IAAAuE,YAAA,EAAAC,aAAA,EAAC,GAAAwC,mBAAW;MACVC,KAAA,EAAO;QACLC,IAAA,EAAM;UACJC,EAAA,EAAIvF,cAAA,GAAiByE,MAAA,GAAS;UAC9Be,QAAA,EAAUxF,cAAA;UACVuD,gBAAA,EAAkB,IAAAH,iBAAS,GAAE,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GAAG;QACvC;MACF;oBACA,IAAAX,YAAA,EAAAC,aAAA,EAAC,GAAAsC,qBAAa,GAAM,IAAAX,iBAAS,EAAET,WAAA,EAAaK,UAAA,gBAC1C,IAAAxB,YAAA,EAAAC,aAAA,EAAC,GAAA6C,mBAAW;MACT,GAAG9G,UAAU;MACd4G,EAAA,EAAIA,EAAA;MACJ,cAAYS,SAAA;MACZ,mBAAiBC,cAAA;MACjB1C,gBAAA,EACE,IAAAH,iBAAS,GACP,GAAAC,sBAAA,CAAAC,mCAAA,CAAK,GACL,6BACA,6BACA;QACE,cAAcc,SAAA;QACd,eAAeF;MACjB,GACA,IAAAd,iBAAS,GACP,GAAAC,sBAAA,CAAAqC,8BAAA,CAAW,GACX;QACE,eAAexB,UAAA;QACf,qCAAqClG;MACvC;MAING,UAAA,EAAYA,UAAA;MACZG,WAAA,EAAaA;OACZI,WAAA,iBAAe,IAAAiE,YAAA,EAAAC,aAAA,EAAC,GAAAkE,gCAAG,0BAI1B,IAAAnE,YAAA,EAAAC,aAAA,EAAC,GAAAmE,WAAG;MACFjE,KAAA,EAAOA,KAAA;MACPkB,YAAA,EAAchF,KAAA,CAAMgF,YAAY;MAChC3D,aAAA,EAAerB,KAAA,CAAMsB,gBAAgB,CAACD,aAAa;MACnD2G,YAAA,EAAchI,KAAA,CAAMsB,gBAAgB,CAAC0G,YAAY;MACjDZ,sBAAA,EAAwBpH,KAAA,CAAMsB,gBAAgB,CAAC8F,sBAAsB;MACrEa,iBAAA,EAAoBC,IAAA,IAASlI,KAAA,CAAMsB,gBAAgB,CAAC6G,eAAe,CAACD,IAAA;MACpE1I,QAAA,EAAUA;OACT4I,IAAA,iBAAQ,IAAAzE,YAAA,EAAAC,aAAA,EAAC,GAAAyE,WAAG;MAAEC,SAAA,EAAWF,IAAA,CAAKE,SAAS;MAAG,GAAG,IAAA/E,qBAAa,EAAE6E,IAAA,CAAKxJ,KAAK;OAAIwJ,IAAA,CAAKtH,QAAQ;EAAA;AAIhG;AAEA,SAASyB,iCAAWgG,OAAoB,EAAEC,gBAAyB,EAAEC,iBAA0B;EAC7F,IAAIzE,KAAA,GAAQ0E,MAAA,CAAOC,gBAAgB,CAACJ,OAAA;EACpC,OAAOA,OAAA,CAAQvG,qBAAqB,GAAGC,KAAK,IAAIuG,gBAAA,GAAmB,IAAII,8BAAA,CAAS5E,KAAA,CAAM6E,UAAU,MAAMJ,iBAAA,GAAoB,IAAIG,8BAAA,CAAS5E,KAAA,CAAM8E,WAAW;AAC1J;AAGA,SAAStG,kCAAY+F,OAAoB,EAAEQ,eAAwB,EAAEC,kBAA2B;EAC9F,IAAIhF,KAAA,GAAQ0E,MAAA,CAAOC,gBAAgB,CAACJ,OAAA;EACpC,OAAOA,OAAA,CAAQvG,qBAAqB,GAAGE,MAAM,IAAI6G,eAAA,GAAkB,IAAIH,8BAAA,CAAS5E,KAAA,CAAMiF,SAAS,MAAMD,kBAAA,GAAqB,IAAIJ,8BAAA,CAAS5E,KAAA,CAAMkF,YAAY;AAC3J;AAEA,SAASN,+BAASO,KAAa;EAC7B,IAAIC,MAAA,GAASC,QAAA,CAASF,KAAA,EAAO;EAC7B,OAAOG,KAAA,CAAMF,MAAA,IAAU,IAAIA,MAAA;AAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}