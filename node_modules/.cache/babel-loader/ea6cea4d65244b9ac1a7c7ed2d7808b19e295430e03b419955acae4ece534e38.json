{"ast":null,"code":"import { getChildNodes as $img26$getChildNodes } from \"@react-stately/collections\";\nimport { Rect as $img26$Rect, Size as $img26$Size, LayoutInfo as $img26$LayoutInfo, Point as $img26$Point, Layout as $img26$Layout } from \"@react-stately/virtualizer\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;\nclass $61ef60fc9b1041f4$export$cacbb3924155d68e extends (0, $img26$Layout) {\n  getLayoutInfo(key) {\n    var _this_layoutNodes_get;\n    this.ensureLayoutInfo(key);\n    return ((_this_layoutNodes_get = this.layoutNodes.get(key)) === null || _this_layoutNodes_get === void 0 ? void 0 : _this_layoutNodes_get.layoutInfo) || null;\n  }\n  getVisibleLayoutInfos(rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      var _this_rowHeight;\n      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n    let res = [];\n    let addNodes = nodes => {\n      for (let node of nodes) if (this.isVisible(node, rect)) {\n        res.push(node.layoutInfo);\n        if (node.children) addNodes(node.children);\n      }\n    };\n    addNodes(this.rootNodes);\n    return res;\n  }\n  layoutIfNeeded(rect) {\n    if (!this.lastCollection) return;\n    if (!this.requestedRect.containsRect(rect)) {\n      this.requestedRect = this.requestedRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n    // Ensure all of the persisted keys are available.\n    for (let key of this.virtualizer.persistedKeys) {\n      if (this.ensureLayoutInfo(key)) return;\n    }\n  }\n  ensureLayoutInfo(key) {\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n      this.requestedRect = new (0, $img26$Rect)(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.requestedRect = new (0, $img26$Rect)(0, 0, this.contentSize.width, this.contentSize.height);\n      return true;\n    }\n    return false;\n  }\n  isVisible(node, rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n  }\n  shouldInvalidateEverything(invalidationContext) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged;\n  }\n  update(invalidationContext) {\n    this.collection = this.virtualizer.collection;\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.requestedRect = this.virtualizer.visibleRect.copy();\n      this.layoutNodes.clear();\n    }\n    this.rootNodes = this.buildCollection();\n    // Remove deleted layout nodes\n    if (this.lastCollection && this.collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) if (!this.collection.getItem(key)) {\n        let layoutNode = this.layoutNodes.get(key);\n        if (layoutNode) this.layoutNodes.delete(key);\n      }\n    }\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n    this.invalidateEverything = false;\n    this.validRect = this.requestedRect.copy();\n  }\n  buildCollection(y = 0) {\n    let skipped = 0;\n    let nodes = [];\n    for (let node of this.collection) {\n      var _this_rowHeight;\n      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n      let layoutNode = this.buildChild(node, 0, y, null);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n      if (node.type === 'item' && y > this.requestedRect.maxY) {\n        y += (this.collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n    this.contentSize = new (0, $img26$Size)(this.virtualizer.visibleRect.width, y);\n    return nodes;\n  }\n  isValid(node, y) {\n    let cached = this.layoutNodes.get(node.key);\n    return !this.invalidateEverything && cached && cached.node === node && y === cached.layoutInfo.rect.y && cached.layoutInfo.rect.intersects(this.validRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect));\n  }\n  buildChild(node, x, y, parentKey) {\n    if (this.isValid(node, y)) return this.layoutNodes.get(node.key);\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.layoutInfo.parentKey = parentKey !== null && parentKey !== void 0 ? parentKey : null;\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n      case 'header':\n        return this.buildSectionHeader(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n    }\n  }\n  buildLoader(node, x, y) {\n    let rect = new (0, $img26$Rect)(x, y, 0, 0);\n    let layoutInfo = new (0, $img26$LayoutInfo)('loader', node.key, rect);\n    rect.width = this.virtualizer.contentSize.width;\n    rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight;\n    return {\n      layoutInfo: layoutInfo,\n      validRect: rect.intersection(this.requestedRect)\n    };\n  }\n  buildSection(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rect = new (0, $img26$Rect)(0, y, width, 0);\n    let layoutInfo = new (0, $img26$LayoutInfo)(node.type, node.key, rect);\n    let startY = y;\n    let skipped = 0;\n    let children = [];\n    for (let child of (0, $img26$getChildNodes)(node, this.collection)) {\n      var _this_rowHeight;\n      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n      let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...(0, $img26$getChildNodes)(node, this.collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n    rect.height = y - startY;\n    return {\n      layoutInfo: layoutInfo,\n      children: children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node: node\n    };\n  }\n  buildSectionHeader(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      let previousLayoutInfo = previousLayoutNode === null || previousLayoutNode === void 0 ? void 0 : previousLayoutNode.layoutInfo;\n      if (previousLayoutInfo) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n      } else {\n        rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n        isEstimated = true;\n      }\n    }\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    let headerRect = new (0, $img26$Rect)(0, y, width, rectHeight);\n    let header = new (0, $img26$LayoutInfo)('header', node.key, headerRect);\n    header.estimatedSize = isEstimated;\n    return {\n      layoutInfo: header,\n      children: [],\n      validRect: header.rect.intersection(this.requestedRect),\n      node: node\n    };\n  }\n  buildItem(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n    if (rectHeight == null) rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;\n    let rect = new (0, $img26$Rect)(x, y, width - x, rectHeight);\n    let layoutInfo = new (0, $img26$LayoutInfo)(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo: layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node: node\n    };\n  }\n  updateItemSize(key, size) {\n    let layoutNode = this.layoutNodes.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutNode) return false;\n    let layoutInfo = layoutNode.layoutInfo;\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      layoutNode.layoutInfo = newLayoutInfo;\n      // Items after this layoutInfo will need to be repositioned to account for the new height.\n      // Adjust the validRect so that only items above remain valid.\n      this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n      // The requestedRect also needs to be adjusted to account for the height difference.\n      this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n      return true;\n    }\n    return false;\n  }\n  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by intersecting the validRect of this node with the overall validRect.\n      n.validRect = n.validRect.intersection(this.validRect);\n      // Replace layout info in LayoutNode\n      if (n.layoutInfo === oldLayoutInfo) n.layoutInfo = newLayoutInfo;\n    }\n  }\n  getContentSize() {\n    return this.contentSize;\n  }\n  getDropTargetFromPoint(x, y, isValidDropTarget) {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n    let key = this.virtualizer.keyAtPoint(new (0, $img26$Point)(x, y));\n    if (key == null || this.collection.size === 0) return {\n      type: 'root'\n    };\n    let layoutInfo = this.getLayoutInfo(key);\n    let rect = layoutInfo.rect;\n    let target = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({\n        ...target,\n        dropPosition: 'before'\n      })) target.dropPosition = 'before';else if (isValidDropTarget({\n        ...target,\n        dropPosition: 'after'\n      })) target.dropPosition = 'after';\n    } else if (y <= rect.y + 10 && isValidDropTarget({\n      ...target,\n      dropPosition: 'before'\n    })) target.dropPosition = 'before';else if (y >= rect.maxY - 10 && isValidDropTarget({\n      ...target,\n      dropPosition: 'after'\n    })) target.dropPosition = 'after';\n    return target;\n  }\n  getDropTargetLayoutInfo(target) {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect;\n    if (target.dropPosition === 'before') rect = new (0, $img26$Rect)(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);else if (target.dropPosition === 'after') rect = new (0, $img26$Rect)(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);else rect = layoutInfo.rect;\n    return new (0, $img26$LayoutInfo)('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n  /**\n  * Creates a new ListLayout with options. See the list of properties below for a description\n  * of the options that can be provided.\n  */\n  constructor(options = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.loaderHeight = options.loaderHeight;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.validRect = new (0, $img26$Rect)();\n    this.requestedRect = new (0, $img26$Rect)();\n    this.contentSize = new (0, $img26$Size)();\n  }\n}\nexport { $61ef60fc9b1041f4$export$cacbb3924155d68e as ListLayout };","map":{"version":3,"names":["$61ef60fc9b1041f4$var$DEFAULT_HEIGHT","$61ef60fc9b1041f4$export$cacbb3924155d68e","$img26$Layout","getLayoutInfo","key","_this_layoutNodes_get","ensureLayoutInfo","layoutNodes","get","layoutInfo","getVisibleLayoutInfos","rect","height","_this_rowHeight","rowHeight","estimatedRowHeight","y","Math","floor","ceil","layoutIfNeeded","res","addNodes","nodes","node","isVisible","push","children","rootNodes","lastCollection","requestedRect","containsRect","union","buildCollection","virtualizer","persistedKeys","has","area","contentSize","$img26$Rect","Infinity","width","intersects","isSticky","type","isPersistedKey","shouldInvalidateEverything","invalidationContext","sizeChanged","update","collection","invalidateEverything","visibleRect","copy","clear","getKeys","getItem","layoutNode","delete","lastWidth","validRect","skipped","isValid","buildChild","maxY","size","length","$img26$Size","cached","intersection","x","parentKey","buildNode","set","buildSection","buildItem","buildSectionHeader","buildLoader","$img26$LayoutInfo","loaderHeight","startY","child","$img26$getChildNodes","rectHeight","headingHeight","isEstimated","previousLayoutNode","previousLayoutInfo","curNode","lastNode","estimatedSize","rendered","estimatedHeadingHeight","headerRect","header","updateItemSize","newLayoutInfo","min","updateLayoutNode","oldLayoutInfo","n","getContentSize","getDropTargetFromPoint","isValidDropTarget","keyAtPoint","$img26$Point","target","dropPosition","getDropTargetLayoutInfo","dropIndicatorThickness","constructor","options","Map"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/layout/dist/packages/@react-stately/layout/src/ListLayout.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DropTarget, DropTargetDelegate, ItemDropTarget, Key, Node} from '@react-types/shared';\nimport {getChildNodes} from '@react-stately/collections';\nimport {InvalidationContext, Layout, LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface ListLayoutOptions {\n  /** The fixed height of a row in px. */\n  rowHeight?: number,\n  /** The estimated height of a row, when row heights are variable. */\n  estimatedRowHeight?: number,\n  /** The fixed height of a section header in px. */\n  headingHeight?: number,\n  /** The estimated height of a section header, when the height is variable. */\n  estimatedHeadingHeight?: number,\n  /** The fixed height of a loader element in px. This loader is specifically for\n   * \"load more\" elements rendered when loading more rows at the root level or inside nested row/sections.\n   */\n  loaderHeight?: number,\n  /** The thickness of the drop indicator. */\n  dropIndicatorThickness?: number\n}\n\n// A wrapper around LayoutInfo that supports hierarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  children?: LayoutNode[],\n  validRect: Rect,\n  index?: number\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a virtualizer {@link Layout}.\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing virtualizer\n * delegate with an additional method to do this (it uses the same delegate object as\n * the virtualizer itself).\n */\nexport class ListLayout<T, O = any> extends Layout<Node<T>, O> implements DropTargetDelegate {\n  protected rowHeight: number;\n  protected estimatedRowHeight: number;\n  protected headingHeight: number;\n  protected estimatedHeadingHeight: number;\n  protected loaderHeight: number;\n  protected dropIndicatorThickness: number;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  protected collection: Collection<Node<T>>;\n  private lastCollection: Collection<Node<T>>;\n  private lastWidth: number;\n  protected rootNodes: LayoutNode[];\n  private invalidateEverything: boolean;\n  /** The rectangle containing currently valid layout infos. */\n  protected validRect: Rect;\n  /** The rectangle of requested layout infos so far. */\n  protected requestedRect: Rect;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.loaderHeight = options.loaderHeight;\n    this.dropIndicatorThickness = options.dropIndicatorThickness || 2;\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n    this.validRect = new Rect();\n    this.requestedRect = new Rect();\n    this.contentSize = new Size();\n  }\n\n  getLayoutInfo(key: Key) {\n    this.ensureLayoutInfo(key);\n    return this.layoutNodes.get(key)?.layoutInfo || null;\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    // Adjust rect to keep number of visible rows consistent.\n    // (only if height > 1 for getDropTargetFromPoint)\n    if (rect.height > 1) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n      rect.y = Math.floor(rect.y / rowHeight) * rowHeight;\n      rect.height = Math.ceil(rect.height / rowHeight) * rowHeight;\n    }\n\n    // If layout hasn't yet been done for the requested rect, union the\n    // new rect with the existing valid rect, and recompute.\n    this.layoutIfNeeded(rect);\n\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  protected layoutIfNeeded(rect: Rect) {\n    if (!this.lastCollection) {\n      return;\n    }\n\n    if (!this.requestedRect.containsRect(rect)) {\n      this.requestedRect = this.requestedRect.union(rect);\n      this.rootNodes = this.buildCollection();\n    }\n    \n    // Ensure all of the persisted keys are available.\n    for (let key of this.virtualizer.persistedKeys) {\n      if (this.ensureLayoutInfo(key)) {\n        return;\n      }\n    }\n  }\n\n  private ensureLayoutInfo(key: Key) {\n    // If the layout info wasn't found, it might be outside the bounds of the area that we've\n    // computed layout for so far. This can happen when accessing a random key, e.g pressing Home/End.\n    // Compute the full layout and try again.\n    if (!this.layoutNodes.has(key) && this.requestedRect.area < this.contentSize.area && this.lastCollection) {\n      this.requestedRect = new Rect(0, 0, Infinity, Infinity);\n      this.rootNodes = this.buildCollection();\n      this.requestedRect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n      return true;\n    }\n\n    return false;\n  }\n\n  protected isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky || node.layoutInfo.type === 'header' || this.virtualizer.isPersistedKey(node.layoutInfo.key);\n  }\n\n  protected shouldInvalidateEverything(invalidationContext: InvalidationContext<O>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    return invalidationContext.sizeChanged;\n  }\n\n  update(invalidationContext: InvalidationContext<O>) {\n    this.collection = this.virtualizer.collection;\n\n    // Reset valid rect if we will have to invalidate everything.\n    // Otherwise we can reuse cached layout infos outside the current visible rect.\n    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);\n    if (this.invalidateEverything) {\n      this.requestedRect = this.virtualizer.visibleRect.copy();\n      this.layoutNodes.clear();\n    }\n\n    this.rootNodes = this.buildCollection();\n\n    // Remove deleted layout nodes\n    if (this.lastCollection && this.collection !== this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!this.collection.getItem(key)) {\n          let layoutNode = this.layoutNodes.get(key);\n          if (layoutNode) {\n            this.layoutNodes.delete(key);\n          }\n        }\n      }\n    }\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n    this.invalidateEverything = false;\n    this.validRect = this.requestedRect.copy();\n  }\n\n  protected buildCollection(y = 0): LayoutNode[] {\n    let skipped = 0;\n    let nodes = [];\n    for (let node of this.collection) {\n      let rowHeight = this.rowHeight ?? this.estimatedRowHeight;\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (node.type === 'item' && y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(node, 0, y, null);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n\n      if (node.type === 'item' && y > this.requestedRect.maxY) {\n        y += (this.collection.size - (nodes.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y);\n    return nodes;\n  }\n\n  protected isValid(node: Node<T>, y: number) {\n    let cached = this.layoutNodes.get(node.key);\n    return (\n      !this.invalidateEverything &&\n      cached &&\n      cached.node === node &&\n      y === cached.layoutInfo.rect.y &&\n      cached.layoutInfo.rect.intersects(this.validRect) &&\n      cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.requestedRect))\n    );\n  }\n\n  protected buildChild(node: Node<T>, x: number, y: number, parentKey: Key | null): LayoutNode {\n    if (this.isValid(node, y)) {\n      return this.layoutNodes.get(node.key);\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n\n    layoutNode.layoutInfo.parentKey = parentKey ?? null;\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  protected buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n      case 'header':\n        return this.buildSectionHeader(node, x, y);\n      case 'loader':\n        return this.buildLoader(node, x, y);\n    }\n  }\n\n  protected buildLoader(node: Node<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('loader', node.key, rect);\n    rect.width = this.virtualizer.contentSize.width;\n    rect.height = this.loaderHeight || this.rowHeight || this.estimatedRowHeight;\n\n    return {\n      layoutInfo,\n      validRect: rect.intersection(this.requestedRect)\n    };\n  }\n\n  protected buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let skipped = 0;\n    let children = [];\n    for (let child of getChildNodes(node, this.collection)) {\n      let rowHeight = (this.rowHeight ?? this.estimatedRowHeight);\n\n      // Skip rows before the valid rectangle unless they are already cached.\n      if (y + rowHeight < this.requestedRect.y && !this.isValid(node, y)) {\n        y += rowHeight;\n        skipped++;\n        continue;\n      }\n\n      let layoutNode = this.buildChild(child, x, y, layoutInfo.key);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n\n      if (y > this.requestedRect.maxY) {\n        // Estimate the remaining height for rows that we don't need to layout right now.\n        y += ([...getChildNodes(node, this.collection)].length - (children.length + skipped)) * rowHeight;\n        break;\n      }\n    }\n\n    rect.height = y - startY;\n\n    return {\n      layoutInfo,\n      children,\n      validRect: layoutInfo.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildSectionHeader(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      let previousLayoutInfo = previousLayoutNode?.layoutInfo;\n      if (previousLayoutInfo) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutInfo.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key, headerRect);\n    header.estimatedSize = isEstimated;\n    return {\n      layoutInfo: header,\n      children: [],\n      validRect: header.rect.intersection(this.requestedRect),\n      node\n    };\n  }\n\n  protected buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall virtualizer changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || node !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo,\n      children: [],\n      validRect: layoutInfo.rect,\n      node\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutNode = this.layoutNodes.get(key);\n    // If no layoutInfo, item has been deleted/removed.\n    if (!layoutNode) {\n      return false;\n    }\n\n    let layoutInfo = layoutNode.layoutInfo;\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      layoutNode.layoutInfo = newLayoutInfo;\n\n      // Items after this layoutInfo will need to be repositioned to account for the new height.\n      // Adjust the validRect so that only items above remain valid.\n      this.validRect.height = Math.min(this.validRect.height, layoutInfo.rect.y - this.validRect.y);\n\n      // The requestedRect also needs to be adjusted to account for the height difference.\n      this.requestedRect.height += newLayoutInfo.rect.height - layoutInfo.rect.height;\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by intersecting the validRect of this node with the overall validRect.\n      n.validRect = n.validRect.intersection(this.validRect);\n\n      // Replace layout info in LayoutNode\n      if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    x += this.virtualizer.visibleRect.x;\n    y += this.virtualizer.visibleRect.y;\n\n    let key = this.virtualizer.keyAtPoint(new Point(x, y));\n    if (key == null || this.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let layoutInfo = this.getLayoutInfo(key);\n    let rect = layoutInfo.rect;\n    let target: DropTarget = {\n      type: 'item',\n      key: layoutInfo.key,\n      dropPosition: 'on'\n    };\n\n    // If dropping on the item isn't accepted, try the target before or after depending on the y position.\n    // Otherwise, if dropping on the item is accepted, still try the before/after positions if within 10px\n    // of the top or bottom of the item.\n    if (!isValidDropTarget(target)) {\n      if (y <= rect.y + rect.height / 2 && isValidDropTarget({...target, dropPosition: 'before'})) {\n        target.dropPosition = 'before';\n      } else if (isValidDropTarget({...target, dropPosition: 'after'})) {\n        target.dropPosition = 'after';\n      }\n    } else if (y <= rect.y + 10 && isValidDropTarget({...target, dropPosition: 'before'})) {\n      target.dropPosition = 'before';\n    } else if (y >= rect.maxY - 10 && isValidDropTarget({...target, dropPosition: 'after'})) {\n      target.dropPosition = 'after';\n    }\n\n    return target;\n  }\n\n  getDropTargetLayoutInfo(target: ItemDropTarget): LayoutInfo {\n    let layoutInfo = this.getLayoutInfo(target.key);\n    let rect: Rect;\n    if (target.dropPosition === 'before') {\n      rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.y - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else if (target.dropPosition === 'after') {\n      rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.maxY - this.dropIndicatorThickness / 2, layoutInfo.rect.width, this.dropIndicatorThickness);\n    } else {\n      rect = layoutInfo.rect;\n    }\n\n    return new LayoutInfo('dropIndicator', target.key + ':' + target.dropPosition, rect);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}