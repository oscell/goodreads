{"ast":null,"code":"import { getScrollLeft as $ce415dc67314b753$export$1389d168952b34b5 } from \"./utils.mjs\";\nimport { flushSync as $f9kpT$flushSync } from \"react-dom\";\nimport $f9kpT$react, { useRef as $f9kpT$useRef, useState as $f9kpT$useState, useCallback as $f9kpT$useCallback, useEffect as $f9kpT$useEffect } from \"react\";\nimport { Rect as $f9kpT$Rect } from \"@react-stately/virtualizer\";\nimport { useObjectRef as $f9kpT$useObjectRef, useEvent as $f9kpT$useEvent, useEffectEvent as $f9kpT$useEffectEvent, useLayoutEffect as $f9kpT$useLayoutEffect, useResizeObserver as $f9kpT$useResizeObserver } from \"@react-aria/utils\";\nimport { useLocale as $f9kpT$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // @ts-ignore\n\nfunction $44a6ee657928b002$var$ScrollView(props, ref) {\n  ref = (0, $f9kpT$useObjectRef)(ref);\n  let {\n    scrollViewProps: scrollViewProps,\n    contentProps: contentProps\n  } = $44a6ee657928b002$export$2ea0c4974da4731b(props, ref);\n  return /*#__PURE__*/(0, $f9kpT$react).createElement(\"div\", {\n    role: \"presentation\",\n    ...scrollViewProps,\n    ref: ref\n  }, /*#__PURE__*/(0, $f9kpT$react).createElement(\"div\", {\n    role: \"presentation\",\n    ...contentProps\n  }, props.children));\n}\nconst $44a6ee657928b002$export$5665e3d6be6adea = /*#__PURE__*/(0, $f9kpT$react).forwardRef($44a6ee657928b002$var$ScrollView);\nfunction $44a6ee657928b002$export$2ea0c4974da4731b(props, ref) {\n  let {\n    contentSize: contentSize,\n    onVisibleRectChange: onVisibleRectChange,\n    innerStyle: innerStyle,\n    onScrollStart: onScrollStart,\n    onScrollEnd: onScrollEnd,\n    scrollDirection = 'both',\n    ...otherProps\n  } = props;\n  let state = (0, $f9kpT$useRef)({\n    scrollTop: 0,\n    scrollLeft: 0,\n    scrollEndTime: 0,\n    scrollTimeout: null,\n    width: 0,\n    height: 0,\n    isScrolling: false\n  }).current;\n  let {\n    direction: direction\n  } = (0, $f9kpT$useLocale)();\n  let [isScrolling, setScrolling] = (0, $f9kpT$useState)(false);\n  let onScroll = (0, $f9kpT$useCallback)(e => {\n    if (e.target !== e.currentTarget) return;\n    if (props.onScroll) props.onScroll(e);\n    (0, $f9kpT$flushSync)(() => {\n      let scrollTop = e.currentTarget.scrollTop;\n      let scrollLeft = (0, $ce415dc67314b753$export$1389d168952b34b5)(e.currentTarget, direction);\n      // Prevent rubber band scrolling from shaking when scrolling out of bounds\n      state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));\n      state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));\n      onVisibleRectChange(new (0, $f9kpT$Rect)(state.scrollLeft, state.scrollTop, state.width, state.height));\n      if (!state.isScrolling) {\n        state.isScrolling = true;\n        setScrolling(true);\n        // Pause typekit MutationObserver during scrolling.\n        window.dispatchEvent(new Event('tk.disconnect-observer'));\n        if (onScrollStart) onScrollStart();\n      }\n      // So we don't constantly call clearTimeout and setTimeout,\n      // keep track of the current timeout time and only reschedule\n      // the timer when it is getting close.\n      let now = Date.now();\n      if (state.scrollEndTime <= now + 50) {\n        state.scrollEndTime = now + 300;\n        clearTimeout(state.scrollTimeout);\n        state.scrollTimeout = setTimeout(() => {\n          state.isScrolling = false;\n          setScrolling(false);\n          state.scrollTimeout = null;\n          window.dispatchEvent(new Event('tk.connect-observer'));\n          if (onScrollEnd) onScrollEnd();\n        }, 300);\n      }\n    });\n  }, [props, direction, state, contentSize, onVisibleRectChange, onScrollStart, onScrollEnd]);\n  // Attach event directly to ref so RAC Virtualizer doesn't need to send props upward.\n  (0, $f9kpT$useEvent)(ref, 'scroll', onScroll);\n  // eslint-disable-next-line arrow-body-style\n  (0, $f9kpT$useEffect)(() => {\n    return () => {\n      clearTimeout(state.scrollTimeout);\n      if (state.isScrolling) window.dispatchEvent(new Event('tk.connect-observer'));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let isUpdatingSize = (0, $f9kpT$useRef)(false);\n  let updateSize = (0, $f9kpT$useEffectEvent)(flush => {\n    let dom = ref.current;\n    if (!dom && !isUpdatingSize.current) return;\n    // Prevent reentrancy when resize observer fires, triggers re-layout that results in\n    // content size update, causing below layout effect to fire. This avoids infinite loops.\n    isUpdatingSize.current = true;\n    let isTestEnv = false;\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n    let clientWidth = dom.clientWidth;\n    let clientHeight = dom.clientHeight;\n    let w = isTestEnv && !isClientWidthMocked ? Infinity : clientWidth;\n    let h = isTestEnv && !isClientHeightMocked ? Infinity : clientHeight;\n    if (state.width !== w || state.height !== h) {\n      state.width = w;\n      state.height = h;\n      flush(() => {\n        onVisibleRectChange(new (0, $f9kpT$Rect)(state.scrollLeft, state.scrollTop, w, h));\n      });\n      // If the clientWidth or clientHeight changed, scrollbars appeared or disappeared as\n      // a result of the layout update. In this case, re-layout again to account for the\n      // adjusted space. In very specific cases this might result in the scrollbars disappearing\n      // again, resulting in extra padding. We stop after a maximum of two layout passes to avoid\n      // an infinite loop. This matches how browsers behavior with native CSS grid layout.\n      if (!isTestEnv && clientWidth !== dom.clientWidth || clientHeight !== dom.clientHeight) {\n        state.width = dom.clientWidth;\n        state.height = dom.clientHeight;\n        flush(() => {\n          onVisibleRectChange(new (0, $f9kpT$Rect)(state.scrollLeft, state.scrollTop, state.width, state.height));\n        });\n      }\n    }\n    isUpdatingSize.current = false;\n  });\n  // Update visible rect when the content size changes, in case scrollbars need to appear or disappear.\n  let lastContentSize = (0, $f9kpT$useRef)(null);\n  (0, $f9kpT$useLayoutEffect)(() => {\n    if (!isUpdatingSize.current && (lastContentSize.current == null || !contentSize.equals(lastContentSize.current))) {\n      // React doesn't allow flushSync inside effects, so queue a microtask.\n      // We also need to wait until all refs are set (e.g. when passing a ref down from a parent).\n      // If we are in an `act` environment, update immediately without a microtask so you don't need\n      // to mock timers in tests. In this case, the update is synchronous already.\n      // IS_REACT_ACT_ENVIRONMENT is used by React 18. Previous versions checked for the `jest` global.\n      // https://github.com/reactwg/react-18/discussions/102\n      // @ts-ignore\n      if (typeof IS_REACT_ACT_ENVIRONMENT === 'boolean' ? IS_REACT_ACT_ENVIRONMENT : typeof jest !== 'undefined') updateSize(fn => fn());else queueMicrotask(() => updateSize((0, $f9kpT$flushSync)));\n    }\n    lastContentSize.current = contentSize;\n  });\n  let onResize = (0, $f9kpT$useCallback)(() => {\n    updateSize((0, $f9kpT$flushSync));\n  }, [updateSize]);\n  // Watch border-box instead of of content-box so that we don't go into\n  // an infinite loop when scrollbars appear or disappear.\n  (0, $f9kpT$useResizeObserver)({\n    ref: ref,\n    box: 'border-box',\n    onResize: onResize\n  });\n  let style = {\n    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.\n    padding: 0,\n    ...otherProps.style\n  };\n  if (scrollDirection === 'horizontal') {\n    style.overflowX = 'auto';\n    style.overflowY = 'hidden';\n  } else if (scrollDirection === 'vertical' || contentSize.width === state.width) {\n    // Set overflow-x: hidden if content size is equal to the width of the scroll view.\n    // This prevents horizontal scrollbars from flickering during resizing due to resize observer\n    // firing slower than the frame rate, which may cause an infinite re-render loop.\n    style.overflowY = 'auto';\n    style.overflowX = 'hidden';\n  } else style.overflow = 'auto';\n  innerStyle = {\n    width: Number.isFinite(contentSize.width) ? contentSize.width : undefined,\n    height: Number.isFinite(contentSize.height) ? contentSize.height : undefined,\n    pointerEvents: isScrolling ? 'none' : 'auto',\n    position: 'relative',\n    ...innerStyle\n  };\n  return {\n    scrollViewProps: {\n      ...otherProps,\n      style: style\n    },\n    contentProps: {\n      role: 'presentation',\n      style: innerStyle\n    }\n  };\n}\nexport { $44a6ee657928b002$export$2ea0c4974da4731b as useScrollView, $44a6ee657928b002$export$5665e3d6be6adea as ScrollView };","map":{"version":3,"names":["$44a6ee657928b002$var$ScrollView","props","ref","$f9kpT$useObjectRef","scrollViewProps","contentProps","$44a6ee657928b002$export$2ea0c4974da4731b","$f9kpT$react","createElement","role","children","$44a6ee657928b002$export$5665e3d6be6adea","forwardRef","contentSize","onVisibleRectChange","innerStyle","onScrollStart","onScrollEnd","scrollDirection","otherProps","state","$f9kpT$useRef","scrollTop","scrollLeft","scrollEndTime","scrollTimeout","width","height","isScrolling","current","direction","$f9kpT$useLocale","setScrolling","$f9kpT$useState","onScroll","$f9kpT$useCallback","e","target","currentTarget","$f9kpT$flushSync","$ce415dc67314b753$export$1389d168952b34b5","Math","max","min","$f9kpT$Rect","window","dispatchEvent","Event","now","Date","clearTimeout","setTimeout","$f9kpT$useEvent","$f9kpT$useEffect","isUpdatingSize","updateSize","$f9kpT$useEffectEvent","flush","dom","isTestEnv","isClientWidthMocked","Object","getOwnPropertyNames","HTMLElement","prototype","includes","isClientHeightMocked","clientWidth","clientHeight","w","Infinity","h","lastContentSize","$f9kpT$useLayoutEffect","equals","IS_REACT_ACT_ENVIRONMENT","jest","fn","queueMicrotask","onResize","$f9kpT$useResizeObserver","box","style","padding","overflowX","overflowY","overflow","Number","isFinite","undefined","pointerEvents","position"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-aria/virtualizer/dist/packages/@react-aria/virtualizer/src/ScrollView.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// @ts-ignore\nimport {flushSync} from 'react-dom';\nimport {getScrollLeft} from './utils';\nimport React, {\n  CSSProperties,\n  ForwardedRef,\n  HTMLAttributes,\n  ReactNode,\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState\n} from 'react';\nimport {Rect, Size} from '@react-stately/virtualizer';\nimport {useEffectEvent, useEvent, useLayoutEffect, useObjectRef, useResizeObserver} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface ScrollViewProps extends HTMLAttributes<HTMLElement> {\n  contentSize: Size,\n  onVisibleRectChange: (rect: Rect) => void,\n  children?: ReactNode,\n  innerStyle?: CSSProperties,\n  onScrollStart?: () => void,\n  onScrollEnd?: () => void,\n  scrollDirection?: 'horizontal' | 'vertical' | 'both'\n}\n\nfunction ScrollView(props: ScrollViewProps, ref: ForwardedRef<HTMLDivElement | null>) {\n  ref = useObjectRef(ref);\n  let {scrollViewProps, contentProps} = useScrollView(props, ref);\n\n  return (\n    <div role=\"presentation\" {...scrollViewProps} ref={ref}>\n      <div role=\"presentation\" {...contentProps}>\n        {props.children}\n      </div>\n    </div>\n  );\n}\n\nconst ScrollViewForwardRef = React.forwardRef(ScrollView);\nexport {ScrollViewForwardRef as ScrollView};\n\nexport function useScrollView(props: ScrollViewProps, ref: RefObject<HTMLElement | null>) {\n  let {\n    contentSize,\n    onVisibleRectChange,\n    innerStyle,\n    onScrollStart,\n    onScrollEnd,\n    scrollDirection = 'both',\n    ...otherProps\n  } = props;\n\n  let state = useRef({\n    scrollTop: 0,\n    scrollLeft: 0,\n    scrollEndTime: 0,\n    scrollTimeout: null,\n    width: 0,\n    height: 0,\n    isScrolling: false\n  }).current;\n  let {direction} = useLocale();\n\n  let [isScrolling, setScrolling] = useState(false);\n  let onScroll = useCallback((e) => {\n    if (e.target !== e.currentTarget) {\n      return;\n    }\n\n    if (props.onScroll) {\n      props.onScroll(e);\n    }\n\n    flushSync(() => {\n      let scrollTop = e.currentTarget.scrollTop;\n      let scrollLeft = getScrollLeft(e.currentTarget, direction);\n\n      // Prevent rubber band scrolling from shaking when scrolling out of bounds\n      state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));\n      state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));\n\n      onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, state.width, state.height));\n\n      if (!state.isScrolling) {\n        state.isScrolling = true;\n        setScrolling(true);\n\n        // Pause typekit MutationObserver during scrolling.\n        window.dispatchEvent(new Event('tk.disconnect-observer'));\n        if (onScrollStart) {\n          onScrollStart();\n        }\n      }\n\n      // So we don't constantly call clearTimeout and setTimeout,\n      // keep track of the current timeout time and only reschedule\n      // the timer when it is getting close.\n      let now = Date.now();\n      if (state.scrollEndTime <= now + 50) {\n        state.scrollEndTime = now + 300;\n\n        clearTimeout(state.scrollTimeout);\n        state.scrollTimeout = setTimeout(() => {\n          state.isScrolling = false;\n          setScrolling(false);\n          state.scrollTimeout = null;\n\n          window.dispatchEvent(new Event('tk.connect-observer'));\n          if (onScrollEnd) {\n            onScrollEnd();\n          }\n        }, 300);\n      }\n    });\n  }, [props, direction, state, contentSize, onVisibleRectChange, onScrollStart, onScrollEnd]);\n\n  // Attach event directly to ref so RAC Virtualizer doesn't need to send props upward.\n  useEvent(ref, 'scroll', onScroll);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      clearTimeout(state.scrollTimeout);\n      if (state.isScrolling) {\n        window.dispatchEvent(new Event('tk.connect-observer'));\n      }\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let isUpdatingSize = useRef(false);\n  let updateSize = useEffectEvent((flush: typeof flushSync) => {\n    let dom = ref.current;\n    if (!dom && !isUpdatingSize.current) {\n      return;\n    }\n\n    // Prevent reentrancy when resize observer fires, triggers re-layout that results in\n    // content size update, causing below layout effect to fire. This avoids infinite loops.\n    isUpdatingSize.current = true;\n\n    let isTestEnv = process.env.NODE_ENV === 'test' && !process.env.VIRT_ON;\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n    let clientWidth = dom.clientWidth;\n    let clientHeight = dom.clientHeight;\n    let w = isTestEnv && !isClientWidthMocked ? Infinity : clientWidth;\n    let h = isTestEnv && !isClientHeightMocked ? Infinity : clientHeight;\n\n    if (state.width !== w || state.height !== h) {\n      state.width = w;\n      state.height = h;\n      flush(() => {\n        onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, w, h));\n      });\n\n      // If the clientWidth or clientHeight changed, scrollbars appeared or disappeared as\n      // a result of the layout update. In this case, re-layout again to account for the\n      // adjusted space. In very specific cases this might result in the scrollbars disappearing\n      // again, resulting in extra padding. We stop after a maximum of two layout passes to avoid\n      // an infinite loop. This matches how browsers behavior with native CSS grid layout.\n      if (!isTestEnv && clientWidth !== dom.clientWidth || clientHeight !== dom.clientHeight) {\n        state.width = dom.clientWidth;\n        state.height = dom.clientHeight;\n        flush(() => {\n          onVisibleRectChange(new Rect(state.scrollLeft, state.scrollTop, state.width, state.height));\n        });\n      }\n    }\n\n    isUpdatingSize.current = false;\n  });\n\n  // Update visible rect when the content size changes, in case scrollbars need to appear or disappear.\n  let lastContentSize = useRef<Size | null>(null);\n  useLayoutEffect(() => {\n    if (!isUpdatingSize.current && (lastContentSize.current == null || !contentSize.equals(lastContentSize.current))) {\n      // React doesn't allow flushSync inside effects, so queue a microtask.\n      // We also need to wait until all refs are set (e.g. when passing a ref down from a parent).\n      // If we are in an `act` environment, update immediately without a microtask so you don't need\n      // to mock timers in tests. In this case, the update is synchronous already.\n      // IS_REACT_ACT_ENVIRONMENT is used by React 18. Previous versions checked for the `jest` global.\n      // https://github.com/reactwg/react-18/discussions/102\n      // @ts-ignore\n      if (typeof IS_REACT_ACT_ENVIRONMENT === 'boolean' ? IS_REACT_ACT_ENVIRONMENT : typeof jest !== 'undefined') {\n        updateSize(fn => fn());\n      } else {\n        queueMicrotask(() => updateSize(flushSync));\n      }\n    }\n\n    lastContentSize.current = contentSize;\n  });\n\n  let onResize = useCallback(() => {\n    updateSize(flushSync);\n  }, [updateSize]);\n\n  // Watch border-box instead of of content-box so that we don't go into\n  // an infinite loop when scrollbars appear or disappear.\n  useResizeObserver({ref, box: 'border-box', onResize});\n\n  let style: React.CSSProperties = {\n    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.\n    padding: 0,\n    ...otherProps.style\n  };\n\n  if (scrollDirection === 'horizontal') {\n    style.overflowX = 'auto';\n    style.overflowY = 'hidden';\n  } else if (scrollDirection === 'vertical' || contentSize.width === state.width) {\n    // Set overflow-x: hidden if content size is equal to the width of the scroll view.\n    // This prevents horizontal scrollbars from flickering during resizing due to resize observer\n    // firing slower than the frame rate, which may cause an infinite re-render loop.\n    style.overflowY = 'auto';\n    style.overflowX = 'hidden';\n  } else {\n    style.overflow = 'auto';\n  }\n\n  innerStyle = {\n    width: Number.isFinite(contentSize.width) ? contentSize.width : undefined,\n    height: Number.isFinite(contentSize.height) ? contentSize.height : undefined,\n    pointerEvents: isScrolling ? 'none' : 'auto',\n    position: 'relative',\n    ...innerStyle\n  };\n\n  return {\n    scrollViewProps: {\n      ...otherProps,\n      style\n    },\n    contentProps: {\n      role: 'presentation',\n      style: innerStyle\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}