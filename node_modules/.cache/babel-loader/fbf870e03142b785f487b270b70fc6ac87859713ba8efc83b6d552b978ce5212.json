{"ast":null,"code":"import { CUSTOM_DRAG_TYPE as $103790afe9474d1c$export$fd9f9fc120c5402d, DROP_OPERATION as $103790afe9474d1c$export$60b7b4bcf3903d8e, GENERIC_TYPE as $103790afe9474d1c$export$f8fc6581787339b3, NATIVE_DRAG_TYPES as $103790afe9474d1c$export$4a7729b856e9a690 } from \"./constants.mjs\";\nimport { useInteractionModality as $j62BV$useInteractionModality, getInteractionModality as $j62BV$getInteractionModality } from \"@react-aria/interactions\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $7252cd45fc48c07c$export$dfdf5deeaf27473f = new WeakMap();\nconst $7252cd45fc48c07c$export$990fced5dfac2637 = Symbol();\nfunction $7252cd45fc48c07c$export$3093291712f09a77(state) {\n  let {\n    id: id\n  } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);\n  if (!id) throw new Error('Droppable item outside a droppable collection');\n  return id;\n}\nfunction $7252cd45fc48c07c$export$7e397efd01d3db27(state) {\n  let {\n    ref: ref\n  } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);\n  if (!ref) throw new Error('Droppable item outside a droppable collection');\n  return ref;\n}\nfunction $7252cd45fc48c07c$export$e1d41611756c6326(items) {\n  let types = new Set();\n  for (let item of items) for (let type of Object.keys(item)) types.add(type);\n  return types;\n}\nfunction $7252cd45fc48c07c$var$mapModality(modality) {\n  if (!modality) modality = 'virtual';\n  if (modality === 'pointer') modality = 'virtual';\n  if (modality === 'virtual' && typeof window !== 'undefined' && 'ontouchstart' in window) modality = 'touch';\n  return modality;\n}\nfunction $7252cd45fc48c07c$export$49bac5d6d4b352ea() {\n  return $7252cd45fc48c07c$var$mapModality((0, $j62BV$useInteractionModality)());\n}\nfunction $7252cd45fc48c07c$export$1fb2158d224b542c() {\n  return $7252cd45fc48c07c$var$mapModality((0, $j62BV$getInteractionModality)());\n}\nfunction $7252cd45fc48c07c$export$f9c1490890ddd063(dataTransfer, items) {\n  // The data transfer API doesn't support more than one item of a given type at once.\n  // In addition, only a small set of types are supported natively for transfer between applications.\n  // We allow for both multiple items, as well as multiple representations of a single item.\n  // In order to make our API work with the native API, we serialize all items to JSON and\n  // store as a single native item. We only need to do this if there is more than one item\n  // of the same type, or if an item has more than one representation. Otherwise the native\n  // API is sufficient.\n  //\n  // The DataTransferItemList API also theoretically supports adding files, which would enable\n  // dragging binary data out of the browser onto the user's desktop for example. Unfortunately,\n  // this does not currently work in any browser, so it is not currently supported by our API.\n  // See e.g. https://bugs.chromium.org/p/chromium/issues/detail?id=438479.\n  let groupedByType = new Map();\n  let needsCustomData = false;\n  let customData = [];\n  for (let item of items) {\n    let types = Object.keys(item);\n    if (types.length > 1) needsCustomData = true;\n    let dataByType = {};\n    for (let type of types) {\n      let typeItems = groupedByType.get(type);\n      if (!typeItems) {\n        typeItems = [];\n        groupedByType.set(type, typeItems);\n      } else needsCustomData = true;\n      let data = item[type];\n      dataByType[type] = data;\n      typeItems.push(data);\n    }\n    customData.push(dataByType);\n  }\n  for (let [type, items] of groupedByType) if ((0, $103790afe9474d1c$export$4a7729b856e9a690).has(type)) {\n    // Only one item of a given type can be set on a data transfer.\n    // Join all of the items together separated by newlines.\n    let data = items.join('\\n');\n    dataTransfer.items.add(data, type);\n  } else\n    // Set data to the first item so we have access to the list of types.\n    dataTransfer.items.add(items[0], type);\n  if (needsCustomData) {\n    let data = JSON.stringify(customData);\n    dataTransfer.items.add(data, (0, $103790afe9474d1c$export$fd9f9fc120c5402d));\n  }\n}\nclass $7252cd45fc48c07c$export$7f04ce188c91447c {\n  has(type) {\n    if (this.includesUnknownTypes || type === $7252cd45fc48c07c$export$990fced5dfac2637 && this.types.has((0, $103790afe9474d1c$export$f8fc6581787339b3))) return true;\n    return typeof type === 'string' && this.types.has(type);\n  }\n  constructor(dataTransfer) {\n    this.types = new Set();\n    let hasFiles = false;\n    for (let item of dataTransfer.items) if (item.type !== (0, $103790afe9474d1c$export$fd9f9fc120c5402d)) {\n      if (item.kind === 'file') hasFiles = true;\n      if (item.type) this.types.add(item.type);else\n        // Files with unknown types or extensions that don't map to a known mime type\n        // are sometimes exposed as an empty string by the browser. Map to a generic\n        // mime type instead. Note that this could also be a directory as there's no\n        // way to determine if something is a file or directory until drop.\n        this.types.add((0, $103790afe9474d1c$export$f8fc6581787339b3));\n    }\n    // In Safari, when dragging files, the dataTransfer.items list is empty, but dataTransfer.types contains \"Files\".\n    // Unfortunately, this doesn't tell us what types of files the user is dragging, so we need to assume that any\n    // type the user checks for is included. See https://bugs.webkit.org/show_bug.cgi?id=223517.\n    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes('Files');\n  }\n}\nfunction $7252cd45fc48c07c$export$d9e760437831f8b3(dataTransfer) {\n  let items = [];\n  // If our custom drag type is available, use that. This is a JSON serialized\n  // representation of all items in the drag, set when there are multiple items\n  // of the same type, or an individual item has multiple representations.\n  let hasCustomType = false;\n  if (dataTransfer.types.includes((0, $103790afe9474d1c$export$fd9f9fc120c5402d))) try {\n    let data = dataTransfer.getData((0, $103790afe9474d1c$export$fd9f9fc120c5402d));\n    let parsed = JSON.parse(data);\n    for (let item of parsed) items.push({\n      kind: 'text',\n      types: new Set(Object.keys(item)),\n      getText: type => Promise.resolve(item[type])\n    });\n    hasCustomType = true;\n  } catch (e) {\n    // ignore\n  }\n  // Otherwise, map native drag items to items of a single representation.\n  if (!hasCustomType) {\n    let stringItems = new Map();\n    for (let item of dataTransfer.items) {\n      if (item.kind === 'string')\n        // The data for all formats must be read here because the data transfer gets\n        // cleared out after the event handler finishes. If the item has an empty string\n        // as a type, the mime type is unknown. Map to a generic mime type instead.\n        stringItems.set(item.type || (0, $103790afe9474d1c$export$f8fc6581787339b3), dataTransfer.getData(item.type));else if (item.kind === 'file') {\n        // Despite the name, webkitGetAsEntry is also implemented in Firefox and Edge.\n        // In the future, we may use getAsFileSystemHandle instead, but that's currently\n        // only implemented in Chrome.\n        if (typeof item.webkitGetAsEntry === 'function') {\n          let entry = item.webkitGetAsEntry();\n          // eslint-disable-next-line max-depth\n          if (!entry) continue;\n          // eslint-disable-next-line max-depth\n          if (entry.isFile) items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));else if (entry.isDirectory) items.push($7252cd45fc48c07c$var$createDirectoryItem(entry));\n        } else\n          // Assume it's a file.\n          items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));\n      }\n    }\n    // All string items are different representations of the same item. There's no way to have\n    // multiple string items at once in the current DataTransfer API.\n    if (stringItems.size > 0) items.push({\n      kind: 'text',\n      types: new Set(stringItems.keys()),\n      getText: type => Promise.resolve(stringItems.get(type))\n    });\n  }\n  return items;\n}\nfunction $7252cd45fc48c07c$var$blobToString(blob) {\n  if (typeof blob.text === 'function') return blob.text();\n  // Safari doesn't have the Blob#text() method yet...\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n    reader.onload = () => {\n      resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(blob);\n  });\n}\nfunction $7252cd45fc48c07c$var$createFileItem(file) {\n  return {\n    kind: 'file',\n    type: file.type || (0, $103790afe9474d1c$export$f8fc6581787339b3),\n    name: file.name,\n    getText: () => $7252cd45fc48c07c$var$blobToString(file),\n    getFile: () => Promise.resolve(file)\n  };\n}\nfunction $7252cd45fc48c07c$var$createDirectoryItem(entry) {\n  return {\n    kind: 'directory',\n    name: entry.name,\n    getEntries: () => $7252cd45fc48c07c$var$getEntries(entry)\n  };\n}\nasync function* $7252cd45fc48c07c$var$getEntries(item) {\n  let reader = item.createReader();\n  // We must call readEntries repeatedly because there may be a limit to the\n  // number of entries that are returned at once.\n  let entries;\n  do {\n    entries = await new Promise((resolve, reject) => {\n      reader.readEntries(resolve, reject);\n    });\n    for (let entry of entries) {\n      if (entry.isFile) {\n        let file = await $7252cd45fc48c07c$var$getEntryFile(entry);\n        yield $7252cd45fc48c07c$var$createFileItem(file);\n      } else if (entry.isDirectory) yield $7252cd45fc48c07c$var$createDirectoryItem(entry);\n    }\n  } while (entries.length > 0);\n}\nfunction $7252cd45fc48c07c$var$getEntryFile(entry) {\n  return new Promise((resolve, reject) => entry.file(resolve, reject));\n}\nfunction $7252cd45fc48c07c$export$97fd558bdc44bea1(dropItem) {\n  return dropItem.kind === 'text';\n}\nfunction $7252cd45fc48c07c$export$a144e1752ebe0aa(dropItem) {\n  return dropItem.kind === 'file';\n}\nfunction $7252cd45fc48c07c$export$2b40a62bdbe6b2b0(dropItem) {\n  return dropItem.kind === 'directory';\n}\nlet $7252cd45fc48c07c$export$6ca6700462636d0b = {\n  draggingKeys: new Set()\n};\nfunction $7252cd45fc48c07c$export$f2be18a910c0caa6(ref) {\n  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingCollectionRef = ref;\n}\nfunction $7252cd45fc48c07c$export$72cb63bdda528276(keys) {\n  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingKeys = keys;\n}\nfunction $7252cd45fc48c07c$export$dac8db29d42db9a1(ref) {\n  $7252cd45fc48c07c$export$6ca6700462636d0b.dropCollectionRef = ref;\n}\nfunction $7252cd45fc48c07c$export$70936501603e6c57() {\n  $7252cd45fc48c07c$export$6ca6700462636d0b = {\n    draggingKeys: new Set()\n  };\n}\nfunction $7252cd45fc48c07c$export$6c10d32b362bfa5f(state) {\n  $7252cd45fc48c07c$export$6ca6700462636d0b = state;\n}\nfunction $7252cd45fc48c07c$export$78bf638634500fa5(ref) {\n  let {\n    draggingCollectionRef: draggingCollectionRef,\n    dropCollectionRef: dropCollectionRef\n  } = $7252cd45fc48c07c$export$6ca6700462636d0b;\n  return (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) != null && draggingCollectionRef.current === ((ref === null || ref === void 0 ? void 0 : ref.current) || (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current));\n}\nlet $7252cd45fc48c07c$export$8e6636520ac15722;\nfunction $7252cd45fc48c07c$export$64f52ed7349ddb84(dropEffect) {\n  $7252cd45fc48c07c$export$8e6636520ac15722 = dropEffect;\n}\nlet $7252cd45fc48c07c$export$f0130eb70b6347b8 = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;\nfunction $7252cd45fc48c07c$export$6539bc8c3a0a2d67(o) {\n  $7252cd45fc48c07c$export$f0130eb70b6347b8 = o;\n}\nexport { $7252cd45fc48c07c$export$dfdf5deeaf27473f as droppableCollectionMap, $7252cd45fc48c07c$export$990fced5dfac2637 as DIRECTORY_DRAG_TYPE, $7252cd45fc48c07c$export$3093291712f09a77 as getDroppableCollectionId, $7252cd45fc48c07c$export$7e397efd01d3db27 as getDroppableCollectionRef, $7252cd45fc48c07c$export$e1d41611756c6326 as getTypes, $7252cd45fc48c07c$export$49bac5d6d4b352ea as useDragModality, $7252cd45fc48c07c$export$1fb2158d224b542c as getDragModality, $7252cd45fc48c07c$export$f9c1490890ddd063 as writeToDataTransfer, $7252cd45fc48c07c$export$7f04ce188c91447c as DragTypes, $7252cd45fc48c07c$export$d9e760437831f8b3 as readFromDataTransfer, $7252cd45fc48c07c$export$97fd558bdc44bea1 as isTextDropItem, $7252cd45fc48c07c$export$a144e1752ebe0aa as isFileDropItem, $7252cd45fc48c07c$export$2b40a62bdbe6b2b0 as isDirectoryDropItem, $7252cd45fc48c07c$export$6ca6700462636d0b as globalDndState, $7252cd45fc48c07c$export$f2be18a910c0caa6 as setDraggingCollectionRef, $7252cd45fc48c07c$export$72cb63bdda528276 as setDraggingKeys, $7252cd45fc48c07c$export$dac8db29d42db9a1 as setDropCollectionRef, $7252cd45fc48c07c$export$70936501603e6c57 as clearGlobalDnDState, $7252cd45fc48c07c$export$6c10d32b362bfa5f as setGlobalDnDState, $7252cd45fc48c07c$export$78bf638634500fa5 as isInternalDropOperation, $7252cd45fc48c07c$export$8e6636520ac15722 as globalDropEffect, $7252cd45fc48c07c$export$64f52ed7349ddb84 as setGlobalDropEffect, $7252cd45fc48c07c$export$f0130eb70b6347b8 as globalAllowedDropOperations, $7252cd45fc48c07c$export$6539bc8c3a0a2d67 as setGlobalAllowedDropOperations };","map":{"version":3,"names":["$7252cd45fc48c07c$export$dfdf5deeaf27473f","WeakMap","$7252cd45fc48c07c$export$990fced5dfac2637","Symbol","$7252cd45fc48c07c$export$3093291712f09a77","state","id","get","Error","$7252cd45fc48c07c$export$7e397efd01d3db27","ref","$7252cd45fc48c07c$export$e1d41611756c6326","items","types","Set","item","type","Object","keys","add","$7252cd45fc48c07c$var$mapModality","modality","window","$7252cd45fc48c07c$export$49bac5d6d4b352ea","$j62BV$useInteractionModality","$7252cd45fc48c07c$export$1fb2158d224b542c","$j62BV$getInteractionModality","$7252cd45fc48c07c$export$f9c1490890ddd063","dataTransfer","groupedByType","Map","needsCustomData","customData","length","dataByType","typeItems","set","data","push","$103790afe9474d1c$export$4a7729b856e9a690","has","join","JSON","stringify","$103790afe9474d1c$export$fd9f9fc120c5402d","$7252cd45fc48c07c$export$7f04ce188c91447c","includesUnknownTypes","$103790afe9474d1c$export$f8fc6581787339b3","constructor","hasFiles","kind","includes","$7252cd45fc48c07c$export$d9e760437831f8b3","hasCustomType","getData","parsed","parse","getText","Promise","resolve","e","stringItems","webkitGetAsEntry","entry","isFile","$7252cd45fc48c07c$var$createFileItem","getAsFile","isDirectory","$7252cd45fc48c07c$var$createDirectoryItem","size","$7252cd45fc48c07c$var$blobToString","blob","text","reject","reader","FileReader","onload","result","onerror","readAsText","file","name","getFile","getEntries","$7252cd45fc48c07c$var$getEntries","createReader","entries","readEntries","$7252cd45fc48c07c$var$getEntryFile","$7252cd45fc48c07c$export$97fd558bdc44bea1","dropItem","$7252cd45fc48c07c$export$a144e1752ebe0aa","$7252cd45fc48c07c$export$2b40a62bdbe6b2b0","$7252cd45fc48c07c$export$6ca6700462636d0b","draggingKeys","$7252cd45fc48c07c$export$f2be18a910c0caa6","draggingCollectionRef","$7252cd45fc48c07c$export$72cb63bdda528276","$7252cd45fc48c07c$export$dac8db29d42db9a1","dropCollectionRef","$7252cd45fc48c07c$export$70936501603e6c57","$7252cd45fc48c07c$export$6c10d32b362bfa5f","$7252cd45fc48c07c$export$78bf638634500fa5","current","$7252cd45fc48c07c$export$8e6636520ac15722","$7252cd45fc48c07c$export$64f52ed7349ddb84","dropEffect","$7252cd45fc48c07c$export$f0130eb70b6347b8","$103790afe9474d1c$export$60b7b4bcf3903d8e","none","$7252cd45fc48c07c$export$6539bc8c3a0a2d67","o"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-aria/dnd/dist/packages/@react-aria/dnd/src/utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CUSTOM_DRAG_TYPE, DROP_OPERATION, GENERIC_TYPE, NATIVE_DRAG_TYPES} from './constants';\nimport {DirectoryDropItem, DragItem, DropItem, FileDropItem, DragTypes as IDragTypes, Key, RefObject, TextDropItem} from '@react-types/shared';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {getInteractionModality, useInteractionModality} from '@react-aria/interactions';\n\ninterface DroppableCollectionMap {\n  id: string,\n  ref: RefObject<HTMLElement | null>\n}\n\nexport const droppableCollectionMap = new WeakMap<DroppableCollectionState, DroppableCollectionMap>();\nexport const DIRECTORY_DRAG_TYPE = Symbol();\n\nexport function getDroppableCollectionId(state: DroppableCollectionState) {\n  let {id} = droppableCollectionMap.get(state);\n  if (!id) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return id;\n}\n\nexport function getDroppableCollectionRef(state: DroppableCollectionState) {\n  let {ref} = droppableCollectionMap.get(state);\n  if (!ref) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return ref;\n}\n\nexport function getTypes(items: DragItem[]): Set<string> {\n  let types = new Set<string>();\n  for (let item of items) {\n    for (let type of Object.keys(item)) {\n      types.add(type);\n    }\n  }\n\n  return types;\n}\n\nfunction mapModality(modality: string) {\n  if (!modality) {\n    modality = 'virtual';\n  }\n\n  if (modality === 'pointer') {\n    modality = 'virtual';\n  }\n\n  if (modality === 'virtual' &&  (typeof window !== 'undefined' && 'ontouchstart' in window)) {\n    modality = 'touch';\n  }\n\n  return modality;\n}\n\nexport function useDragModality() {\n  return mapModality(useInteractionModality());\n}\n\nexport function getDragModality() {\n  return mapModality(getInteractionModality());\n}\n\nexport function writeToDataTransfer(dataTransfer: DataTransfer, items: DragItem[]) {\n  // The data transfer API doesn't support more than one item of a given type at once.\n  // In addition, only a small set of types are supported natively for transfer between applications.\n  // We allow for both multiple items, as well as multiple representations of a single item.\n  // In order to make our API work with the native API, we serialize all items to JSON and\n  // store as a single native item. We only need to do this if there is more than one item\n  // of the same type, or if an item has more than one representation. Otherwise the native\n  // API is sufficient.\n  //\n  // The DataTransferItemList API also theoretically supports adding files, which would enable\n  // dragging binary data out of the browser onto the user's desktop for example. Unfortunately,\n  // this does not currently work in any browser, so it is not currently supported by our API.\n  // See e.g. https://bugs.chromium.org/p/chromium/issues/detail?id=438479.\n  let groupedByType = new Map<string, string[]>();\n  let needsCustomData = false;\n  let customData = [];\n  for (let item of items) {\n    let types = Object.keys(item);\n    if (types.length > 1) {\n      needsCustomData = true;\n    }\n\n    let dataByType = {};\n    for (let type of types) {\n      let typeItems = groupedByType.get(type);\n      if (!typeItems) {\n        typeItems = [];\n        groupedByType.set(type, typeItems);\n      } else {\n        needsCustomData = true;\n      }\n\n      let data = item[type];\n      dataByType[type] = data;\n      typeItems.push(data);\n    }\n\n    customData.push(dataByType);\n  }\n\n  for (let [type, items] of groupedByType) {\n    if (NATIVE_DRAG_TYPES.has(type)) {\n      // Only one item of a given type can be set on a data transfer.\n      // Join all of the items together separated by newlines.\n      let data = items.join('\\n');\n      dataTransfer.items.add(data, type);\n    } else {\n      // Set data to the first item so we have access to the list of types.\n      dataTransfer.items.add(items[0], type);\n    }\n  }\n\n  if (needsCustomData) {\n    let data = JSON.stringify(customData);\n    dataTransfer.items.add(data, CUSTOM_DRAG_TYPE);\n  }\n}\n\nexport class DragTypes implements IDragTypes {\n  private types: Set<string>;\n  private includesUnknownTypes: boolean;\n\n  constructor(dataTransfer: DataTransfer) {\n    this.types = new Set<string>();\n\n    let hasFiles = false;\n    for (let item of dataTransfer.items) {\n      if (item.type !== CUSTOM_DRAG_TYPE) {\n        if (item.kind === 'file') {\n          hasFiles = true;\n        }\n\n        if (item.type) {\n          this.types.add(item.type);\n        } else {\n          // Files with unknown types or extensions that don't map to a known mime type\n          // are sometimes exposed as an empty string by the browser. Map to a generic\n          // mime type instead. Note that this could also be a directory as there's no\n          // way to determine if something is a file or directory until drop.\n          this.types.add(GENERIC_TYPE);\n        }\n      }\n    }\n\n    // In Safari, when dragging files, the dataTransfer.items list is empty, but dataTransfer.types contains \"Files\".\n    // Unfortunately, this doesn't tell us what types of files the user is dragging, so we need to assume that any\n    // type the user checks for is included. See https://bugs.webkit.org/show_bug.cgi?id=223517.\n    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes('Files');\n  }\n\n  has(type: string | symbol) {\n    if (this.includesUnknownTypes || (type === DIRECTORY_DRAG_TYPE && this.types.has(GENERIC_TYPE))) {\n      return true;\n    }\n\n    return typeof type === 'string' && this.types.has(type);\n  }\n}\n\nexport function readFromDataTransfer(dataTransfer: DataTransfer) {\n  let items: DropItem[] = [];\n\n  // If our custom drag type is available, use that. This is a JSON serialized\n  // representation of all items in the drag, set when there are multiple items\n  // of the same type, or an individual item has multiple representations.\n  let hasCustomType = false;\n  if (dataTransfer.types.includes(CUSTOM_DRAG_TYPE)) {\n    try {\n      let data = dataTransfer.getData(CUSTOM_DRAG_TYPE);\n      let parsed = JSON.parse(data);\n      for (let item of parsed) {\n        items.push({\n          kind: 'text',\n          types: new Set(Object.keys(item)),\n          getText: (type) => Promise.resolve(item[type])\n        });\n      }\n\n      hasCustomType = true;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Otherwise, map native drag items to items of a single representation.\n  if (!hasCustomType) {\n    let stringItems = new Map();\n    for (let item of dataTransfer.items) {\n      if (item.kind === 'string') {\n        // The data for all formats must be read here because the data transfer gets\n        // cleared out after the event handler finishes. If the item has an empty string\n        // as a type, the mime type is unknown. Map to a generic mime type instead.\n        stringItems.set(item.type || GENERIC_TYPE, dataTransfer.getData(item.type));\n      } else if (item.kind === 'file') {\n        // Despite the name, webkitGetAsEntry is also implemented in Firefox and Edge.\n        // In the future, we may use getAsFileSystemHandle instead, but that's currently\n        // only implemented in Chrome.\n        if (typeof item.webkitGetAsEntry === 'function') {\n          let entry: FileSystemEntry = item.webkitGetAsEntry();\n          // eslint-disable-next-line max-depth\n          if (!entry) {\n            // For some reason, Firefox includes an item with type image/png when copy\n            // and pasting any file or directory (no matter the type), but returns `null` for both\n            // item.getAsFile() and item.webkitGetAsEntry(). Safari works as expected. Ignore this\n            // item if this happens. See https://bugzilla.mozilla.org/show_bug.cgi?id=1699743.\n            // This was recently fixed in Chrome Canary: https://bugs.chromium.org/p/chromium/issues/detail?id=1175483.\n            continue;\n          }\n\n          // eslint-disable-next-line max-depth\n          if (entry.isFile) {\n            items.push(createFileItem(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            items.push(createDirectoryItem(entry));\n          }\n        } else {\n          // Assume it's a file.\n          items.push(createFileItem(item.getAsFile()));\n        }\n      }\n    }\n\n    // All string items are different representations of the same item. There's no way to have\n    // multiple string items at once in the current DataTransfer API.\n    if (stringItems.size > 0) {\n      items.push({\n        kind: 'text',\n        types: new Set(stringItems.keys()),\n        getText: (type) => Promise.resolve(stringItems.get(type))\n      });\n    }\n  }\n\n  return items;\n}\n\nfunction blobToString(blob: Blob): Promise<string> {\n  if (typeof blob.text === 'function') {\n    return blob.text();\n  }\n\n  // Safari doesn't have the Blob#text() method yet...\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader;\n    reader.onload = () => {\n      resolve(reader.result as string);\n    };\n\n    reader.onerror = reject;\n    reader.readAsText(blob);\n  });\n}\n\nfunction createFileItem(file: File): FileDropItem {\n  return {\n    kind: 'file',\n    type: file.type || GENERIC_TYPE,\n    name: file.name,\n    getText: () => blobToString(file),\n    getFile: () => Promise.resolve(file)\n  };\n}\n\nfunction createDirectoryItem(entry: any): DirectoryDropItem {\n  return {\n    kind: 'directory',\n    name: entry.name,\n    getEntries: () => getEntries(entry)\n  };\n}\n\nasync function *getEntries(item: FileSystemDirectoryEntry): AsyncIterable<FileDropItem | DirectoryDropItem> {\n  let reader = item.createReader();\n\n  // We must call readEntries repeatedly because there may be a limit to the\n  // number of entries that are returned at once.\n  let entries: FileSystemEntry[];\n  do {\n    entries = await new Promise((resolve, reject) => {\n      reader.readEntries(resolve, reject);\n    });\n\n    for (let entry of entries) {\n      if (entry.isFile) {\n        let file = await getEntryFile(entry as FileSystemFileEntry);\n        yield createFileItem(file);\n      } else if (entry.isDirectory) {\n        yield createDirectoryItem(entry);\n      }\n    }\n  } while (entries.length > 0);\n}\n\nfunction getEntryFile(entry: FileSystemFileEntry): Promise<File> {\n  return new Promise((resolve, reject) => entry.file(resolve, reject));\n}\n\n/** Returns whether a drop item contains text data. */\nexport function isTextDropItem(dropItem: DropItem): dropItem is TextDropItem {\n  return dropItem.kind === 'text';\n}\n\n/** Returns whether a drop item is a file. */\nexport function isFileDropItem(dropItem: DropItem): dropItem is FileDropItem {\n  return dropItem.kind === 'file';\n}\n\n/** Returns whether a drop item is a directory. */\nexport function isDirectoryDropItem(dropItem: DropItem): dropItem is DirectoryDropItem {\n  return dropItem.kind === 'directory';\n}\n\n// Global DnD collection state tracker.\nexport interface DnDState {\n  /** A ref for the  of the drag items in the current drag session if any. */\n  draggingCollectionRef?: RefObject<HTMLElement | null>,\n  /** The set of currently dragged keys. */\n  draggingKeys: Set<Key>,\n  /** A ref for the collection that is targeted for a drop operation, if any. */\n  dropCollectionRef?: RefObject<HTMLElement | null>\n}\n\nexport let globalDndState: DnDState = {draggingKeys: new Set()};\n\nexport function setDraggingCollectionRef(ref: RefObject<HTMLElement | null>) {\n  globalDndState.draggingCollectionRef = ref;\n}\n\nexport function setDraggingKeys(keys: Set<Key>) {\n  globalDndState.draggingKeys = keys;\n}\n\nexport function setDropCollectionRef(ref: RefObject<HTMLElement | null>) {\n  globalDndState.dropCollectionRef = ref;\n}\n\nexport function clearGlobalDnDState() {\n  globalDndState = {draggingKeys: new Set()};\n}\n\nexport function setGlobalDnDState(state: DnDState) {\n  globalDndState = state;\n}\n\n// Util function to check if the current dragging collection ref is the same as the current targeted droppable collection ref.\n// Allows a droppable ref arg in case the global drop collection ref hasn't been set\nexport function isInternalDropOperation(ref?: RefObject<HTMLElement | null>) {\n  let {draggingCollectionRef, dropCollectionRef} = globalDndState;\n  return draggingCollectionRef?.current != null && draggingCollectionRef.current === (ref?.current || dropCollectionRef?.current);\n}\n\ntype DropEffect = 'none' | 'copy' | 'link' | 'move';\nexport let globalDropEffect: DropEffect;\nexport function setGlobalDropEffect(dropEffect: DropEffect) {\n  globalDropEffect = dropEffect;\n}\n\nexport let globalAllowedDropOperations = DROP_OPERATION.none;\nexport function setGlobalAllowedDropOperations(o: DROP_OPERATION) {\n  globalAllowedDropOperations = o;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}