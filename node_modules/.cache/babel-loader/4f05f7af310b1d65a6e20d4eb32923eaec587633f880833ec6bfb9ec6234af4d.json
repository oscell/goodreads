{"ast":null,"code":"import { CollectionNode as $23b9f4fcf0fe224b$export$d68d59712b04d9d1 } from \"./BaseCollection.mjs\";\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nclass $681cc3c98f569e39$export$410b0c854570d131 {\n  *[Symbol.iterator]() {\n    let node = this.firstChild;\n    while (node) {\n      yield node;\n      node = node.nextSibling;\n    }\n  }\n  get firstChild() {\n    return this._firstChild;\n  }\n  set firstChild(firstChild) {\n    this._firstChild = firstChild;\n    this.ownerDocument.markDirty(this);\n  }\n  get lastChild() {\n    return this._lastChild;\n  }\n  set lastChild(lastChild) {\n    this._lastChild = lastChild;\n    this.ownerDocument.markDirty(this);\n  }\n  get previousSibling() {\n    return this._previousSibling;\n  }\n  set previousSibling(previousSibling) {\n    this._previousSibling = previousSibling;\n    this.ownerDocument.markDirty(this);\n  }\n  get nextSibling() {\n    return this._nextSibling;\n  }\n  set nextSibling(nextSibling) {\n    this._nextSibling = nextSibling;\n    this.ownerDocument.markDirty(this);\n  }\n  get parentNode() {\n    return this._parentNode;\n  }\n  set parentNode(parentNode) {\n    this._parentNode = parentNode;\n    this.ownerDocument.markDirty(this);\n  }\n  get isConnected() {\n    var _this_parentNode;\n    return ((_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.isConnected) || false;\n  }\n  appendChild(child) {\n    this.ownerDocument.startTransaction();\n    if (child.parentNode) child.parentNode.removeChild(child);\n    if (this.firstChild == null) this.firstChild = child;\n    if (this.lastChild) {\n      this.lastChild.nextSibling = child;\n      child.index = this.lastChild.index + 1;\n      child.previousSibling = this.lastChild;\n    } else {\n      child.previousSibling = null;\n      child.index = 0;\n    }\n    child.parentNode = this;\n    child.nextSibling = null;\n    this.lastChild = child;\n    this.ownerDocument.markDirty(this);\n    if (child.hasSetProps)\n      // Only add the node to the collection if we already received props for it.\n      // Otherwise wait until then so we have the correct id for the node.\n      this.ownerDocument.addNode(child);\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n  insertBefore(newNode, referenceNode) {\n    if (referenceNode == null) return this.appendChild(newNode);\n    this.ownerDocument.startTransaction();\n    if (newNode.parentNode) newNode.parentNode.removeChild(newNode);\n    newNode.nextSibling = referenceNode;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.index = referenceNode.index;\n    if (this.firstChild === referenceNode) this.firstChild = newNode;else if (referenceNode.previousSibling) referenceNode.previousSibling.nextSibling = newNode;\n    referenceNode.previousSibling = newNode;\n    newNode.parentNode = referenceNode.parentNode;\n    let node = referenceNode;\n    while (node) {\n      node.index++;\n      node = node.nextSibling;\n    }\n    if (newNode.hasSetProps) this.ownerDocument.addNode(newNode);\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n  removeChild(child) {\n    if (child.parentNode !== this || !this.ownerDocument.isMounted) return;\n    this.ownerDocument.startTransaction();\n    let node = child.nextSibling;\n    while (node) {\n      node.index--;\n      node = node.nextSibling;\n    }\n    if (child.nextSibling) child.nextSibling.previousSibling = child.previousSibling;\n    if (child.previousSibling) child.previousSibling.nextSibling = child.nextSibling;\n    if (this.firstChild === child) this.firstChild = child.nextSibling;\n    if (this.lastChild === child) this.lastChild = child.previousSibling;\n    child.parentNode = null;\n    child.nextSibling = null;\n    child.previousSibling = null;\n    child.index = 0;\n    this.ownerDocument.removeNode(child);\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n  addEventListener() {}\n  removeEventListener() {}\n  constructor(ownerDocument) {\n    this._firstChild = null;\n    this._lastChild = null;\n    this._previousSibling = null;\n    this._nextSibling = null;\n    this._parentNode = null;\n    this.ownerDocument = ownerDocument;\n  }\n}\nclass $681cc3c98f569e39$export$dc064fe9e59310fd extends $681cc3c98f569e39$export$410b0c854570d131 {\n  get index() {\n    return this._index;\n  }\n  set index(index) {\n    this._index = index;\n    this.ownerDocument.markDirty(this);\n  }\n  get level() {\n    if (this.parentNode instanceof $681cc3c98f569e39$export$dc064fe9e59310fd) return this.parentNode.level + (this.node.type === 'item' ? 1 : 0);\n    return 0;\n  }\n  updateNode() {\n    var _this_previousSibling, _this_nextSibling, _this_firstChild, _this_lastChild;\n    let node = this.ownerDocument.getMutableNode(this);\n    node.index = this.index;\n    node.level = this.level;\n    node.parentKey = this.parentNode instanceof $681cc3c98f569e39$export$dc064fe9e59310fd ? this.parentNode.node.key : null;\n    var _this_previousSibling_node_key;\n    node.prevKey = (_this_previousSibling_node_key = (_this_previousSibling = this.previousSibling) === null || _this_previousSibling === void 0 ? void 0 : _this_previousSibling.node.key) !== null && _this_previousSibling_node_key !== void 0 ? _this_previousSibling_node_key : null;\n    var _this_nextSibling_node_key;\n    node.nextKey = (_this_nextSibling_node_key = (_this_nextSibling = this.nextSibling) === null || _this_nextSibling === void 0 ? void 0 : _this_nextSibling.node.key) !== null && _this_nextSibling_node_key !== void 0 ? _this_nextSibling_node_key : null;\n    node.hasChildNodes = !!this.firstChild;\n    var _this_firstChild_node_key;\n    node.firstChildKey = (_this_firstChild_node_key = (_this_firstChild = this.firstChild) === null || _this_firstChild === void 0 ? void 0 : _this_firstChild.node.key) !== null && _this_firstChild_node_key !== void 0 ? _this_firstChild_node_key : null;\n    var _this_lastChild_node_key;\n    node.lastChildKey = (_this_lastChild_node_key = (_this_lastChild = this.lastChild) === null || _this_lastChild === void 0 ? void 0 : _this_lastChild.node.key) !== null && _this_lastChild_node_key !== void 0 ? _this_lastChild_node_key : null;\n  }\n  setProps(obj, ref, rendered, render) {\n    let node = this.ownerDocument.getMutableNode(this);\n    let {\n      value: value,\n      textValue: textValue,\n      id: id,\n      ...props\n    } = obj;\n    props.ref = ref;\n    node.props = props;\n    node.rendered = rendered;\n    node.render = render;\n    node.value = value;\n    node.textValue = textValue || (typeof props.children === 'string' ? props.children : '') || obj['aria-label'] || '';\n    if (id != null && id !== node.key) {\n      if (this.hasSetProps) throw new Error('Cannot change the id of an item');\n      node.key = id;\n    }\n    // If this is the first time props have been set, end the transaction started in the constructor\n    // so this node can be emitted.\n    if (!this.hasSetProps) {\n      this.ownerDocument.addNode(this);\n      this.ownerDocument.endTransaction();\n      this.hasSetProps = true;\n    }\n    this.ownerDocument.queueUpdate();\n  }\n  get style() {\n    return {};\n  }\n  hasAttribute() {}\n  setAttribute() {}\n  setAttributeNS() {}\n  removeAttribute() {}\n  constructor(type, ownerDocument) {\n    super(ownerDocument);\n    this.nodeType = 8 // COMMENT_NODE (we'd use ELEMENT_NODE but React DevTools will fail to get its dimensions)\n    ;\n    this._index = 0;\n    this.hasSetProps = false;\n    this.node = new (0, $23b9f4fcf0fe224b$export$d68d59712b04d9d1)(type, `react-aria-${++ownerDocument.nodeId}`);\n    // Start a transaction so that no updates are emitted from the collection\n    // until the props for this node are set. We don't know the real id for the\n    // node until then, so we need to avoid emitting collections in an inconsistent state.\n    this.ownerDocument.startTransaction();\n  }\n}\nclass $681cc3c98f569e39$export$b34a105447964f9f extends $681cc3c98f569e39$export$410b0c854570d131 {\n  get isConnected() {\n    return this.isMounted;\n  }\n  createElement(type) {\n    return new $681cc3c98f569e39$export$dc064fe9e59310fd(type, this);\n  }\n  /**\n  * Lazily gets a mutable instance of a Node. If the node has already\n  * been cloned during this update cycle, it just returns the existing one.\n  */\n  getMutableNode(element) {\n    let node = element.node;\n    if (!this.mutatedNodes.has(element)) {\n      node = element.node.clone();\n      this.mutatedNodes.add(element);\n      element.node = node;\n    }\n    this.markDirty(element);\n    return node;\n  }\n  getMutableCollection() {\n    if (!this.isSSR && !this.collectionMutated) {\n      this.collection = this.collection.clone();\n      this.collectionMutated = true;\n    }\n    return this.collection;\n  }\n  markDirty(node) {\n    this.dirtyNodes.add(node);\n  }\n  startTransaction() {\n    this.transactionCount++;\n  }\n  endTransaction() {\n    this.transactionCount--;\n  }\n  addNode(element) {\n    let collection = this.getMutableCollection();\n    if (!collection.getItem(element.node.key)) {\n      collection.addNode(element.node);\n      for (let child of element) this.addNode(child);\n    }\n    this.markDirty(element);\n  }\n  removeNode(node) {\n    for (let child of node) this.removeNode(child);\n    let collection = this.getMutableCollection();\n    collection.removeNode(node.node.key);\n    this.markDirty(node);\n  }\n  /** Finalizes the collection update, updating all nodes and freezing the collection. */\n  getCollection() {\n    if (this.transactionCount > 0) return this.collection;\n    this.updateCollection();\n    return this.collection;\n  }\n  updateCollection() {\n    for (let element of this.dirtyNodes) if (element instanceof $681cc3c98f569e39$export$dc064fe9e59310fd && element.isConnected) element.updateNode();\n    this.dirtyNodes.clear();\n    if (this.mutatedNodes.size || this.collectionMutated) {\n      var _this_firstChild, _this_lastChild;\n      let collection = this.getMutableCollection();\n      for (let element of this.mutatedNodes) if (element.isConnected) collection.addNode(element.node);\n      var _this_firstChild_node_key, _this_lastChild_node_key;\n      collection.commit((_this_firstChild_node_key = (_this_firstChild = this.firstChild) === null || _this_firstChild === void 0 ? void 0 : _this_firstChild.node.key) !== null && _this_firstChild_node_key !== void 0 ? _this_firstChild_node_key : null, (_this_lastChild_node_key = (_this_lastChild = this.lastChild) === null || _this_lastChild === void 0 ? void 0 : _this_lastChild.node.key) !== null && _this_lastChild_node_key !== void 0 ? _this_lastChild_node_key : null, this.isSSR);\n      this.mutatedNodes.clear();\n    }\n    this.collectionMutated = false;\n  }\n  queueUpdate() {\n    // Don't emit any updates if there is a transaction in progress.\n    // queueUpdate should be called again after the transaction.\n    if (this.dirtyNodes.size === 0 || this.transactionCount > 0) return;\n    for (let fn of this.subscriptions) fn();\n  }\n  subscribe(fn) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n  resetAfterSSR() {\n    if (this.isSSR) {\n      this.isSSR = false;\n      this.firstChild = null;\n      this.lastChild = null;\n      this.nodeId = 0;\n    }\n  }\n  constructor(collection) {\n    // @ts-ignore\n    super(null);\n    this.nodeType = 11 // DOCUMENT_FRAGMENT_NODE\n    ;\n    this.ownerDocument = this;\n    this.dirtyNodes = new Set();\n    this.isSSR = false;\n    this.nodeId = 0;\n    this.nodesByProps = new WeakMap();\n    this.isMounted = true;\n    this.mutatedNodes = new Set();\n    this.subscriptions = new Set();\n    this.transactionCount = 0;\n    this.collection = collection;\n    this.collectionMutated = true;\n  }\n}\nexport { $681cc3c98f569e39$export$410b0c854570d131 as BaseNode, $681cc3c98f569e39$export$dc064fe9e59310fd as ElementNode, $681cc3c98f569e39$export$b34a105447964f9f as Document };","map":{"version":3,"names":["$681cc3c98f569e39$export$410b0c854570d131","Symbol","iterator","node","firstChild","nextSibling","_firstChild","ownerDocument","markDirty","lastChild","_lastChild","previousSibling","_previousSibling","_nextSibling","parentNode","_parentNode","isConnected","_this_parentNode","appendChild","child","startTransaction","removeChild","index","hasSetProps","addNode","endTransaction","queueUpdate","insertBefore","newNode","referenceNode","isMounted","removeNode","addEventListener","removeEventListener","constructor","$681cc3c98f569e39$export$dc064fe9e59310fd","_index","level","type","updateNode","_this_previousSibling","_this_nextSibling","_this_firstChild","_this_lastChild","getMutableNode","parentKey","key","_this_previousSibling_node_key","prevKey","_this_nextSibling_node_key","nextKey","hasChildNodes","_this_firstChild_node_key","firstChildKey","_this_lastChild_node_key","lastChildKey","setProps","obj","ref","rendered","render","value","textValue","id","props","children","Error","style","hasAttribute","setAttribute","setAttributeNS","removeAttribute","nodeType","$23b9f4fcf0fe224b$export$d68d59712b04d9d1","nodeId","$681cc3c98f569e39$export$b34a105447964f9f","createElement","element","mutatedNodes","has","clone","add","getMutableCollection","isSSR","collectionMutated","collection","dirtyNodes","transactionCount","getItem","getCollection","updateCollection","clear","size","commit","fn","subscriptions","subscribe","delete","resetAfterSSR","Set","nodesByProps","WeakMap"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-aria/collections/dist/packages/@react-aria/collections/src/Document.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {BaseCollection, CollectionNode, Mutable} from './BaseCollection';\nimport {ForwardedRef, ReactElement} from 'react';\nimport {Node} from '@react-types/shared';\n\n// This Collection implementation is perhaps a little unusual. It works by rendering the React tree into a\n// Portal to a fake DOM implementation. This gives us efficient access to the tree of rendered objects, and\n// supports React features like composition and context. We use this fake DOM to access the full set of elements\n// before we render into the real DOM, which allows us to render a subset of the elements (e.g. virtualized scrolling),\n// and compute properties like the total number of items. It also enables keyboard navigation, selection, and other features.\n// React takes care of efficiently rendering components and updating the collection for us via this fake DOM.\n//\n// The DOM is a mutable API, and React expects the node instances to remain stable over time. So the implementation is split\n// into two parts. Each mutable fake DOM node owns an instance of an immutable collection node. When a fake DOM node is updated,\n// it queues a second render for the collection. Multiple updates to a collection can be queued at once. Collection nodes are\n// lazily copied on write, so only the changed nodes need to be cloned. During the second render, the new immutable collection\n// is finalized by updating the map of Key -> Node with the new cloned nodes. Then the new collection is frozen so it can no\n// longer be mutated, and returned to the calling component to render.\n\n/**\n * A mutable node in the fake DOM tree. When mutated, it marks itself as dirty\n * and queues an update with the owner document.\n */\nexport class BaseNode<T> {\n  private _firstChild: ElementNode<T> | null = null;\n  private _lastChild: ElementNode<T> | null = null;\n  private _previousSibling: ElementNode<T> | null = null;\n  private _nextSibling: ElementNode<T> | null = null;\n  private _parentNode: BaseNode<T> | null = null;\n  ownerDocument: Document<T, any>;\n\n  constructor(ownerDocument: Document<T, any>) {\n    this.ownerDocument = ownerDocument;\n  }\n\n  *[Symbol.iterator]() {\n    let node = this.firstChild;\n    while (node) {\n      yield node;\n      node = node.nextSibling;\n    }\n  }\n\n  get firstChild() {\n    return this._firstChild;\n  }\n\n  set firstChild(firstChild) {\n    this._firstChild = firstChild;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get lastChild() {\n    return this._lastChild;\n  }\n\n  set lastChild(lastChild) {\n    this._lastChild = lastChild;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get previousSibling() {\n    return this._previousSibling;\n  }\n\n  set previousSibling(previousSibling) {\n    this._previousSibling = previousSibling;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get nextSibling() {\n    return this._nextSibling;\n  }\n\n  set nextSibling(nextSibling) {\n    this._nextSibling = nextSibling;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get parentNode() {\n    return this._parentNode;\n  }\n\n  set parentNode(parentNode) {\n    this._parentNode = parentNode;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get isConnected() {\n    return this.parentNode?.isConnected || false;\n  }\n\n  appendChild(child: ElementNode<T>) {\n    this.ownerDocument.startTransaction();\n    if (child.parentNode) {\n      child.parentNode.removeChild(child);\n    }\n\n    if (this.firstChild == null) {\n      this.firstChild = child;\n    }\n\n    if (this.lastChild) {\n      this.lastChild.nextSibling = child;\n      child.index = this.lastChild.index + 1;\n      child.previousSibling = this.lastChild;\n    } else {\n      child.previousSibling = null;\n      child.index = 0;\n    }\n\n    child.parentNode = this;\n    child.nextSibling = null;\n    this.lastChild = child;\n\n    this.ownerDocument.markDirty(this);\n    if (child.hasSetProps) {\n      // Only add the node to the collection if we already received props for it.\n      // Otherwise wait until then so we have the correct id for the node.\n      this.ownerDocument.addNode(child);\n    }\n\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  insertBefore(newNode: ElementNode<T>, referenceNode: ElementNode<T>) {\n    if (referenceNode == null) {\n      return this.appendChild(newNode);\n    }\n\n    this.ownerDocument.startTransaction();\n    if (newNode.parentNode) {\n      newNode.parentNode.removeChild(newNode);\n    }\n\n    newNode.nextSibling = referenceNode;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.index = referenceNode.index;\n\n    if (this.firstChild === referenceNode) {\n      this.firstChild = newNode;\n    } else if (referenceNode.previousSibling) {\n      referenceNode.previousSibling.nextSibling = newNode;\n    }\n\n    referenceNode.previousSibling = newNode;\n    newNode.parentNode = referenceNode.parentNode;\n\n    let node: ElementNode<T> | null = referenceNode;\n    while (node) {\n      node.index++;\n      node = node.nextSibling;\n    }\n\n    if (newNode.hasSetProps) {\n      this.ownerDocument.addNode(newNode);\n    }\n\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  removeChild(child: ElementNode<T>) {\n    if (child.parentNode !== this || !this.ownerDocument.isMounted) {\n      return;\n    }\n\n    this.ownerDocument.startTransaction();\n    let node = child.nextSibling;\n    while (node) {\n      node.index--;\n      node = node.nextSibling;\n    }\n\n    if (child.nextSibling) {\n      child.nextSibling.previousSibling = child.previousSibling;\n    }\n\n    if (child.previousSibling) {\n      child.previousSibling.nextSibling = child.nextSibling;\n    }\n\n    if (this.firstChild === child) {\n      this.firstChild = child.nextSibling;\n    }\n\n    if (this.lastChild === child) {\n      this.lastChild = child.previousSibling;\n    }\n\n    child.parentNode = null;\n    child.nextSibling = null;\n    child.previousSibling = null;\n    child.index = 0;\n\n    this.ownerDocument.removeNode(child);\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  addEventListener() {}\n  removeEventListener() {}\n}\n\n/**\n * A mutable element node in the fake DOM tree. It owns an immutable\n * Collection Node which is copied on write.\n */\nexport class ElementNode<T> extends BaseNode<T> {\n  nodeType = 8; // COMMENT_NODE (we'd use ELEMENT_NODE but React DevTools will fail to get its dimensions)\n  node: CollectionNode<T>;\n  private _index: number = 0;\n  hasSetProps = false;\n\n  constructor(type: string, ownerDocument: Document<T, any>) {\n    super(ownerDocument);\n    this.node = new CollectionNode(type, `react-aria-${++ownerDocument.nodeId}`);\n    // Start a transaction so that no updates are emitted from the collection\n    // until the props for this node are set. We don't know the real id for the\n    // node until then, so we need to avoid emitting collections in an inconsistent state.\n    this.ownerDocument.startTransaction();\n  }\n\n  get index() {\n    return this._index;\n  }\n\n  set index(index) {\n    this._index = index;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get level(): number {\n    if (this.parentNode instanceof ElementNode) {\n      return this.parentNode.level + (this.node.type === 'item' ? 1 : 0);\n    }\n\n    return 0;\n  }\n\n  updateNode() {\n    let node = this.ownerDocument.getMutableNode(this);\n    node.index = this.index;\n    node.level = this.level;\n    node.parentKey = this.parentNode instanceof ElementNode ? this.parentNode.node.key : null;\n    node.prevKey = this.previousSibling?.node.key ?? null;\n    node.nextKey = this.nextSibling?.node.key ?? null;\n    node.hasChildNodes = !!this.firstChild;\n    node.firstChildKey = this.firstChild?.node.key ?? null;\n    node.lastChildKey = this.lastChild?.node.key ?? null;\n  }\n\n  setProps<E extends Element>(obj: any, ref: ForwardedRef<E>, rendered?: any, render?: (node: Node<T>) => ReactElement) {\n    let node = this.ownerDocument.getMutableNode(this);\n    let {value, textValue, id, ...props} = obj;\n    props.ref = ref;\n    node.props = props;\n    node.rendered = rendered;\n    node.render = render;\n    node.value = value;\n    node.textValue = textValue || (typeof props.children === 'string' ? props.children : '') || obj['aria-label'] || '';\n    if (id != null && id !== node.key) {\n      if (this.hasSetProps) {\n        throw new Error('Cannot change the id of an item');\n      }\n      node.key = id;\n    }\n\n    // If this is the first time props have been set, end the transaction started in the constructor\n    // so this node can be emitted.\n    if (!this.hasSetProps) {\n      this.ownerDocument.addNode(this);\n      this.ownerDocument.endTransaction();\n      this.hasSetProps = true;\n    }\n\n    this.ownerDocument.queueUpdate();\n  }\n\n  get style() {\n    return {};\n  }\n\n  hasAttribute() {}\n  setAttribute() {}\n  setAttributeNS() {}\n  removeAttribute() {}\n}\n\n/**\n * A mutable Document in the fake DOM. It owns an immutable Collection instance,\n * which is lazily copied on write during updates.\n */\nexport class Document<T, C extends BaseCollection<T> = BaseCollection<T>> extends BaseNode<T> {\n  nodeType = 11; // DOCUMENT_FRAGMENT_NODE\n  ownerDocument = this;\n  dirtyNodes: Set<BaseNode<T>> = new Set();\n  isSSR = false;\n  nodeId = 0;\n  nodesByProps = new WeakMap<object, ElementNode<T>>();\n  isMounted = true;\n  private collection: C;\n  private collectionMutated: boolean;\n  private mutatedNodes: Set<ElementNode<T>> = new Set();\n  private subscriptions: Set<() => void> = new Set();\n  private transactionCount = 0;\n\n  constructor(collection: C) {\n    // @ts-ignore\n    super(null);\n    this.collection = collection;\n    this.collectionMutated = true;\n  }\n\n  get isConnected() {\n    return this.isMounted;\n  }\n\n  createElement(type: string) {\n    return new ElementNode(type, this);\n  }\n\n  /**\n   * Lazily gets a mutable instance of a Node. If the node has already\n   * been cloned during this update cycle, it just returns the existing one.\n   */\n  getMutableNode(element: ElementNode<T>): Mutable<CollectionNode<T>> {\n    let node = element.node;\n    if (!this.mutatedNodes.has(element)) {\n      node = element.node.clone();\n      this.mutatedNodes.add(element);\n      element.node = node;\n    }\n    this.markDirty(element);\n    return node;\n  }\n\n  private getMutableCollection() {\n    if (!this.isSSR && !this.collectionMutated) {\n      this.collection = this.collection.clone();\n      this.collectionMutated = true;\n    }\n\n    return this.collection;\n  }\n\n  markDirty(node: BaseNode<T>) {\n    this.dirtyNodes.add(node);\n  }\n\n  startTransaction() {\n    this.transactionCount++;\n  }\n\n  endTransaction() {\n    this.transactionCount--;\n  }\n\n  addNode(element: ElementNode<T>) {\n    let collection = this.getMutableCollection();\n    if (!collection.getItem(element.node.key)) {\n      collection.addNode(element.node);\n\n      for (let child of element) {\n        this.addNode(child);\n      }\n    }\n\n    this.markDirty(element);\n  }\n\n  removeNode(node: ElementNode<T>) {\n    for (let child of node) {\n      this.removeNode(child);\n    }\n\n    let collection = this.getMutableCollection();\n    collection.removeNode(node.node.key);\n    this.markDirty(node);\n  }\n\n  /** Finalizes the collection update, updating all nodes and freezing the collection. */\n  getCollection(): C {\n    if (this.transactionCount > 0) {\n      return this.collection;\n    }\n\n    this.updateCollection();\n    return this.collection;\n  }\n\n  updateCollection() {\n    for (let element of this.dirtyNodes) {\n      if (element instanceof ElementNode && element.isConnected) {\n        element.updateNode();\n      }\n    }\n\n    this.dirtyNodes.clear();\n\n    if (this.mutatedNodes.size || this.collectionMutated) {\n      let collection = this.getMutableCollection();\n      for (let element of this.mutatedNodes) {\n        if (element.isConnected) {\n          collection.addNode(element.node);\n        }\n      }\n\n      collection.commit(this.firstChild?.node.key ?? null, this.lastChild?.node.key ?? null, this.isSSR);\n      this.mutatedNodes.clear();\n    }\n\n    this.collectionMutated = false;\n  }\n\n  queueUpdate() {\n    // Don't emit any updates if there is a transaction in progress.\n    // queueUpdate should be called again after the transaction.\n    if (this.dirtyNodes.size === 0 || this.transactionCount > 0) {\n      return;\n    }\n\n    for (let fn of this.subscriptions) {\n      fn();\n    }\n  }\n\n  subscribe(fn: () => void) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n\n  resetAfterSSR() {\n    if (this.isSSR) {\n      this.isSSR = false;\n      this.firstChild = null;\n      this.lastChild = null;\n      this.nodeId = 0;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}