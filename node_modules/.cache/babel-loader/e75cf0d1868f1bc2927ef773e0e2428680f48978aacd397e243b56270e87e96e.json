{"ast":null,"code":"import { useState as $3pPTd$useState } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => {\n      var _item_id;\n      return (_item_id = item.id) !== null && _item_id !== void 0 ? _item_id : item.key;\n    },\n    getChildren = item => item.children\n  } = options;\n  // We only want to compute this on initial render.\n  let [tree, setItems] = (0, $3pPTd$useState)(() => buildTree(initialItems, new Map()));\n  let {\n    items: items,\n    nodeMap: nodeMap\n  } = tree;\n  let [selectedKeys, setSelectedKeys] = (0, $3pPTd$useState)(new Set(initialSelectedKeys || []));\n  function buildTree(initialItems = [], map, parentKey) {\n    if (initialItems == null) initialItems = [];\n    return {\n      items: initialItems.map(item => {\n        let node = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n  function updateTree(items, key, update, originalMap) {\n    let node = originalMap.get(key);\n    if (!node) return {\n      items: items,\n      nodeMap: originalMap\n    };\n    let map = new Map(originalMap);\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) deleteNode(node, map);else addNode(newNode, map);\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n      if (newNode == null) children = children.filter(c => c !== node);\n      copy.children = children.map(child => {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(c => c !== node);\n    return {\n      items: items.map(item => {\n        if (item === node) return newNode;\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n  function addNode(node, map) {\n    map.set(node.key, node);\n    for (let child of node.children) addNode(child, map);\n  }\n  function deleteNode(node, map) {\n    map.delete(node.key);\n    for (let child of node.children) deleteNode(child, map);\n  }\n  return {\n    items: items,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem(key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey, index, ...values) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => {\n        let {\n          items: newNodes,\n          nodeMap: newMap\n        } = buildTree(values, originalMap, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return {\n          items: [...items.slice(0, index), ...newNodes, ...items.slice(index)],\n          nodeMap: newMap\n        };\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...newNodes, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    insertBefore(key, ...values) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);\n    },\n    insertAfter(key, ...values) {\n      let node = nodeMap.get(key);\n      if (!node) return;\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);\n    },\n    prepend(parentKey, ...values) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey, ...values) {\n      if (parentKey == null) this.insert(null, items.length, ...values);else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) return;\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys) {\n      if (keys.length === 0) return;\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n      setItems(newTree);\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) if (!newTree.nodeMap.has(key)) selection.delete(key);\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key, toParentKey, index) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => {\n        let node = originalMap.get(key);\n        if (!node) return {\n          items: items,\n          nodeMap: originalMap\n        };\n        let {\n          items: newItems,\n          nodeMap: newMap\n        } = updateTree(items, key, () => null, originalMap);\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {\n            items: [...newItems.slice(0, index), movedNode, ...newItems.slice(index)],\n            nodeMap: newMap\n          };\n        }\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), movedNode, ...parentNode.children.slice(index)]\n        }), newMap);\n      });\n    },\n    update(oldKey, newValue) {\n      setItems(({\n        items: items,\n        nodeMap: originalMap\n      }) => updateTree(items, oldKey, oldNode => {\n        let node = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\nexport { $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData };","map":{"version":3,"names":["$be2ea0343af54212$export$d14e1352e21f4a16","options","initialItems","initialSelectedKeys","getKey","item","_item_id","id","key","getChildren","children","tree","setItems","$3pPTd$useState","buildTree","Map","items","nodeMap","selectedKeys","setSelectedKeys","Set","map","parentKey","node","value","set","updateTree","update","originalMap","get","newNode","deleteNode","addNode","nextParent","copy","filter","c","child","delete","getItem","insert","index","values","newNodes","newMap","slice","parentNode","insertBefore","nodes","indexOf","insertAfter","prepend","append","length","remove","keys","newItems","prevMap","newTree","selection","has","removeSelectedItems","move","toParentKey","movedNode","oldKey","newValue","oldNode"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into. `null` for the root.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key | null, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id ?? item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n\n  // We only want to compute this on initial render.\n  let [tree, setItems] = useState<{items: TreeNode<T>[], nodeMap: Map<Key, TreeNode<T>>}>(() => buildTree(initialItems, new Map()));\n  let {items, nodeMap} = tree;\n\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] | null = [], map: Map<Key, TreeNode<T>>, parentKey?: Key | null) {\n    if (initialItems == null) {\n      initialItems = [];\n    }\n    return {\n      items: initialItems.map(item => {\n        let node: TreeNode<T> = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>, originalMap: Map<Key, TreeNode<T>>) {\n    let node = originalMap.get(key);\n    if (!node) {\n      return {items, nodeMap: originalMap};\n    }\n    let map = new Map<Key, TreeNode<T>>(originalMap);\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node, map);\n    } else {\n      addNode(newNode, map);\n    }\n\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return {\n      items: items.map(item => {\n        if (item === node) {\n          return newNode;\n        }\n\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function addNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child, map);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child, map);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let {items: newNodes, nodeMap: newMap} = buildTree(values, originalMap, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return {\n            items: [\n              ...items.slice(0, index),\n              ...newNodes,\n              ...items.slice(index)\n            ],\n            nodeMap: newMap\n          };\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...newNodes,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      if (keys.length === 0) {\n        return;\n      }\n\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n\n      setItems(newTree);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!newTree.nodeMap.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key | null, index: number) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let node = originalMap.get(key);\n        if (!node) {\n          return {items, nodeMap: originalMap};\n        }\n\n        let {items: newItems, nodeMap: newMap} = updateTree(items, key, () => null, originalMap);\n\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {items: [\n            ...newItems.slice(0, index),\n            movedNode,\n            ...newItems.slice(index)\n          ], nodeMap: newMap};\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(({items, nodeMap: originalMap}) => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}