{"ast":null,"code":"// lite/builds/browser.ts\nimport { createXhrRequester } from \"@algolia/requester-browser-xhr\";\nimport { createBrowserLocalStorageCache, createFallbackableCache, createMemoryCache, createNullLogger, DEFAULT_CONNECT_TIMEOUT_BROWSER, DEFAULT_READ_TIMEOUT_BROWSER, DEFAULT_WRITE_TIMEOUT_BROWSER } from \"@algolia/client-common\";\n\n// lite/src/liteClient.ts\nimport { createAuth, createTransporter, getAlgoliaAgent, shuffle } from \"@algolia/client-common\";\nvar apiClientVersion = \"5.9.1\";\nfunction getDefaultHosts(appId) {\n  return [{\n    url: `${appId}-dsn.algolia.net`,\n    accept: \"read\",\n    protocol: \"https\"\n  }, {\n    url: `${appId}.algolia.net`,\n    accept: \"write\",\n    protocol: \"https\"\n  }].concat(shuffle([{\n    url: `${appId}-1.algolianet.com`,\n    accept: \"readWrite\",\n    protocol: \"https\"\n  }, {\n    url: `${appId}-2.algolianet.com`,\n    accept: \"readWrite\",\n    protocol: \"https\"\n  }, {\n    url: `${appId}-3.algolianet.com`,\n    accept: \"readWrite\",\n    protocol: \"https\"\n  }]));\n}\nfunction createLiteClient({\n  appId: appIdOption,\n  apiKey: apiKeyOption,\n  authMode,\n  algoliaAgents,\n  ...options\n}) {\n  const auth = createAuth(appIdOption, apiKeyOption, authMode);\n  const transporter = createTransporter({\n    hosts: getDefaultHosts(appIdOption),\n    ...options,\n    algoliaAgent: getAlgoliaAgent({\n      algoliaAgents,\n      client: \"Lite\",\n      version: apiClientVersion\n    }),\n    baseHeaders: {\n      \"content-type\": \"text/plain\",\n      ...auth.headers(),\n      ...options.baseHeaders\n    },\n    baseQueryParameters: {\n      ...auth.queryParameters(),\n      ...options.baseQueryParameters\n    }\n  });\n  return {\n    transporter,\n    /**\n     * The `appId` currently in use.\n     */\n    appId: appIdOption,\n    /**\n     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.\n     */\n    clearCache() {\n      return Promise.all([transporter.requestsCache.clear(), transporter.responsesCache.clear()]).then(() => void 0);\n    },\n    /**\n     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.\n     */\n    get _ua() {\n      return transporter.algoliaAgent.value;\n    },\n    /**\n     * Adds a `segment` to the `x-algolia-agent` sent with every requests.\n     *\n     * @param segment - The algolia agent (user-agent) segment to add.\n     * @param version - The version of the agent.\n     */\n    addAlgoliaAgent(segment, version) {\n      transporter.algoliaAgent.add({\n        segment,\n        version\n      });\n    },\n    /**\n     * Helper method to switch the API key used to authenticate the requests.\n     *\n     * @param params - Method params.\n     * @param params.apiKey - The new API Key to use.\n     */\n    setClientApiKey({\n      apiKey\n    }) {\n      if (!authMode || authMode === \"WithinHeaders\") {\n        transporter.baseHeaders[\"x-algolia-api-key\"] = apiKey;\n      } else {\n        transporter.baseQueryParameters[\"x-algolia-api-key\"] = apiKey;\n      }\n    },\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `hits`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForHits(searchMethodParams, requestOptions) {\n      return this.search(searchMethodParams, requestOptions);\n    },\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `facets`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForFacets(searchMethodParams, requestOptions) {\n      return this.search(searchMethodParams, requestOptions);\n    },\n    /**\n     * This method allow you to send requests to the Algolia REST API.\n     * @param customPost - The customPost object.\n     * @param customPost.path - Path of the endpoint, anything after \\\"/1\\\" must be specified.\n     * @param customPost.parameters - Query parameters to apply to the current query.\n     * @param customPost.body - Parameters to send with the custom request.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    customPost({\n      path,\n      parameters,\n      body\n    }, requestOptions) {\n      if (!path) {\n        throw new Error(\"Parameter `path` is required when calling `customPost`.\");\n      }\n      const requestPath = \"/{path}\".replace(\"{path}\", path);\n      const headers = {};\n      const queryParameters = parameters ? parameters : {};\n      const request = {\n        method: \"POST\",\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: body ? body : {}\n      };\n      return transporter.request(request, requestOptions);\n    },\n    /**\n     * Retrieves recommendations from selected AI models.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param getRecommendationsParams - The getRecommendationsParams object.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    getRecommendations(getRecommendationsParams, requestOptions) {\n      if (getRecommendationsParams && Array.isArray(getRecommendationsParams)) {\n        const newSignatureRequest = {\n          requests: getRecommendationsParams\n        };\n        getRecommendationsParams = newSignatureRequest;\n      }\n      if (!getRecommendationsParams) {\n        throw new Error(\"Parameter `getRecommendationsParams` is required when calling `getRecommendations`.\");\n      }\n      if (!getRecommendationsParams.requests) {\n        throw new Error(\"Parameter `getRecommendationsParams.requests` is required when calling `getRecommendations`.\");\n      }\n      const requestPath = \"/1/indexes/*/recommendations\";\n      const headers = {};\n      const queryParameters = {};\n      const request = {\n        method: \"POST\",\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: getRecommendationsParams,\n        useReadTransporter: true,\n        cacheable: true\n      };\n      return transporter.request(request, requestOptions);\n    },\n    /**\n     * Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same index—for example, with different filters.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param searchMethodParams - Muli-search request body. Results are returned in the same order as the requests.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    search(searchMethodParams, requestOptions) {\n      if (searchMethodParams && Array.isArray(searchMethodParams)) {\n        const newSignatureRequest = {\n          requests: searchMethodParams.map(({\n            params,\n            ...legacyRequest\n          }) => {\n            if (legacyRequest.type === \"facet\") {\n              return {\n                ...legacyRequest,\n                ...params,\n                type: \"facet\"\n              };\n            }\n            return {\n              ...legacyRequest,\n              ...params,\n              facet: void 0,\n              maxFacetHits: void 0,\n              facetQuery: void 0\n            };\n          })\n        };\n        searchMethodParams = newSignatureRequest;\n      }\n      if (!searchMethodParams) {\n        throw new Error(\"Parameter `searchMethodParams` is required when calling `search`.\");\n      }\n      if (!searchMethodParams.requests) {\n        throw new Error(\"Parameter `searchMethodParams.requests` is required when calling `search`.\");\n      }\n      const requestPath = \"/1/indexes/*/queries\";\n      const headers = {};\n      const queryParameters = {};\n      const request = {\n        method: \"POST\",\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: searchMethodParams,\n        useReadTransporter: true,\n        cacheable: true\n      };\n      return transporter.request(request, requestOptions);\n    }\n  };\n}\n\n// lite/builds/browser.ts\nfunction liteClient(appId, apiKey, options) {\n  if (!appId || typeof appId !== \"string\") {\n    throw new Error(\"`appId` is missing.\");\n  }\n  if (!apiKey || typeof apiKey !== \"string\") {\n    throw new Error(\"`apiKey` is missing.\");\n  }\n  return createLiteClient({\n    appId,\n    apiKey,\n    timeouts: {\n      connect: DEFAULT_CONNECT_TIMEOUT_BROWSER,\n      read: DEFAULT_READ_TIMEOUT_BROWSER,\n      write: DEFAULT_WRITE_TIMEOUT_BROWSER\n    },\n    logger: createNullLogger(),\n    requester: createXhrRequester(),\n    algoliaAgents: [{\n      segment: \"Browser\"\n    }],\n    authMode: \"WithinQueryParameters\",\n    responsesCache: createMemoryCache(),\n    requestsCache: createMemoryCache({\n      serializable: false\n    }),\n    hostsCache: createFallbackableCache({\n      caches: [createBrowserLocalStorageCache({\n        key: `${apiClientVersion}-${appId}`\n      }), createMemoryCache()]\n    }),\n    ...options\n  });\n}\nexport { apiClientVersion, liteClient };","map":{"version":3,"names":["createXhrRequester","createBrowserLocalStorageCache","createFallbackableCache","createMemoryCache","createNullLogger","DEFAULT_CONNECT_TIMEOUT_BROWSER","DEFAULT_READ_TIMEOUT_BROWSER","DEFAULT_WRITE_TIMEOUT_BROWSER","createAuth","createTransporter","getAlgoliaAgent","shuffle","apiClientVersion","getDefaultHosts","appId","url","accept","protocol","concat","createLiteClient","appIdOption","apiKey","apiKeyOption","authMode","algoliaAgents","options","auth","transporter","hosts","algoliaAgent","client","version","baseHeaders","headers","baseQueryParameters","queryParameters","clearCache","Promise","all","requestsCache","clear","responsesCache","then","_ua","value","addAlgoliaAgent","segment","add","setClientApiKey","searchForHits","searchMethodParams","requestOptions","search","searchForFacets","customPost","path","parameters","body","Error","requestPath","replace","request","method","data","getRecommendations","getRecommendationsParams","Array","isArray","newSignatureRequest","requests","useReadTransporter","cacheable","map","params","legacyRequest","type","facet","maxFacetHits","facetQuery","liteClient","timeouts","connect","read","write","logger","requester","serializable","hostsCache","caches","key"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/algoliasearch/lite/builds/browser.ts","/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/algoliasearch/lite/src/liteClient.ts"],"sourcesContent":["// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.\n\nimport { createXhrRequester } from '@algolia/requester-browser-xhr';\n\nimport {\n  ClientOptions,\n  createBrowserLocalStorageCache,\n  createFallbackableCache,\n  createMemoryCache,\n  createNullLogger,\n  DEFAULT_CONNECT_TIMEOUT_BROWSER,\n  DEFAULT_READ_TIMEOUT_BROWSER,\n  DEFAULT_WRITE_TIMEOUT_BROWSER,\n} from '@algolia/client-common';\n\nimport { apiClientVersion, createLiteClient } from '../src/liteClient';\n\nexport * from '../model';\nexport { apiClientVersion } from '../src/liteClient';\n\nexport function liteClient(appId: string, apiKey: string, options?: ClientOptions): LiteClient {\n  if (!appId || typeof appId !== 'string') {\n    throw new Error('`appId` is missing.');\n  }\n\n  if (!apiKey || typeof apiKey !== 'string') {\n    throw new Error('`apiKey` is missing.');\n  }\n\n  return createLiteClient({\n    appId,\n    apiKey,\n    timeouts: {\n      connect: DEFAULT_CONNECT_TIMEOUT_BROWSER,\n      read: DEFAULT_READ_TIMEOUT_BROWSER,\n      write: DEFAULT_WRITE_TIMEOUT_BROWSER,\n    },\n    logger: createNullLogger(),\n    requester: createXhrRequester(),\n    algoliaAgents: [{ segment: 'Browser' }],\n    authMode: 'WithinQueryParameters',\n    responsesCache: createMemoryCache(),\n    requestsCache: createMemoryCache({ serializable: false }),\n    hostsCache: createFallbackableCache({\n      caches: [createBrowserLocalStorageCache({ key: `${apiClientVersion}-${appId}` }), createMemoryCache()],\n    }),\n    ...options,\n  });\n}\n\nexport type LiteClient = ReturnType<typeof createLiteClient>;\n","// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.\n\nimport type {\n  CreateClientOptions,\n  Headers,\n  Host,\n  QueryParameters,\n  Request,\n  RequestOptions,\n} from '@algolia/client-common';\nimport { createAuth, createTransporter, getAlgoliaAgent, shuffle } from '@algolia/client-common';\n\nimport type { GetRecommendationsParams } from '../model/getRecommendationsParams';\nimport type { GetRecommendationsResponse } from '../model/getRecommendationsResponse';\nimport type { SearchMethodParams } from '../model/searchMethodParams';\nimport type { SearchResponses } from '../model/searchResponses';\n\nimport type {\n  CustomPostProps,\n  LegacyGetRecommendationsParams,\n  LegacySearchMethodProps,\n} from '../model/clientMethodProps';\n\nimport type { SearchForFacetValuesResponse } from '../model/searchForFacetValuesResponse';\nimport type { SearchResponse } from '../model/searchResponse';\n\nexport const apiClientVersion = '5.9.1';\n\nfunction getDefaultHosts(appId: string): Host[] {\n  return (\n    [\n      {\n        url: `${appId}-dsn.algolia.net`,\n        accept: 'read',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}.algolia.net`,\n        accept: 'write',\n        protocol: 'https',\n      },\n    ] as Host[]\n  ).concat(\n    shuffle([\n      {\n        url: `${appId}-1.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}-2.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}-3.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n    ]),\n  );\n}\n\nexport function createLiteClient({\n  appId: appIdOption,\n  apiKey: apiKeyOption,\n  authMode,\n  algoliaAgents,\n  ...options\n}: CreateClientOptions) {\n  const auth = createAuth(appIdOption, apiKeyOption, authMode);\n  const transporter = createTransporter({\n    hosts: getDefaultHosts(appIdOption),\n    ...options,\n    algoliaAgent: getAlgoliaAgent({\n      algoliaAgents,\n      client: 'Lite',\n      version: apiClientVersion,\n    }),\n    baseHeaders: {\n      'content-type': 'text/plain',\n      ...auth.headers(),\n      ...options.baseHeaders,\n    },\n    baseQueryParameters: {\n      ...auth.queryParameters(),\n      ...options.baseQueryParameters,\n    },\n  });\n\n  return {\n    transporter,\n\n    /**\n     * The `appId` currently in use.\n     */\n    appId: appIdOption,\n\n    /**\n     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.\n     */\n    clearCache(): Promise<void> {\n      return Promise.all([transporter.requestsCache.clear(), transporter.responsesCache.clear()]).then(() => undefined);\n    },\n\n    /**\n     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.\n     */\n    get _ua(): string {\n      return transporter.algoliaAgent.value;\n    },\n\n    /**\n     * Adds a `segment` to the `x-algolia-agent` sent with every requests.\n     *\n     * @param segment - The algolia agent (user-agent) segment to add.\n     * @param version - The version of the agent.\n     */\n    addAlgoliaAgent(segment: string, version?: string): void {\n      transporter.algoliaAgent.add({ segment, version });\n    },\n\n    /**\n     * Helper method to switch the API key used to authenticate the requests.\n     *\n     * @param params - Method params.\n     * @param params.apiKey - The new API Key to use.\n     */\n    setClientApiKey({ apiKey }: { apiKey: string }): void {\n      if (!authMode || authMode === 'WithinHeaders') {\n        transporter.baseHeaders['x-algolia-api-key'] = apiKey;\n      } else {\n        transporter.baseQueryParameters['x-algolia-api-key'] = apiKey;\n      }\n    },\n\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `hits`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForHits<T>(\n      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,\n      requestOptions?: RequestOptions,\n    ): Promise<{ results: Array<SearchResponse<T>> }> {\n      return this.search(searchMethodParams, requestOptions) as Promise<{ results: Array<SearchResponse<T>> }>;\n    },\n\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `facets`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForFacets(\n      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,\n      requestOptions?: RequestOptions,\n    ): Promise<{ results: Array<SearchForFacetValuesResponse> }> {\n      return this.search(searchMethodParams, requestOptions) as Promise<{\n        results: Array<SearchForFacetValuesResponse>;\n      }>;\n    },\n    /**\n     * This method allow you to send requests to the Algolia REST API.\n     * @param customPost - The customPost object.\n     * @param customPost.path - Path of the endpoint, anything after \\\"/1\\\" must be specified.\n     * @param customPost.parameters - Query parameters to apply to the current query.\n     * @param customPost.body - Parameters to send with the custom request.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    customPost(\n      { path, parameters, body }: CustomPostProps,\n      requestOptions?: RequestOptions,\n    ): Promise<Record<string, unknown>> {\n      if (!path) {\n        throw new Error('Parameter `path` is required when calling `customPost`.');\n      }\n\n      const requestPath = '/{path}'.replace('{path}', path);\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = parameters ? parameters : {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: body ? body : {},\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n\n    /**\n     * Retrieves recommendations from selected AI models.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param getRecommendationsParams - The getRecommendationsParams object.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    getRecommendations(\n      getRecommendationsParams: GetRecommendationsParams | LegacyGetRecommendationsParams,\n      requestOptions?: RequestOptions,\n    ): Promise<GetRecommendationsResponse> {\n      if (getRecommendationsParams && Array.isArray(getRecommendationsParams)) {\n        const newSignatureRequest: GetRecommendationsParams = {\n          requests: getRecommendationsParams,\n        };\n\n        getRecommendationsParams = newSignatureRequest;\n      }\n\n      if (!getRecommendationsParams) {\n        throw new Error('Parameter `getRecommendationsParams` is required when calling `getRecommendations`.');\n      }\n\n      if (!getRecommendationsParams.requests) {\n        throw new Error('Parameter `getRecommendationsParams.requests` is required when calling `getRecommendations`.');\n      }\n\n      const requestPath = '/1/indexes/*/recommendations';\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: getRecommendationsParams,\n        useReadTransporter: true,\n        cacheable: true,\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n\n    /**\n     * Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same index—for example, with different filters.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param searchMethodParams - Muli-search request body. Results are returned in the same order as the requests.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    search<T>(\n      searchMethodParams: SearchMethodParams | LegacySearchMethodProps,\n      requestOptions?: RequestOptions,\n    ): Promise<SearchResponses<T>> {\n      if (searchMethodParams && Array.isArray(searchMethodParams)) {\n        const newSignatureRequest: SearchMethodParams = {\n          requests: searchMethodParams.map(({ params, ...legacyRequest }) => {\n            if (legacyRequest.type === 'facet') {\n              return {\n                ...legacyRequest,\n                ...params,\n                type: 'facet',\n              };\n            }\n\n            return {\n              ...legacyRequest,\n              ...params,\n              facet: undefined,\n              maxFacetHits: undefined,\n              facetQuery: undefined,\n            };\n          }),\n        };\n\n        searchMethodParams = newSignatureRequest;\n      }\n\n      if (!searchMethodParams) {\n        throw new Error('Parameter `searchMethodParams` is required when calling `search`.');\n      }\n\n      if (!searchMethodParams.requests) {\n        throw new Error('Parameter `searchMethodParams.requests` is required when calling `search`.');\n      }\n\n      const requestPath = '/1/indexes/*/queries';\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: searchMethodParams,\n        useReadTransporter: true,\n        cacheable: true,\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}