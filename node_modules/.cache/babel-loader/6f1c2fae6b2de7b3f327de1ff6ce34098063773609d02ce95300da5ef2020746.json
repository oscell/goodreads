{"ast":null,"code":"import { useState as $bc4N1$useState, useMemo as $bc4N1$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys: initialSelectedKeys,\n    getKey = item => {\n      var _item_id;\n      return (_item_id = item.id) !== null && _item_id !== void 0 ? _item_id : item.key;\n    },\n    filter: filter,\n    initialFilterText = ''\n  } = options;\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = (0, $bc4N1$useState)({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n  let filteredItems = (0, $bc4N1$useMemo)(() => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items, [state.items, state.filterText, filter]);\n  return {\n    ...state,\n    items: filteredItems,\n    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n      getKey: getKey\n    }, setState),\n    getItem(key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  let {\n    cursor: cursor,\n    getKey: getKey\n  } = opts;\n  return {\n    setSelectedKeys(selectedKeys) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys: selectedKeys\n      }));\n    },\n    setFilterText(filterText) {\n      dispatch(state => ({\n        ...state,\n        filterText: filterText\n      }));\n    },\n    insert(index, ...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, index, ...values));\n    },\n    insertBefore(key, ...values) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) index = 0;else return state;\n        }\n        return $0d86e9c8f07f9a7b$var$insert(state, index, ...values);\n      });\n    },\n    insertAfter(key, ...values) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) index = 0;else return state;\n        }\n        return $0d86e9c8f07f9a7b$var$insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, 0, ...values));\n    },\n    append(...values) {\n      dispatch(state => $0d86e9c8f07f9a7b$var$insert(state, state.items.length, ...values));\n    },\n    remove(...keys) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n        let selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) selection.delete(key);\n        }\n        if (cursor == null && items.length === 0) selection = new Set();\n        return {\n          ...state,\n          items: items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') return {\n          ...state,\n          items: [],\n          selectedKeys: new Set()\n        };\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items: items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key, toIndex) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) return state;\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key, keys) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) return state;\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update(key, newValue) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) return state;\n        return {\n          ...state,\n          items: [...state.items.slice(0, index), newValue, ...state.items.slice(index + 1)]\n        };\n      });\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index, ...values) {\n  return {\n    ...state,\n    items: [...state.items.slice(0, index), ...values, ...state.items.slice(index)]\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  // Shift the target down by the number of items being moved from before the target\n  toIndex -= indices.filter(index => index < toIndex).length;\n  let moves = indices.map(from => ({\n    from: from,\n    to: toIndex++\n  }));\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n      if (b.from < a.to) a.to++;else b.from++;\n    }\n  }\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n  return {\n    ...state,\n    items: copy\n  };\n}\nexport { $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a as createListActions };","map":{"version":3,"names":["$0d86e9c8f07f9a7b$export$762f73dccccd255d","options","initialItems","initialSelectedKeys","getKey","item","_item_id","id","key","filter","initialFilterText","state","setState","$bc4N1$useState","items","selectedKeys","Set","filterText","filteredItems","$bc4N1$useMemo","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","getItem","find","opts","dispatch","cursor","setSelectedKeys","setFilterText","insert","index","values","$0d86e9c8f07f9a7b$var$insert","insertBefore","findIndex","length","insertAfter","prepend","append","remove","keys","keySet","has","selection","delete","removeSelectedItems","move","toIndex","copy","slice","splice","moveBefore","keyArray","Array","isArray","indices","map","sort","a","b","$0d86e9c8f07f9a7b$var$move","moveAfter","update","newValue","moves","from","to","i","j"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useListData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, Selection} from '@react-types/shared';\nimport {useMemo, useState} from 'react';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id ?? item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  toIndex -= indices.filter(index => index < toIndex).length;\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}