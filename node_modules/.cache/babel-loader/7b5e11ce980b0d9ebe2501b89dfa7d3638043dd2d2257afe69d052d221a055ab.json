{"ast":null,"code":"import { getInitialResults, waitForResults } from \"instantsearch.js/es/lib/server.js\";\nimport { walkIndex, resetWidgetId } from \"instantsearch.js/es/lib/utils/index.js\";\nimport React from 'react';\nimport { InstantSearchServerContext } from \"../components/InstantSearchServerContext.js\";\nimport { InstantSearchSSRProvider } from \"../components/InstantSearchSSRProvider.js\";\n/**\n * Returns the InstantSearch server state from a component.\n */\nexport function getServerState(children, _ref) {\n  var renderToString = _ref.renderToString;\n  var searchRef = {\n    current: undefined\n  };\n  resetWidgetId();\n  var createNotifyServer = function createNotifyServer() {\n    var hasBeenNotified = false;\n    var notifyServer = function notifyServer(_ref2) {\n      var search = _ref2.search;\n      if (hasBeenNotified) {\n        throw new Error('getServerState should be called with a single InstantSearchSSRProvider and a single InstantSearch component.');\n      }\n      hasBeenNotified = true;\n      searchRef.current = search;\n    };\n    return notifyServer;\n  };\n  return execute({\n    children: children,\n    renderToString: renderToString,\n    searchRef: searchRef,\n    notifyServer: createNotifyServer()\n  }).then(function (serverState) {\n    var shouldRefetch = false;\n\n    // <DynamicWidgets> requires another query to retrieve the dynamic widgets\n    // to render.\n    walkIndex(searchRef.current.mainIndex, function (index) {\n      shouldRefetch = shouldRefetch || index.getWidgets().some(function (widget) {\n        return widget.$$type === 'ais.dynamicWidgets';\n      });\n    });\n    if (shouldRefetch) {\n      resetWidgetId();\n      return execute({\n        children: /*#__PURE__*/React.createElement(InstantSearchSSRProvider, serverState, children),\n        renderToString: renderToString,\n        searchRef: searchRef,\n        notifyServer: createNotifyServer(),\n        skipRecommend: true\n      });\n    }\n    return serverState;\n  });\n}\nfunction execute(_ref3) {\n  var children = _ref3.children,\n    renderToString = _ref3.renderToString,\n    notifyServer = _ref3.notifyServer,\n    searchRef = _ref3.searchRef,\n    skipRecommend = _ref3.skipRecommend;\n  return Promise.resolve().then(function () {\n    renderToString(/*#__PURE__*/React.createElement(InstantSearchServerContext.Provider, {\n      value: {\n        notifyServer: notifyServer\n      }\n    }, children));\n  }).then(function () {\n    return (\n      // We wait for the component to mount so that `notifyServer()` is called.\n      new Promise(function (resolve) {\n        return setTimeout(resolve, 0);\n      })\n    );\n  }).then(function () {\n    // If `notifyServer()` is not called by then, it means that <InstantSearch>\n    // wasn't within the `children`.\n    // We decide to go with a strict behavior in that case; throwing. If users have\n    // some routes that don't mount the <InstantSearch> component, they would need\n    // to try/catch the `getServerState()` call.\n    // If this behavior turns out to be too strict for many users, we can decide\n    // to warn instead of throwing.\n    if (!searchRef.current) {\n      throw new Error(\"Unable to retrieve InstantSearch's server state in `getServerState()`. Did you mount the <InstantSearch> component?\");\n    }\n    return waitForResults(searchRef.current, skipRecommend);\n  }).then(function (requestParamsList) {\n    return {\n      initialResults: getInitialResults(searchRef.current.mainIndex, requestParamsList)\n    };\n  });\n}","map":{"version":3,"names":["getInitialResults","waitForResults","walkIndex","resetWidgetId","React","InstantSearchServerContext","InstantSearchSSRProvider","getServerState","children","_ref","renderToString","searchRef","current","undefined","createNotifyServer","hasBeenNotified","notifyServer","_ref2","search","Error","execute","then","serverState","shouldRefetch","mainIndex","index","getWidgets","some","widget","$$type","createElement","skipRecommend","_ref3","Promise","resolve","Provider","value","setTimeout","requestParamsList","initialResults"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/react-instantsearch-core/dist/es/server/getServerState.js"],"sourcesContent":["import { getInitialResults, waitForResults } from \"instantsearch.js/es/lib/server.js\";\nimport { walkIndex, resetWidgetId } from \"instantsearch.js/es/lib/utils/index.js\";\nimport React from 'react';\nimport { InstantSearchServerContext } from \"../components/InstantSearchServerContext.js\";\nimport { InstantSearchSSRProvider } from \"../components/InstantSearchSSRProvider.js\";\n/**\n * Returns the InstantSearch server state from a component.\n */\nexport function getServerState(children, _ref) {\n  var renderToString = _ref.renderToString;\n  var searchRef = {\n    current: undefined\n  };\n  resetWidgetId();\n  var createNotifyServer = function createNotifyServer() {\n    var hasBeenNotified = false;\n    var notifyServer = function notifyServer(_ref2) {\n      var search = _ref2.search;\n      if (hasBeenNotified) {\n        throw new Error('getServerState should be called with a single InstantSearchSSRProvider and a single InstantSearch component.');\n      }\n      hasBeenNotified = true;\n      searchRef.current = search;\n    };\n    return notifyServer;\n  };\n  return execute({\n    children: children,\n    renderToString: renderToString,\n    searchRef: searchRef,\n    notifyServer: createNotifyServer()\n  }).then(function (serverState) {\n    var shouldRefetch = false;\n\n    // <DynamicWidgets> requires another query to retrieve the dynamic widgets\n    // to render.\n    walkIndex(searchRef.current.mainIndex, function (index) {\n      shouldRefetch = shouldRefetch || index.getWidgets().some(function (widget) {\n        return widget.$$type === 'ais.dynamicWidgets';\n      });\n    });\n    if (shouldRefetch) {\n      resetWidgetId();\n      return execute({\n        children: /*#__PURE__*/React.createElement(InstantSearchSSRProvider, serverState, children),\n        renderToString: renderToString,\n        searchRef: searchRef,\n        notifyServer: createNotifyServer(),\n        skipRecommend: true\n      });\n    }\n    return serverState;\n  });\n}\nfunction execute(_ref3) {\n  var children = _ref3.children,\n    renderToString = _ref3.renderToString,\n    notifyServer = _ref3.notifyServer,\n    searchRef = _ref3.searchRef,\n    skipRecommend = _ref3.skipRecommend;\n  return Promise.resolve().then(function () {\n    renderToString( /*#__PURE__*/React.createElement(InstantSearchServerContext.Provider, {\n      value: {\n        notifyServer: notifyServer\n      }\n    }, children));\n  }).then(function () {\n    return (\n      // We wait for the component to mount so that `notifyServer()` is called.\n      new Promise(function (resolve) {\n        return setTimeout(resolve, 0);\n      })\n    );\n  }).then(function () {\n    // If `notifyServer()` is not called by then, it means that <InstantSearch>\n    // wasn't within the `children`.\n    // We decide to go with a strict behavior in that case; throwing. If users have\n    // some routes that don't mount the <InstantSearch> component, they would need\n    // to try/catch the `getServerState()` call.\n    // If this behavior turns out to be too strict for many users, we can decide\n    // to warn instead of throwing.\n    if (!searchRef.current) {\n      throw new Error(\"Unable to retrieve InstantSearch's server state in `getServerState()`. Did you mount the <InstantSearch> component?\");\n    }\n    return waitForResults(searchRef.current, skipRecommend);\n  }).then(function (requestParamsList) {\n    return {\n      initialResults: getInitialResults(searchRef.current.mainIndex, requestParamsList)\n    };\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}