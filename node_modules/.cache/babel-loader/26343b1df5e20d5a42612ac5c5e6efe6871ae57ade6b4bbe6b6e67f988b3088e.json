{"ast":null,"code":"import { isSetEqual as $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64 } from \"./utils.mjs\";\nimport { OverscanManager as $364191b3decf3697$export$4455ee6afb38dcbb } from \"./OverscanManager.mjs\";\nimport { Rect as $60423f92c7f9ad87$export$c79fc6492f3af13d } from \"./Rect.mjs\";\nimport { ReusableView as $ad1d98aa8f0c31b4$export$1a5223887c560441 } from \"./ReusableView.mjs\";\nimport { Size as $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec } from \"./Size.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  /** Returns whether the given key, or an ancestor, is persisted. */isPersistedKey(key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this.persistedKeys.has(key)) return true;\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this.persistedKeys) while (k != null) {\n      let layoutInfo = this.layout.getLayoutInfo(k);\n      if (!layoutInfo) break;\n      k = layoutInfo.parentKey;\n      if (k === key) return true;\n    }\n    return false;\n  }\n  getParentView(layoutInfo) {\n    return layoutInfo.parentKey != null ? this._visibleViews.get(layoutInfo.parentKey) : this._rootView;\n  }\n  getReusableView(layoutInfo) {\n    let parentView = this.getParentView(layoutInfo);\n    let view = parentView.getReusableView(layoutInfo.type);\n    view.layoutInfo = layoutInfo;\n    this._renderView(view);\n    return view;\n  }\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key,\n      content: content\n    } = reusableView.layoutInfo;\n    reusableView.content = content || this.collection.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n  keyAtPoint(point) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n    let layoutInfos = rect.area === 0 ? [] : this.layout.getVisibleLayoutInfos(rect);\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n    }\n    return null;\n  }\n  relayout(context = {}) {\n    // Update the layout\n    this.layout.update(context);\n    this.contentSize = this.layout.getContentSize();\n    // Constrain scroll position.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.visibleRect;\n    let contentOffsetX = context.contentChanged ? 0 : visibleRect.x;\n    let contentOffsetY = context.contentChanged ? 0 : visibleRect.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If the offset changed, trigger a new re-render.\n      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(contentOffsetX, contentOffsetY, visibleRect.width, visibleRect.height);\n      this.delegate.setVisibleRect(rect);\n    } else this.updateSubviews();\n  }\n  getVisibleLayoutInfos() {\n    let isTestEnv = false;\n    let isClientWidthMocked = isTestEnv && typeof HTMLElement !== 'undefined' && Object.getOwnPropertyNames(HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = isTestEnv && typeof HTMLElement !== 'undefined' && Object.getOwnPropertyNames(HTMLElement.prototype).includes('clientHeight');\n    let rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);else rect = this._overscanManager.getOverscannedRect();\n    let layoutInfos = rect.area === 0 ? [] : this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n    for (let layoutInfo of layoutInfos) map.set(layoutInfo.key, layoutInfo);\n    return map;\n  }\n  updateSubviews() {\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let removed = new Set();\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      // If a view's parent changed, treat it as a delete and re-create in the new parent.\n      if (!layoutInfo || view.parent !== this.getParentView(layoutInfo)) {\n        this._visibleViews.delete(key);\n        view.parent.reuseChild(view);\n        removed.add(view); // Defer removing in case we reuse this view.\n      }\n    }\n    for (let [key, layoutInfo] of visibleLayoutInfos) {\n      let view = this._visibleViews.get(key);\n      if (!view) {\n        view = this.getReusableView(layoutInfo);\n        view.parent.children.add(view);\n        this._visibleViews.set(key, view);\n        removed.delete(view);\n      } else {\n        view.layoutInfo = layoutInfo;\n        let item = this.collection.getItem(layoutInfo.key);\n        if (view.content !== item) {\n          this._renderedContent.delete(view.content);\n          this._renderView(view);\n        }\n      }\n    }\n    // The remaining views in `removed` were not reused to render new items.\n    // They should be removed from the DOM. We also clear the reusable view queue\n    // here since there's no point holding onto views that have been removed.\n    // Doing so hurts performance in the future when reusing elements due to FIFO order.\n    for (let view of removed) {\n      view.parent.children.delete(view);\n      view.parent.reusableViews.clear();\n    }\n    // Reordering DOM nodes is costly, so we defer this until scrolling stops.\n    // DOM order does not affect visual order (due to absolute positioning),\n    // but does matter for assistive technology users.\n    if (!this._isScrolling)\n      // Layout infos must be in topological order (parents before children).\n      for (let key of visibleLayoutInfos.keys()) {\n        let view = this._visibleViews.get(key);\n        view.parent.children.delete(view);\n        view.parent.children.add(view);\n      }\n  }\n  /** Performs layout and updates visible views as needed. */\n  render(opts) {\n    let mutableThis = this;\n    let needsLayout = false;\n    let offsetChanged = false;\n    let sizeChanged = false;\n    let itemSizeChanged = false;\n    let needsUpdate = false;\n    if (opts.collection !== this.collection) {\n      mutableThis.collection = opts.collection;\n      needsLayout = true;\n    }\n    if (opts.layout !== this.layout) {\n      if (this.layout) this.layout.virtualizer = null;\n      opts.layout.virtualizer = this;\n      mutableThis.layout = opts.layout;\n      needsLayout = true;\n    }\n    if (opts.persistedKeys && !(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(opts.persistedKeys, this.persistedKeys)) {\n      mutableThis.persistedKeys = opts.persistedKeys;\n      needsUpdate = true;\n    }\n    if (!this.visibleRect.equals(opts.visibleRect)) {\n      this._overscanManager.setVisibleRect(opts.visibleRect);\n      let shouldInvalidate = this.layout.shouldInvalidate(opts.visibleRect, this.visibleRect);\n      if (shouldInvalidate) {\n        offsetChanged = !opts.visibleRect.pointEquals(this.visibleRect);\n        sizeChanged = !opts.visibleRect.sizeEquals(this.visibleRect);\n        needsLayout = true;\n      } else needsUpdate = true;\n      mutableThis.visibleRect = opts.visibleRect;\n    }\n    if (opts.invalidationContext !== this._invalidationContext) {\n      if (opts.invalidationContext) {\n        sizeChanged || (sizeChanged = opts.invalidationContext.sizeChanged || false);\n        offsetChanged || (offsetChanged = opts.invalidationContext.offsetChanged || false);\n        itemSizeChanged || (itemSizeChanged = opts.invalidationContext.itemSizeChanged || false);\n        needsLayout || (needsLayout = itemSizeChanged || sizeChanged || offsetChanged);\n        needsLayout || (needsLayout = opts.invalidationContext.layoutOptions !== this._invalidationContext.layoutOptions);\n      }\n      this._invalidationContext = opts.invalidationContext;\n    }\n    if (opts.isScrolling !== this._isScrolling) {\n      this._isScrolling = opts.isScrolling;\n      if (!opts.isScrolling)\n        // Update to fix the DOM order after scrolling.\n        needsUpdate = true;\n    }\n    if (needsLayout) this.relayout({\n      offsetChanged: offsetChanged,\n      sizeChanged: sizeChanged,\n      itemSizeChanged: itemSizeChanged,\n      layoutOptions: this._invalidationContext.layoutOptions\n    });else if (needsUpdate) this.updateSubviews();\n    return Array.from(this._rootView.children);\n  }\n  getVisibleView(key) {\n    return this._visibleViews.get(key);\n  }\n  invalidate(context) {\n    this.delegate.invalidate(context);\n  }\n  updateItemSize(key, size) {\n    if (!this.layout.updateItemSize) return;\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.invalidate({\n      itemSizeChanged: true\n    });\n  }\n  constructor(delegate) {\n    this.delegate = delegate;\n    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();\n    this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    this.persistedKeys = new Set();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._rootView = new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n    this._isScrolling = false;\n    this._invalidationContext = null;\n    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n  }\n}\nexport { $38b9490c1cca8fc4$export$89be5a243e59c4b2 as Virtualizer };","map":{"version":3,"names":["$38b9490c1cca8fc4$export$89be5a243e59c4b2","isPersistedKey","key","persistedKeys","has","k","layoutInfo","layout","getLayoutInfo","parentKey","getParentView","_visibleViews","get","_rootView","getReusableView","parentView","view","type","_renderView","reusableView","content","collection","getItem","rendered","_renderContent","cached","_renderedContent","delegate","renderView","set","keyAtPoint","point","rect","$60423f92c7f9ad87$export$c79fc6492f3af13d","x","y","layoutInfos","area","getVisibleLayoutInfos","intersects","relayout","context","update","contentSize","getContentSize","visibleRect","contentOffsetX","contentChanged","contentOffsetY","Math","max","min","width","height","setVisibleRect","updateSubviews","isTestEnv","isClientWidthMocked","HTMLElement","Object","getOwnPropertyNames","prototype","includes","isClientHeightMocked","_overscanManager","getOverscannedRect","map","Map","visibleLayoutInfos","removed","Set","parent","delete","reuseChild","add","children","item","reusableViews","clear","_isScrolling","keys","render","opts","mutableThis","needsLayout","offsetChanged","sizeChanged","itemSizeChanged","needsUpdate","virtualizer","$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64","equals","shouldInvalidate","pointEquals","sizeEquals","invalidationContext","_invalidationContext","layoutOptions","isScrolling","Array","from","getVisibleView","invalidate","updateItemSize","size","changed","constructor","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","WeakMap","$ad1d98aa8f0c31b4$export$1a5223887c560441","$364191b3decf3697$export$4455ee6afb38dcbb"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Virtualizer.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Key} from '@react-types/shared';\nimport {InvalidationContext, Mutable, VirtualizerDelegate, VirtualizerRenderOptions} from './types';\nimport {isSetEqual} from './utils';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\n\n/**\n * The Virtualizer class renders a scrollable collection of data using customizable layouts.\n * It supports very large collections by only rendering visible views to the DOM, reusing\n * them as you scroll. Virtualizer can present any type of view, including non-item views\n * such as section headers and footers.\n *\n * Virtualizer uses {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that virtualizer can have its items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well.\n *\n * Layouts produce information on what views should appear in the virtualizer, but do not create\n * the views themselves directly. It is the responsibility of the {@link VirtualizerDelegate} object\n * to render elements for each layout info. The virtualizer manages a set of {@link ReusableView} objects,\n * which are reused as the user scrolls by swapping their content with cached elements returned by the delegate.\n */\nexport class Virtualizer<T extends object, V> {\n  /**\n   * The virtualizer delegate. The delegate is used by the virtualizer\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V>;\n\n  /** The current content of the virtualizer. */\n  readonly collection: Collection<T>;\n  /** The layout object that determines the visible views. */\n  readonly layout: Layout<T>;\n  /** The size of the scrollable content. */\n  readonly contentSize: Size;\n  /** The currently visible rectangle. */\n  readonly visibleRect: Rect;\n  /** The set of persisted keys that are always present in the DOM, even if not currently in view. */\n  readonly persistedKeys: Set<Key>;\n\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _rootView: ReusableView<T, V>;\n  private _isScrolling: boolean;\n  private _invalidationContext: InvalidationContext | null;\n  private _overscanManager: OverscanManager;\n\n  constructor(delegate: VirtualizerDelegate<T, V>) {\n    this.delegate = delegate;\n    this.contentSize = new Size;\n    this.visibleRect = new Rect;\n    this.persistedKeys = new Set();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._rootView = new ReusableView(this);\n    this._isScrolling = false;\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this.persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this.persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private getParentView(layoutInfo: LayoutInfo): ReusableView<T, V> | undefined {\n    return layoutInfo.parentKey != null ? this._visibleViews.get(layoutInfo.parentKey) : this._rootView;\n  }\n\n  private getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let parentView = this.getParentView(layoutInfo)!;\n    let view = parentView.getReusableView(layoutInfo.type);\n    view.layoutInfo = layoutInfo;\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key, content} = reusableView.layoutInfo;\n    reusableView.content = content || this.collection.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = rect.area === 0 ? [] : this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  private relayout(context: InvalidationContext = {}) {\n    // Update the layout\n    this.layout.update(context);\n    (this as Mutable<this>).contentSize = this.layout.getContentSize();\n\n    // Constrain scroll position.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.visibleRect;\n    let contentOffsetX = context.contentChanged ? 0 : visibleRect.x;\n    let contentOffsetY = context.contentChanged ? 0 : visibleRect.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If the offset changed, trigger a new re-render.\n      let rect = new Rect(contentOffsetX, contentOffsetY, visibleRect.width, visibleRect.height);\n      this.delegate.setVisibleRect(rect);\n    } else {\n      this.updateSubviews();\n    }\n  }\n\n  getVisibleLayoutInfos() {\n    let isTestEnv = process.env.NODE_ENV === 'test' && !process.env.VIRT_ON;\n    let isClientWidthMocked = isTestEnv && typeof HTMLElement !== 'undefined' && Object.getOwnPropertyNames(HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = isTestEnv && typeof HTMLElement !== 'undefined' && Object.getOwnPropertyNames(HTMLElement.prototype).includes('clientHeight');\n\n    let rect: Rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) {\n      rect = new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n    } else {\n      rect = this._overscanManager.getOverscannedRect();\n    }\n\n    let layoutInfos = rect.area === 0 ? [] : this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n    for (let layoutInfo of layoutInfos) {\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  private updateSubviews() {\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n\n    let removed = new Set<ReusableView<T, V>>();\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      // If a view's parent changed, treat it as a delete and re-create in the new parent.\n      if (!layoutInfo || view.parent !== this.getParentView(layoutInfo)) {\n        this._visibleViews.delete(key);\n        view.parent.reuseChild(view);\n        removed.add(view); // Defer removing in case we reuse this view.\n      }\n    }\n\n    for (let [key, layoutInfo] of visibleLayoutInfos) {\n      let view = this._visibleViews.get(key);\n      if (!view) {\n        view = this.getReusableView(layoutInfo);\n        view.parent.children.add(view);\n        this._visibleViews.set(key, view);\n        removed.delete(view);\n      } else {\n        view.layoutInfo = layoutInfo;\n\n        let item = this.collection.getItem(layoutInfo.key);\n        if (view.content !== item) {\n          this._renderedContent.delete(view.content);\n          this._renderView(view);\n        }\n      }\n    }\n\n    // The remaining views in `removed` were not reused to render new items.\n    // They should be removed from the DOM. We also clear the reusable view queue\n    // here since there's no point holding onto views that have been removed.\n    // Doing so hurts performance in the future when reusing elements due to FIFO order.\n    for (let view of removed) {\n      view.parent.children.delete(view);\n      view.parent.reusableViews.clear();\n    }\n\n    // Reordering DOM nodes is costly, so we defer this until scrolling stops.\n    // DOM order does not affect visual order (due to absolute positioning),\n    // but does matter for assistive technology users.\n    if (!this._isScrolling) {\n      // Layout infos must be in topological order (parents before children).\n      for (let key of visibleLayoutInfos.keys()) {\n        let view = this._visibleViews.get(key)!;\n        view.parent.children.delete(view);\n        view.parent.children.add(view);\n      }\n    }\n  }\n\n  /** Performs layout and updates visible views as needed. */\n  render(opts: VirtualizerRenderOptions<T>): ReusableView<T, V>[] {\n    let mutableThis: Mutable<this> = this;\n    let needsLayout = false;\n    let offsetChanged = false;\n    let sizeChanged = false;\n    let itemSizeChanged = false;\n    let needsUpdate = false;\n\n    if (opts.collection !== this.collection) {\n      mutableThis.collection = opts.collection;\n      needsLayout = true;\n    }\n\n    if (opts.layout !== this.layout) {\n      if (this.layout) {\n        this.layout.virtualizer = null;\n      }\n\n      opts.layout.virtualizer = this;\n      mutableThis.layout = opts.layout;\n      needsLayout = true;\n    }\n\n    if (opts.persistedKeys && !isSetEqual(opts.persistedKeys, this.persistedKeys)) {\n      mutableThis.persistedKeys = opts.persistedKeys;\n      needsUpdate = true;\n    }\n\n    if (!this.visibleRect.equals(opts.visibleRect)) {\n      this._overscanManager.setVisibleRect(opts.visibleRect);\n      let shouldInvalidate = this.layout.shouldInvalidate(opts.visibleRect, this.visibleRect);\n\n      if (shouldInvalidate) {\n        offsetChanged = !opts.visibleRect.pointEquals(this.visibleRect);\n        sizeChanged = !opts.visibleRect.sizeEquals(this.visibleRect);\n        needsLayout = true;\n      } else {\n        needsUpdate = true;\n      }\n\n      mutableThis.visibleRect = opts.visibleRect;\n    }\n\n    if (opts.invalidationContext !== this._invalidationContext) {\n      if (opts.invalidationContext) {\n        sizeChanged ||= opts.invalidationContext.sizeChanged || false;\n        offsetChanged ||= opts.invalidationContext.offsetChanged || false;\n        itemSizeChanged ||= opts.invalidationContext.itemSizeChanged || false;\n        needsLayout ||= itemSizeChanged || sizeChanged || offsetChanged;\n        needsLayout ||= opts.invalidationContext.layoutOptions !== this._invalidationContext.layoutOptions;\n      }\n      this._invalidationContext = opts.invalidationContext;\n    }\n\n    if (opts.isScrolling !== this._isScrolling) {\n      this._isScrolling = opts.isScrolling;\n      if (!opts.isScrolling) {\n        // Update to fix the DOM order after scrolling.\n        needsUpdate = true;\n      }\n    }\n\n    if (needsLayout) {\n      this.relayout({\n        offsetChanged,\n        sizeChanged,\n        itemSizeChanged,\n        layoutOptions: this._invalidationContext.layoutOptions\n      });\n    } else if (needsUpdate) {\n      this.updateSubviews();\n    }\n\n    return Array.from(this._rootView.children);\n  }\n\n  getVisibleView(key: Key): ReusableView<T, V> | undefined {\n    return this._visibleViews.get(key);\n  }\n\n  invalidate(context: InvalidationContext) {\n    this.delegate.invalidate(context);\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.invalidate({\n        itemSizeChanged: true\n      });\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}