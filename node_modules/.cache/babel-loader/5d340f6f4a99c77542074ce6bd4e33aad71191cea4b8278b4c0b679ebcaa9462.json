{"ast":null,"code":"import { createPortal as $8SdCi$createPortal } from \"react-dom\";\nimport $8SdCi$react, { createContext as $8SdCi$createContext, useContext as $8SdCi$useContext, forwardRef as $8SdCi$forwardRef } from \"react\";\nimport { useIsSSR as $8SdCi$useIsSSR } from \"@react-aria/ssr\";\n\n/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// React doesn't understand the <template> element, which doesn't have children like a normal element.\n// It will throw an error during hydration when it expects the firstChild to contain content rendered\n// on the server, when in reality, the browser will have placed this inside the `content` document fragment.\n// This monkey patches the firstChild property for our special hidden template elements to work around this error.\n// See https://github.com/facebook/react/issues/19932\nif (typeof HTMLTemplateElement !== 'undefined') {\n  const getFirstChild = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;\n  Object.defineProperty(HTMLTemplateElement.prototype, 'firstChild', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      if (this.dataset.reactAriaHidden) return this.content.firstChild;else return getFirstChild.call(this);\n    }\n  });\n}\nconst $f39a9eba43920ace$export$94b6d0abf7d33e8c = /*#__PURE__*/(0, $8SdCi$createContext)(false);\n// Portal to nowhere\nconst $f39a9eba43920ace$var$hiddenFragment = typeof DocumentFragment !== 'undefined' ? new DocumentFragment() : null;\nfunction $f39a9eba43920ace$export$8dc98ba7eadeaa56(props) {\n  let isHidden = (0, $8SdCi$useContext)($f39a9eba43920ace$export$94b6d0abf7d33e8c);\n  let isSSR = (0, $8SdCi$useIsSSR)();\n  if (isHidden)\n    // Don't hide again if we are already hidden.\n    return /*#__PURE__*/(0, $8SdCi$react).createElement((0, $8SdCi$react).Fragment, null, props.children);\n  let children = /*#__PURE__*/(0, $8SdCi$react).createElement($f39a9eba43920ace$export$94b6d0abf7d33e8c.Provider, {\n    value: true\n  }, props.children);\n  // In SSR, portals are not supported by React. Instead, render into a <template>\n  // element, which the browser will never display to the user. In addition, the\n  // content is not part of the DOM tree, so it won't affect ids or other accessibility attributes.\n  return isSSR ? /*#__PURE__*/(0, $8SdCi$react).createElement(\"template\", {\n    \"data-react-aria-hidden\": true\n  }, children) : /*#__PURE__*/(0, $8SdCi$createPortal)(children, $f39a9eba43920ace$var$hiddenFragment);\n}\nfunction $f39a9eba43920ace$export$86427a43e3e48ebb(fn) {\n  let Wrapper = (props, ref) => {\n    let isHidden = (0, $8SdCi$useContext)($f39a9eba43920ace$export$94b6d0abf7d33e8c);\n    if (isHidden) return null;\n    return fn(props, ref);\n  };\n  // @ts-ignore - for react dev tools\n  Wrapper.displayName = fn.displayName || fn.name;\n  return (0, $8SdCi$forwardRef)(Wrapper);\n}\nfunction $f39a9eba43920ace$export$b5d7cc18bb8d2b59() {\n  return (0, $8SdCi$useContext)($f39a9eba43920ace$export$94b6d0abf7d33e8c);\n}\nexport { $f39a9eba43920ace$export$94b6d0abf7d33e8c as HiddenContext, $f39a9eba43920ace$export$8dc98ba7eadeaa56 as Hidden, $f39a9eba43920ace$export$86427a43e3e48ebb as createHideableComponent, $f39a9eba43920ace$export$b5d7cc18bb8d2b59 as useIsHidden };","map":{"version":3,"names":["HTMLTemplateElement","getFirstChild","Object","getOwnPropertyDescriptor","Node","prototype","get","defineProperty","configurable","enumerable","dataset","reactAriaHidden","content","firstChild","call","$f39a9eba43920ace$export$94b6d0abf7d33e8c","$8SdCi$createContext","$f39a9eba43920ace$var$hiddenFragment","DocumentFragment","$f39a9eba43920ace$export$8dc98ba7eadeaa56","props","isHidden","$8SdCi$useContext","isSSR","$8SdCi$useIsSSR","$8SdCi$react","createElement","Fragment","children","Provider","value","$8SdCi$createPortal","$f39a9eba43920ace$export$86427a43e3e48ebb","fn","Wrapper","ref","displayName","name","$8SdCi$forwardRef","$f39a9eba43920ace$export$b5d7cc18bb8d2b59"],"sources":["/Users/oscar.meunier/Documents/Coding/Personal/final/goodreads/node_modules/@react-aria/collections/dist/packages/@react-aria/collections/src/Hidden.tsx"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createPortal} from 'react-dom';\nimport {forwardRefType} from '@react-types/shared';\nimport React, {createContext, forwardRef, ReactElement, ReactNode, useContext} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\n// React doesn't understand the <template> element, which doesn't have children like a normal element.\n// It will throw an error during hydration when it expects the firstChild to contain content rendered\n// on the server, when in reality, the browser will have placed this inside the `content` document fragment.\n// This monkey patches the firstChild property for our special hidden template elements to work around this error.\n// See https://github.com/facebook/react/issues/19932\nif (typeof HTMLTemplateElement !== 'undefined') {\n  const getFirstChild = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild')!.get!;\n  Object.defineProperty(HTMLTemplateElement.prototype, 'firstChild', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      if (this.dataset.reactAriaHidden) {\n        return this.content.firstChild;\n      } else {\n        return getFirstChild.call(this);\n      }\n    }\n  });\n}\n\nexport const HiddenContext = createContext<boolean>(false);\n\n// Portal to nowhere\nconst hiddenFragment = typeof DocumentFragment !== 'undefined' ? new DocumentFragment() : null;\n\nexport function Hidden(props: {children: ReactNode}) {\n  let isHidden = useContext(HiddenContext);\n  let isSSR = useIsSSR();\n  if (isHidden) {\n    // Don't hide again if we are already hidden.\n    return <>{props.children}</>;\n  }\n\n  let children = (\n    <HiddenContext.Provider value>\n      {props.children}\n    </HiddenContext.Provider>\n  );\n\n  // In SSR, portals are not supported by React. Instead, render into a <template>\n  // element, which the browser will never display to the user. In addition, the\n  // content is not part of the DOM tree, so it won't affect ids or other accessibility attributes.\n  return isSSR\n    ? <template data-react-aria-hidden>{children}</template>\n    : createPortal(children, hiddenFragment!);\n}\n\n/** Creates a component that forwards its ref and returns null if it is in a hidden subtree. */\n// Note: this function is handled specially in the documentation generator. If you change it, you'll need to update DocsTransformer as well.\nexport function createHideableComponent<T, P = {}>(fn: (props: P, ref: React.Ref<T>) => ReactElement | null): (props: P & React.RefAttributes<T>) => ReactElement | null {\n  let Wrapper = (props: P, ref: React.Ref<T>) => {\n    let isHidden = useContext(HiddenContext);\n    if (isHidden) {\n      return null;\n    }\n\n    return fn(props, ref);\n  };\n  // @ts-ignore - for react dev tools\n  Wrapper.displayName = fn.displayName || fn.name;\n  return (forwardRef as forwardRefType)(Wrapper);\n}\n\n/** Returns whether the component is in a hidden subtree. */\nexport function useIsHidden(): boolean {\n  return useContext(HiddenContext);\n}\n"],"mappings":";;;;AAAA;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAOA,mBAAA,KAAwB,aAAa;EAC9C,MAAMC,aAAA,GAAgBC,MAAA,CAAOC,wBAAwB,CAACC,IAAA,CAAKC,SAAS,EAAE,cAAeC,GAAG;EACxFJ,MAAA,CAAOK,cAAc,CAACP,mBAAA,CAAoBK,SAAS,EAAE,cAAc;IACjEG,YAAA,EAAc;IACdC,UAAA,EAAY;IACZH,GAAA,EAAK,SAAAA,CAAA;MACH,IAAI,IAAI,CAACI,OAAO,CAACC,eAAe,EAC9B,OAAO,IAAI,CAACC,OAAO,CAACC,UAAU,MAE9B,OAAOZ,aAAA,CAAca,IAAI,CAAC,IAAI;IAElC;EACF;AACF;AAEO,MAAMC,yCAAA,gBAAgB,IAAAC,oBAAY,EAAW;AAEpD;AACA,MAAMC,oCAAA,GAAiB,OAAOC,gBAAA,KAAqB,cAAc,IAAIA,gBAAA,KAAqB;AAEnF,SAASC,0CAAOC,KAA4B;EACjD,IAAIC,QAAA,GAAW,IAAAC,iBAAS,EAAEP,yCAAA;EAC1B,IAAIQ,KAAA,GAAQ,IAAAC,eAAO;EACnB,IAAIH,QAAA;IACF;IACA,oBAAO,IAAAI,YAAA,EAAAC,aAAA,KAAAD,YAAA,EAAAE,QAAA,QAAGP,KAAA,CAAMQ,QAAQ;EAG1B,IAAIA,QAAA,gBACF,IAAAH,YAAA,EAAAC,aAAA,CAACX,yCAAA,CAAcc,QAAQ;IAACC,KAAA;KACrBV,KAAA,CAAMQ,QAAQ;EAInB;EACA;EACA;EACA,OAAOL,KAAA,gBACH,IAAAE,YAAA,EAAAC,aAAA,CAAC;IAAS;KAAwBE,QAAA,iBAClC,IAAAG,mBAAW,EAAEH,QAAA,EAAUX,oCAAA;AAC7B;AAIO,SAASe,0CAAmCC,EAAwD;EACzG,IAAIC,OAAA,GAAUA,CAACd,KAAA,EAAUe,GAAA;IACvB,IAAId,QAAA,GAAW,IAAAC,iBAAS,EAAEP,yCAAA;IAC1B,IAAIM,QAAA,EACF,OAAO;IAGT,OAAOY,EAAA,CAAGb,KAAA,EAAOe,GAAA;EACnB;EACA;EACAD,OAAA,CAAQE,WAAW,GAAGH,EAAA,CAAGG,WAAW,IAAIH,EAAA,CAAGI,IAAI;EAC/C,OAAO,CAAC,GAAAC,iBAAS,EAAqBJ,OAAA;AACxC;AAGO,SAASK,0CAAA;EACd,OAAO,IAAAjB,iBAAS,EAAEP,yCAAA;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}