{"ast":null,"code":"import $34yyy$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { clamp as $34yyy$clamp, toFixedNumber as $34yyy$toFixedNumber } from \"@react-stately/utils\";\nimport { LocalizedStringDictionary as $34yyy$LocalizedStringDictionary, LocalizedStringFormatter as $34yyy$LocalizedStringFormatter } from \"@internationalized/string\";\nimport { NumberFormatter as $34yyy$NumberFormatter } from \"@internationalized/number\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nlet $799cddbef784668f$var$dictionary = new (0, $34yyy$LocalizedStringDictionary)((0, $parcel$interopDefault($34yyy$intlStringsmodulejs)));\nfunction $799cddbef784668f$export$6e865ea70d7724f(value) {\n  let res = $799cddbef784668f$var$RGBColor.parse(value) || $799cddbef784668f$var$HSBColor.parse(value) || $799cddbef784668f$var$HSLColor.parse(value);\n  if (res) return res;\n  throw new Error('Invalid color value: ' + value);\n}\nfunction $799cddbef784668f$export$4cde5df63f53f473(v) {\n  if (typeof v === 'string') return $799cddbef784668f$export$6e865ea70d7724f(v);else return v;\n}\nfunction $799cddbef784668f$export$1c0c08912582810c(colorSpace) {\n  switch (colorSpace) {\n    case 'rgb':\n      return $799cddbef784668f$var$RGBColor.colorChannels;\n    case 'hsl':\n      return $799cddbef784668f$var$HSLColor.colorChannels;\n    case 'hsb':\n      return $799cddbef784668f$var$HSBColor.colorChannels;\n  }\n}\nfunction $799cddbef784668f$export$87f5012e10bb20b2(hue) {\n  if (hue === 360) return hue;\n  return (hue % 360 + 360) % 360;\n}\n// Lightness threshold between orange and brown.\nconst $799cddbef784668f$var$ORANGE_LIGHTNESS_THRESHOLD = 0.68;\n// Lightness threshold between pure yellow and \"yellow green\".\nconst $799cddbef784668f$var$YELLOW_GREEN_LIGHTNESS_THRESHOLD = 0.85;\n// The maximum lightness considered to be \"dark\".\nconst $799cddbef784668f$var$MAX_DARK_LIGHTNESS = 0.55;\n// The chroma threshold between gray and color.\nconst $799cddbef784668f$var$GRAY_THRESHOLD = 0.001;\nconst $799cddbef784668f$var$OKLCH_HUES = [[0, 'pink'], [15, 'red'], [48, 'orange'], [94, 'yellow'], [135, 'green'], [175, 'cyan'], [264, 'blue'], [284, 'purple'], [320, 'magenta'], [349, 'pink']];\nclass $799cddbef784668f$var$Color {\n  toHexInt() {\n    return this.toFormat('rgb').toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error('Unsupported color channel: ' + channel);\n  }\n  withChannelValue(channel, value) {\n    if (channel in this) {\n      let x = this.clone();\n      x[channel] = value;\n      return x;\n    }\n    throw new Error('Unsupported color channel: ' + channel);\n  }\n  getChannelName(channel, locale) {\n    let strings = (0, $34yyy$LocalizedStringDictionary).getGlobalDictionaryForPackage('@react-stately/color') || $799cddbef784668f$var$dictionary;\n    return strings.getStringForLocale(channel, locale);\n  }\n  getColorSpaceAxes(xyChannels) {\n    let {\n      xChannel: xChannel,\n      yChannel: yChannel\n    } = xyChannels;\n    let xCh = xChannel || this.getColorChannels().find(c => c !== yChannel);\n    let yCh = yChannel || this.getColorChannels().find(c => c !== xCh);\n    let zCh = this.getColorChannels().find(c => c !== xCh && c !== yCh);\n    return {\n      xChannel: xCh,\n      yChannel: yCh,\n      zChannel: zCh\n    };\n  }\n  getColorName(locale) {\n    // Convert to oklch color space, which has perceptually uniform lightness across all hues.\n    let [l, c, h] = $799cddbef784668f$var$toOKLCH(this);\n    let strings = (0, $34yyy$LocalizedStringDictionary).getGlobalDictionaryForPackage('@react-stately/color') || $799cddbef784668f$var$dictionary;\n    if (l > 0.999) return strings.getStringForLocale('white', locale);\n    if (l < 0.001) return strings.getStringForLocale('black', locale);\n    let hue;\n    [hue, l] = this.getOklchHue(l, c, h, locale);\n    let lightness = '';\n    let chroma = '';\n    if (c <= 0.1 && c >= $799cddbef784668f$var$GRAY_THRESHOLD) {\n      if (l >= 0.7) chroma = 'pale';else chroma = 'grayish';\n    } else if (c >= 0.15) chroma = 'vibrant';\n    if (l < 0.3) lightness = 'very dark';else if (l < $799cddbef784668f$var$MAX_DARK_LIGHTNESS) lightness = 'dark';else if (l < 0.7) ;else if (l < 0.85) lightness = 'light';else lightness = 'very light';\n    if (chroma) chroma = strings.getStringForLocale(chroma, locale);\n    if (lightness) lightness = strings.getStringForLocale(lightness, locale);\n    let alpha = this.getChannelValue('alpha');\n    let formatter = new (0, $34yyy$LocalizedStringFormatter)(locale, strings);\n    if (alpha < 1) {\n      let percentTransparent = new (0, $34yyy$NumberFormatter)(locale, {\n        style: 'percent'\n      }).format(1 - alpha);\n      return formatter.format('transparentColorName', {\n        lightness: lightness,\n        chroma: chroma,\n        hue: hue,\n        percentTransparent: percentTransparent\n      }).replace(/\\s+/g, ' ').trim();\n    } else return formatter.format('colorName', {\n      lightness: lightness,\n      chroma: chroma,\n      hue: hue\n    }).replace(/\\s+/g, ' ').trim();\n  }\n  getOklchHue(l, c, h, locale) {\n    let strings = (0, $34yyy$LocalizedStringDictionary).getGlobalDictionaryForPackage('@react-stately/color') || $799cddbef784668f$var$dictionary;\n    if (c < $799cddbef784668f$var$GRAY_THRESHOLD) return [strings.getStringForLocale('gray', locale), l];\n    for (let i = 0; i < $799cddbef784668f$var$OKLCH_HUES.length; i++) {\n      let [hue, hueName] = $799cddbef784668f$var$OKLCH_HUES[i];\n      let [nextHue, nextHueName] = $799cddbef784668f$var$OKLCH_HUES[i + 1] || [360, 'pink'];\n      if (h >= hue && h < nextHue) {\n        // Split orange hue into brown/orange depending on lightness.\n        if (hueName === 'orange') {\n          if (l < $799cddbef784668f$var$ORANGE_LIGHTNESS_THRESHOLD) hueName = 'brown';else\n            // Adjust lightness.\n            l = l - $799cddbef784668f$var$ORANGE_LIGHTNESS_THRESHOLD + $799cddbef784668f$var$MAX_DARK_LIGHTNESS;\n        }\n        // If the hue is at least halfway to the next hue, add the next hue name as well.\n        if (h > hue + (nextHue - hue) / 2 && hueName !== nextHueName) hueName = `${hueName} ${nextHueName}`;else if (hueName === 'yellow' && l < $799cddbef784668f$var$YELLOW_GREEN_LIGHTNESS_THRESHOLD)\n          // Yellow shifts toward green at lower lightnesses.\n          hueName = 'yellow green';\n        let name = strings.getStringForLocale(hueName, locale).toLocaleLowerCase(locale);\n        return [name, l];\n      }\n    }\n    throw new Error('Unexpected hue');\n  }\n  getHueName(locale) {\n    let [l, c, h] = $799cddbef784668f$var$toOKLCH(this);\n    let [name] = this.getOklchHue(l, c, h, locale);\n    return name;\n  }\n}\nclass $799cddbef784668f$var$RGBColor extends $799cddbef784668f$var$Color {\n  static parse(value) {\n    let colors = [];\n    // matching #rgb, #rgba, #rrggbb, #rrggbbaa\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, '$&$&') : value).slice(1).split('');\n      while (values.length > 0) colors.push(parseInt(values.splice(0, 2).join(''), 16));\n      colors[3] = colors[3] !== undefined ? colors[3] / 255 : undefined;\n    }\n    // matching rgb(rrr, ggg, bbb), rgba(rrr, ggg, bbb, 0.a)\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match === null || match === void 0 ? void 0 : match[1]) {\n      colors = match[1].split(',').map(value => Number(value.trim()));\n      colors = colors.map((num, i) => {\n        return (0, $34yyy$clamp)(num !== null && num !== void 0 ? num : 0, 0, i < 3 ? 255 : 1);\n      });\n    }\n    if (colors[0] === undefined || colors[1] === undefined || colors[2] === undefined) return undefined;\n    var _colors_;\n    return colors.length < 3 ? undefined : new $799cddbef784668f$var$RGBColor(colors[0], colors[1], colors[2], (_colors_ = colors[3]) !== null && _colors_ !== void 0 ? _colors_ : 1);\n  }\n  toString(format = 'css') {\n    switch (format) {\n      case 'hex':\n        return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0')).toUpperCase();\n      case 'hexa':\n        return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0') + Math.round(this.alpha * 255).toString(16).padStart(2, '0')).toUpperCase();\n      case 'rgb':\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case 'css':\n      case 'rgba':\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case 'hex':\n      case 'hexa':\n      case 'rgb':\n      case 'rgba':\n        return this;\n      case 'hsb':\n      case 'hsba':\n        return this.toHSB();\n      case 'hsl':\n      case 'hsla':\n        return this.toHSL();\n      default:\n        throw new Error('Unsupported color conversion: rgb -> ' + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n  * Converts an RGB color value to HSB.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n  * @returns An HSBColor object.\n  */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0; // achromatic\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new $799cddbef784668f$var$HSBColor((0, $34yyy$toFixedNumber)(hue * 360, 2), (0, $34yyy$toFixedNumber)(saturation * 100, 2), (0, $34yyy$toFixedNumber)(brightness * 100, 2), this.alpha);\n  }\n  /**\n  * Converts an RGB color value to HSL.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n  * @returns An HSLColor object.\n  */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue;\n    let saturation;\n    if (chroma === 0) hue = saturation = 0; // achromatic\n    else {\n      saturation = chroma / (lightness < .5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n        default:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new $799cddbef784668f$var$HSLColor((0, $34yyy$toFixedNumber)(hue * 360, 2), (0, $34yyy$toFixedNumber)(saturation * 100, 2), (0, $34yyy$toFixedNumber)(lightness * 100, 2), this.alpha);\n  }\n  clone() {\n    return new $799cddbef784668f$var$RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case 'red':\n      case 'green':\n      case 'blue':\n        return {\n          minValue: 0x0,\n          maxValue: 0xFF,\n          step: 0x1,\n          pageSize: 0x11\n        };\n      case 'alpha':\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case 'red':\n      case 'green':\n      case 'blue':\n        return {\n          style: 'decimal'\n        };\n      case 'alpha':\n        return {\n          style: 'percent'\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new (0, $34yyy$NumberFormatter)(locale, options).format(value);\n  }\n  getColorSpace() {\n    return 'rgb';\n  }\n  getColorChannels() {\n    return $799cddbef784668f$var$RGBColor.colorChannels;\n  }\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n}\n$799cddbef784668f$var$RGBColor.colorChannels = ['red', 'green', 'blue'];\n// X = <negative/positive number with/without decimal places>\n// before/after a comma, 0 or more whitespaces are allowed\n// - hsb(X, X%, X%)\n// - hsba(X, X%, X%, X)\nconst $799cddbef784668f$var$HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nclass $799cddbef784668f$var$HSBColor extends $799cddbef784668f$var$Color {\n  static parse(value) {\n    let m;\n    if (m = value.match($799cddbef784668f$var$HSB_REGEX)) {\n      var _m_;\n      const [h, s, b, a] = ((_m_ = m[1]) !== null && _m_ !== void 0 ? _m_ : m[2]).split(',').map(n => Number(n.trim().replace('%', '')));\n      return new $799cddbef784668f$var$HSBColor($799cddbef784668f$export$87f5012e10bb20b2(h), (0, $34yyy$clamp)(s, 0, 100), (0, $34yyy$clamp)(b, 0, 100), (0, $34yyy$clamp)(a !== null && a !== void 0 ? a : 1, 0, 1));\n    }\n  }\n  toString(format = 'css') {\n    switch (format) {\n      case 'css':\n        return this.toHSL().toString('css');\n      case 'hex':\n        return this.toRGB().toString('hex');\n      case 'hexa':\n        return this.toRGB().toString('hexa');\n      case 'hsb':\n        return `hsb(${this.hue}, ${(0, $34yyy$toFixedNumber)(this.saturation, 2)}%, ${(0, $34yyy$toFixedNumber)(this.brightness, 2)}%)`;\n      case 'hsba':\n        return `hsba(${this.hue}, ${(0, $34yyy$toFixedNumber)(this.saturation, 2)}%, ${(0, $34yyy$toFixedNumber)(this.brightness, 2)}%, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case 'hsb':\n      case 'hsba':\n        return this;\n      case 'hsl':\n      case 'hsla':\n        return this.toHSL();\n      case 'rgb':\n      case 'rgba':\n        return this.toRGB();\n      default:\n        throw new Error('Unsupported color conversion: hsb -> ' + format);\n    }\n  }\n  /**\n  * Converts a HSB color to HSL.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n  * @returns An HSLColor object.\n  */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new $799cddbef784668f$var$HSLColor((0, $34yyy$toFixedNumber)(this.hue, 2), (0, $34yyy$toFixedNumber)(saturation * 100, 2), (0, $34yyy$toFixedNumber)(lightness * 100, 2), this.alpha);\n  }\n  /**\n  * Converts a HSV color value to RGB.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n  * @returns An RGBColor object.\n  */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new $799cddbef784668f$var$RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), this.alpha);\n  }\n  clone() {\n    return new $799cddbef784668f$var$HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case 'hue':\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case 'saturation':\n      case 'brightness':\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case 'alpha':\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case 'hue':\n        return {\n          style: 'unit',\n          unit: 'degree',\n          unitDisplay: 'narrow'\n        };\n      case 'saturation':\n      case 'brightness':\n      case 'alpha':\n        return {\n          style: 'percent'\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === 'saturation' || channel === 'brightness') value /= 100;\n    return new (0, $34yyy$NumberFormatter)(locale, options).format(value);\n  }\n  getColorSpace() {\n    return 'hsb';\n  }\n  getColorChannels() {\n    return $799cddbef784668f$var$HSBColor.colorChannels;\n  }\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n}\n$799cddbef784668f$var$HSBColor.colorChannels = ['hue', 'saturation', 'brightness'];\n// X = <negative/positive number with/without decimal places>\n// before/after a comma, 0 or more whitespaces are allowed\n// - hsl(X, X%, X%)\n// - hsla(X, X%, X%, X)\nconst $799cddbef784668f$var$HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nclass $799cddbef784668f$var$HSLColor extends $799cddbef784668f$var$Color {\n  static parse(value) {\n    let m;\n    if (m = value.match($799cddbef784668f$var$HSL_REGEX)) {\n      var _m_;\n      const [h, s, l, a] = ((_m_ = m[1]) !== null && _m_ !== void 0 ? _m_ : m[2]).split(',').map(n => Number(n.trim().replace('%', '')));\n      return new $799cddbef784668f$var$HSLColor($799cddbef784668f$export$87f5012e10bb20b2(h), (0, $34yyy$clamp)(s, 0, 100), (0, $34yyy$clamp)(l, 0, 100), (0, $34yyy$clamp)(a !== null && a !== void 0 ? a : 1, 0, 1));\n    }\n  }\n  toString(format = 'css') {\n    switch (format) {\n      case 'hex':\n        return this.toRGB().toString('hex');\n      case 'hexa':\n        return this.toRGB().toString('hexa');\n      case 'hsl':\n        return `hsl(${this.hue}, ${(0, $34yyy$toFixedNumber)(this.saturation, 2)}%, ${(0, $34yyy$toFixedNumber)(this.lightness, 2)}%)`;\n      case 'css':\n      case 'hsla':\n        return `hsla(${this.hue}, ${(0, $34yyy$toFixedNumber)(this.saturation, 2)}%, ${(0, $34yyy$toFixedNumber)(this.lightness, 2)}%, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case 'hsl':\n      case 'hsla':\n        return this;\n      case 'hsb':\n      case 'hsba':\n        return this.toHSB();\n      case 'rgb':\n      case 'rgba':\n        return this.toRGB();\n      default:\n        throw new Error('Unsupported color conversion: hsl -> ' + format);\n    }\n  }\n  /**\n  * Converts a HSL color to HSB.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n  * @returns An HSBColor object.\n  */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new $799cddbef784668f$var$HSBColor((0, $34yyy$toFixedNumber)(this.hue, 2), (0, $34yyy$toFixedNumber)(saturation * 100, 2), (0, $34yyy$toFixedNumber)(brightness * 100, 2), this.alpha);\n  }\n  /**\n  * Converts a HSL color to RGB.\n  * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n  * @returns An RGBColor object.\n  */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new $799cddbef784668f$var$RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), this.alpha);\n  }\n  clone() {\n    return new $799cddbef784668f$var$HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case 'hue':\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case 'saturation':\n      case 'lightness':\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case 'alpha':\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case 'hue':\n        return {\n          style: 'unit',\n          unit: 'degree',\n          unitDisplay: 'narrow'\n        };\n      case 'saturation':\n      case 'lightness':\n      case 'alpha':\n        return {\n          style: 'percent'\n        };\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === 'saturation' || channel === 'lightness') value /= 100;\n    return new (0, $34yyy$NumberFormatter)(locale, options).format(value);\n  }\n  getColorSpace() {\n    return 'hsl';\n  }\n  getColorChannels() {\n    return $799cddbef784668f$var$HSLColor.colorChannels;\n  }\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n}\n$799cddbef784668f$var$HSLColor.colorChannels = ['hue', 'saturation', 'lightness'];\n// https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction $799cddbef784668f$var$toOKLCH(color) {\n  let rgb = color.toFormat('rgb');\n  let red = rgb.getChannelValue('red') / 255;\n  let green = rgb.getChannelValue('green') / 255;\n  let blue = rgb.getChannelValue('blue') / 255;\n  [red, green, blue] = $799cddbef784668f$var$lin_sRGB(red, green, blue);\n  let [x, y, z] = $799cddbef784668f$var$lin_sRGB_to_XYZ(red, green, blue);\n  let [l, a, b] = $799cddbef784668f$var$XYZ_to_OKLab(x, y, z);\n  return $799cddbef784668f$var$OKLab_to_OKLCH(l, a, b);\n}\nfunction $799cddbef784668f$var$OKLab_to_OKLCH(l, a, b) {\n  var hue = Math.atan2(b, a) * 180 / Math.PI;\n  return [l, Math.sqrt(a ** 2 + b ** 2), hue >= 0 ? hue : hue + 360 // Hue, in degrees [0 to 360)\n  ];\n}\nfunction $799cddbef784668f$var$lin_sRGB(r, g, b) {\n  // convert an array of sRGB values\n  // where in-gamut values are in the range [0 - 1]\n  // to linear light (un-companded) form.\n  // https://en.wikipedia.org/wiki/SRGB\n  // Extended transfer function:\n  // for negative values,  linear portion is extended on reflection of axis,\n  // then reflected power function is used.\n  return [$799cddbef784668f$var$lin_sRGB_component(r), $799cddbef784668f$var$lin_sRGB_component(g), $799cddbef784668f$var$lin_sRGB_component(b)];\n}\nfunction $799cddbef784668f$var$lin_sRGB_component(val) {\n  let sign = val < 0 ? -1 : 1;\n  let abs = Math.abs(val);\n  if (abs <= 0.04045) return val / 12.92;\n  return sign * Math.pow((abs + 0.055) / 1.055, 2.4);\n}\nfunction $799cddbef784668f$var$lin_sRGB_to_XYZ(r, g, b) {\n  // convert an array of linear-light sRGB values to CIE XYZ\n  // using sRGB's own white, D65 (no chromatic adaptation)\n  const M = [506752 / 1228815, 87881 / 245763, 12673 / 70218, 87098 / 409605, 175762 / 245763, 12673 / 175545, 7918 / 409605, 87881 / 737289, 1001167 / 1053270];\n  return $799cddbef784668f$var$multiplyMatrix(M, r, g, b);\n}\nfunction $799cddbef784668f$var$XYZ_to_OKLab(x, y, z) {\n  // Given XYZ relative to D65, convert to OKLab\n  const XYZtoLMS = [0.8190224379967030, 0.3619062600528904, -0.1288737815209879, 0.0329836539323885, 0.9292868615863434, 0.0361446663506424, 0.0481771893596242, 0.2642395317527308, 0.6335478284694309];\n  const LMStoOKLab = [0.2104542683093140, 0.7936177747023054, -0.0040720430116193, 1.9779985324311684, -2.42859224204858, 0.4505937096174110, 0.0259040424655478, 0.7827717124575296, -0.8086757549230774];\n  let [a, b, c] = $799cddbef784668f$var$multiplyMatrix(XYZtoLMS, x, y, z);\n  return $799cddbef784668f$var$multiplyMatrix(LMStoOKLab, Math.cbrt(a), Math.cbrt(b), Math.cbrt(c));\n}\nfunction $799cddbef784668f$var$multiplyMatrix(m, x, y, z) {\n  let a = m[0] * x + m[1] * y + m[2] * z;\n  let b = m[3] * x + m[4] * y + m[5] * z;\n  let c = m[6] * x + m[7] * y + m[8] * z;\n  return [a, b, c];\n}\nexport { $799cddbef784668f$export$6e865ea70d7724f as parseColor, $799cddbef784668f$export$4cde5df63f53f473 as normalizeColor, $799cddbef784668f$export$1c0c08912582810c as getColorChannels, $799cddbef784668f$export$87f5012e10bb20b2 as normalizeHue };","map":{"version":3,"names":["$799cddbef784668f$var$dictionary","$34yyy$LocalizedStringDictionary","$parcel$interopDefault","$34yyy$intlStringsmodulejs","$799cddbef784668f$export$6e865ea70d7724f","value","res","$799cddbef784668f$var$RGBColor","parse","$799cddbef784668f$var$HSBColor","$799cddbef784668f$var$HSLColor","Error","$799cddbef784668f$export$4cde5df63f53f473","v","$799cddbef784668f$export$1c0c08912582810c","colorSpace","colorChannels","$799cddbef784668f$export$87f5012e10bb20b2","hue","$799cddbef784668f$var$ORANGE_LIGHTNESS_THRESHOLD","$799cddbef784668f$var$YELLOW_GREEN_LIGHTNESS_THRESHOLD","$799cddbef784668f$var$MAX_DARK_LIGHTNESS","$799cddbef784668f$var$GRAY_THRESHOLD","$799cddbef784668f$var$OKLCH_HUES","$799cddbef784668f$var$Color","toHexInt","toFormat","getChannelValue","channel","withChannelValue","x","clone","getChannelName","locale","strings","getGlobalDictionaryForPackage","getStringForLocale","getColorSpaceAxes","xyChannels","xChannel","yChannel","xCh","getColorChannels","find","c","yCh","zCh","zChannel","getColorName","l","h","$799cddbef784668f$var$toOKLCH","getOklchHue","lightness","chroma","alpha","formatter","$34yyy$LocalizedStringFormatter","percentTransparent","$34yyy$NumberFormatter","style","format","replace","trim","i","length","hueName","nextHue","nextHueName","name","toLocaleLowerCase","getHueName","colors","test","includes","values","slice","split","push","parseInt","splice","join","undefined","match","map","Number","num","$34yyy$clamp","_colors_","toString","red","padStart","green","blue","toUpperCase","Math","round","toHSB","toHSL","min","brightness","max","saturation","$34yyy$toFixedNumber","getChannelRange","minValue","maxValue","step","pageSize","getChannelFormatOptions","formatChannelValue","options","getColorSpace","constructor","$799cddbef784668f$var$HSB_REGEX","m","_m_","s","b","a","n","toRGB","fn","k","unit","unitDisplay","$799cddbef784668f$var$HSL_REGEX","color","rgb","$799cddbef784668f$var$lin_sRGB","y","z","$799cddbef784668f$var$lin_sRGB_to_XYZ","$799cddbef784668f$var$XYZ_to_OKLab","$799cddbef784668f$var$OKLab_to_OKLCH","atan2","PI","sqrt","r","g","$799cddbef784668f$var$lin_sRGB_component","val","sign","abs","pow","M","$799cddbef784668f$var$multiplyMatrix","XYZtoLMS","LMStoOKLab","cbrt"],"sources":["/Users/oscar.meunier/Documents/Personal/goodreads/node_modules/@react-stately/color/dist/packages/@react-stately/color/src/Color.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, toFixedNumber} from '@react-stately/utils';\nimport {ColorAxes, ColorChannel, ColorChannelRange, ColorFormat, ColorSpace, Color as IColor} from '@react-types/color';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {LocalizedStringDictionary, LocalizedStringFormatter} from '@internationalized/string';\nimport {NumberFormatter} from '@internationalized/number';\n\nlet dictionary = new LocalizedStringDictionary(intlMessages);\n\n/** Parses a color from a string value. Throws an error if the string could not be parsed. */\nexport function parseColor(value: string): IColor {\n  let res = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (res) {\n    return res;\n  }\n\n  throw new Error('Invalid color value: ' + value);\n}\n\nexport function normalizeColor(v: string | IColor) {\n  if (typeof v === 'string') {\n    return parseColor(v);\n  } else {\n    return v;\n  }\n}\n\n/** Returns a list of color channels for a given color space. */\nexport function getColorChannels(colorSpace: ColorSpace) {\n  switch (colorSpace) {\n    case 'rgb':\n      return RGBColor.colorChannels;\n    case 'hsl':\n      return HSLColor.colorChannels;\n    case 'hsb':\n      return HSBColor.colorChannels;\n  }\n}\n\n/**\n * Returns the hue value normalized to the range of 0 to 360.\n */\nexport function normalizeHue(hue: number) {\n  if (hue === 360) {\n    return hue;\n  }\n\n  return ((hue % 360) + 360) % 360;\n}\n\n// Lightness threshold between orange and brown.\nconst ORANGE_LIGHTNESS_THRESHOLD = 0.68;\n// Lightness threshold between pure yellow and \"yellow green\".\nconst YELLOW_GREEN_LIGHTNESS_THRESHOLD = 0.85;\n// The maximum lightness considered to be \"dark\".\nconst MAX_DARK_LIGHTNESS = 0.55;\n// The chroma threshold between gray and color.\nconst GRAY_THRESHOLD = 0.001;\nconst OKLCH_HUES: [number, string][] = [\n  [0, 'pink'],\n  [15, 'red'],\n  [48, 'orange'],\n  [94, 'yellow'],\n  [135, 'green'],\n  [175, 'cyan'],\n  [264, 'blue'],\n  [284, 'purple'],\n  [320, 'magenta'],\n  [349, 'pink']\n];\n\nabstract class Color implements IColor {\n  abstract toFormat(format: ColorFormat): IColor;\n  abstract toString(format: ColorFormat | 'css'): string;\n  abstract clone(): IColor;\n  abstract getChannelRange(channel: ColorChannel): ColorChannelRange;\n  abstract getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions;\n  abstract formatChannelValue(channel: ColorChannel, locale: string): string;\n\n  toHexInt(): number {\n    return this.toFormat('rgb').toHexInt();\n  }\n\n  getChannelValue(channel: ColorChannel): number {\n    if (channel in this) {\n      return this[channel];\n    }\n\n    throw new Error('Unsupported color channel: ' + channel);\n  }\n\n  withChannelValue(channel: ColorChannel, value: number): IColor {\n    if (channel in this) {\n      let x = this.clone();\n      x[channel] = value;\n      return x;\n    }\n\n    throw new Error('Unsupported color channel: ' + channel);\n  }\n\n  getChannelName(channel: ColorChannel, locale: string) {\n    let strings = LocalizedStringDictionary.getGlobalDictionaryForPackage('@react-stately/color') || dictionary;\n    return strings.getStringForLocale(channel, locale);\n  }\n\n  abstract getColorSpace(): ColorSpace;\n\n  getColorSpaceAxes(xyChannels: {xChannel?: ColorChannel, yChannel?: ColorChannel}): ColorAxes {\n    let {xChannel, yChannel} = xyChannels;\n    let xCh = xChannel || this.getColorChannels().find(c => c !== yChannel)!;\n    let yCh = yChannel || this.getColorChannels().find(c => c !== xCh)!;\n    let zCh = this.getColorChannels().find(c => c !== xCh && c !== yCh)!;\n\n    return {xChannel: xCh, yChannel: yCh, zChannel: zCh};\n  }\n\n  abstract getColorChannels(): [ColorChannel, ColorChannel, ColorChannel]\n\n  getColorName(locale: string): string {\n    // Convert to oklch color space, which has perceptually uniform lightness across all hues.\n    let [l, c, h] = toOKLCH(this);\n\n    let strings = LocalizedStringDictionary.getGlobalDictionaryForPackage('@react-stately/color') || dictionary;\n    if (l > 0.999) {\n      return strings.getStringForLocale('white', locale);\n    }\n\n    if (l < 0.001) {\n      return strings.getStringForLocale('black', locale);\n    }\n\n    let hue: string;\n    [hue, l] = this.getOklchHue(l, c, h, locale);\n\n    let lightness = '';\n    let chroma = '';\n    if (c <= 0.1 && c >= GRAY_THRESHOLD) {\n      if (l >= 0.7) {\n        chroma = 'pale';\n      } else {\n        chroma = 'grayish';\n      }\n    } else if (c >= 0.15) {\n      chroma = 'vibrant';\n    }\n\n    if (l < 0.3) {\n      lightness = 'very dark';\n    } else if (l < MAX_DARK_LIGHTNESS) {\n      lightness = 'dark';\n    } else if (l < 0.7) {\n      // none\n    } else if (l < 0.85) {\n      lightness = 'light';\n    } else {\n      lightness = 'very light';\n    }\n\n    if (chroma) {\n      chroma = strings.getStringForLocale(chroma, locale);\n    }\n\n    if (lightness) {\n      lightness = strings.getStringForLocale(lightness, locale);\n    }\n\n    let alpha = this.getChannelValue('alpha');\n    let formatter = new LocalizedStringFormatter(locale, strings);\n    if (alpha < 1) {\n      let percentTransparent = new NumberFormatter(locale, {style: 'percent'}).format(1 - alpha);\n      return formatter.format('transparentColorName', {\n        lightness,\n        chroma,\n        hue,\n        percentTransparent\n      }).replace(/\\s+/g, ' ').trim();\n    } else {\n      return formatter.format('colorName', {\n        lightness,\n        chroma,\n        hue\n      }).replace(/\\s+/g, ' ').trim();\n    }\n  }\n\n  private getOklchHue(l: number, c: number, h: number, locale: string): [string, number] {\n    let strings = LocalizedStringDictionary.getGlobalDictionaryForPackage('@react-stately/color') || dictionary;\n    if (c < GRAY_THRESHOLD) {\n      return [strings.getStringForLocale('gray', locale), l];\n    }\n\n    for (let i = 0; i < OKLCH_HUES.length; i++) {\n      let [hue, hueName] = OKLCH_HUES[i];\n      let [nextHue, nextHueName] = OKLCH_HUES[i + 1] || [360, 'pink'];\n      if (h >= hue && h < nextHue) {\n        // Split orange hue into brown/orange depending on lightness.\n        if (hueName === 'orange') {\n          if (l < ORANGE_LIGHTNESS_THRESHOLD) {\n            hueName = 'brown';\n          } else {\n            // Adjust lightness.\n            l = (l - ORANGE_LIGHTNESS_THRESHOLD) + MAX_DARK_LIGHTNESS;\n          }\n        }\n\n        // If the hue is at least halfway to the next hue, add the next hue name as well.\n        if (h > hue + (nextHue - hue) / 2 && hueName !== nextHueName) {\n          hueName = `${hueName} ${nextHueName}`;\n        } else if (hueName === 'yellow' && l < YELLOW_GREEN_LIGHTNESS_THRESHOLD) {\n          // Yellow shifts toward green at lower lightnesses.\n          hueName = 'yellow green';\n        }\n\n        let name = strings.getStringForLocale(hueName, locale).toLocaleLowerCase(locale);\n        return [name, l];\n      }\n    }\n\n    throw new Error('Unexpected hue');\n  }\n\n  getHueName(locale: string): string {\n    let [l, c, h] = toOKLCH(this);\n    let [name] = this.getOklchHue(l, c, h, locale);\n    return name;\n  }\n}\n\nclass RGBColor extends Color {\n  constructor(private red: number, private green: number, private blue: number, private alpha: number) {\n    super();\n  }\n\n  static parse(value: string) {\n    let colors: Array<number | undefined> = [];\n    // matching #rgb, #rgba, #rrggbb, #rrggbbaa\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, '$&$&') : value).slice(1).split('');\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(''), 16));\n      }\n      colors[3] = colors[3] !== undefined ? colors[3] / 255 : undefined;\n    }\n\n    // matching rgb(rrr, ggg, bbb), rgba(rrr, ggg, bbb, 0.a)\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match?.[1]) {\n      colors = match[1].split(',').map(value => Number(value.trim()));\n      colors = colors.map((num, i) => {\n        return clamp(num ?? 0, 0, i < 3 ? 255 : 1);\n      });\n    }\n    if (colors[0] === undefined || colors[1] === undefined || colors[2] === undefined) {\n      return undefined;\n    }\n\n    return colors.length < 3 ? undefined : new RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n\n  toString(format: ColorFormat | 'css' = 'css') {\n    switch (format) {\n      case 'hex':\n        return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0')).toUpperCase();\n      case 'hexa':\n        return '#' + (this.red.toString(16).padStart(2, '0') + this.green.toString(16).padStart(2, '0') + this.blue.toString(16).padStart(2, '0') + Math.round(this.alpha * 255).toString(16).padStart(2, '0')).toUpperCase();\n      case 'rgb':\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case 'css':\n      case 'rgba':\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n\n  toFormat(format: ColorFormat): IColor {\n    switch (format) {\n      case 'hex':\n      case 'hexa':\n      case 'rgb':\n      case 'rgba':\n        return this;\n      case 'hsb':\n      case 'hsba':\n        return this.toHSB();\n      case 'hsl':\n      case 'hsla':\n        return this.toHSL();\n      default:\n        throw new Error('Unsupported color conversion: rgb -> ' + format);\n    }\n  }\n\n  toHexInt(): number {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  private toHSB(): IColor {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0; // achromatic\n\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    return new HSBColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      this.alpha\n    );\n  }\n\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  private toHSL(): IColor {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue: number;\n    let saturation: number;\n\n    if (chroma === 0) {\n      hue = saturation = 0; // achromatic\n    } else {\n      saturation = chroma / (lightness < .5 ? max + min : 2 - max - min);\n\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n        default:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    return new HSLColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      this.alpha);\n  }\n\n  clone(): IColor {\n    return new RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case 'red':\n      case 'green':\n      case 'blue':\n        return {minValue: 0x0, maxValue: 0xFF, step: 0x1, pageSize: 0x11};\n      case 'alpha':\n        return {minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case 'red':\n      case 'green':\n      case 'blue':\n        return {style: 'decimal'};\n      case 'alpha':\n        return {style: 'percent'};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new NumberFormatter(locale, options).format(value);\n  }\n\n  getColorSpace(): ColorSpace {\n    return 'rgb';\n  }\n\n  static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = ['red', 'green', 'blue'];\n  getColorChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return RGBColor.colorChannels;\n  }\n}\n\n// X = <negative/positive number with/without decimal places>\n// before/after a comma, 0 or more whitespaces are allowed\n// - hsb(X, X%, X%)\n// - hsba(X, X%, X%, X)\nconst HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\n\nclass HSBColor extends Color {\n  constructor(private hue: number, private saturation: number, private brightness: number, private alpha: number) {\n    super();\n  }\n\n  static parse(value: string): HSBColor | void {\n    let m: RegExpMatchArray | null;\n    if ((m = value.match(HSB_REGEX))) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(',').map(n => Number(n.trim().replace('%', '')));\n      return new HSBColor(normalizeHue(h), clamp(s, 0, 100), clamp(b, 0, 100), clamp(a ?? 1, 0, 1));\n    }\n  }\n\n  toString(format: ColorFormat | 'css' = 'css') {\n    switch (format) {\n      case 'css':\n        return this.toHSL().toString('css');\n      case 'hex':\n        return this.toRGB().toString('hex');\n      case 'hexa':\n        return this.toRGB().toString('hexa');\n      case 'hsb':\n        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;\n      case 'hsba':\n        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n\n  toFormat(format: ColorFormat): IColor {\n    switch (format) {\n      case 'hsb':\n      case 'hsba':\n        return this;\n      case 'hsl':\n      case 'hsla':\n        return this.toHSL();\n      case 'rgb':\n      case 'rgba':\n        return this.toRGB();\n      default:\n        throw new Error('Unsupported color conversion: hsb -> ' + format);\n    }\n  }\n\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  private toHSL(): IColor {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n\n    return new HSLColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n        toFixedNumber(lightness * 100, 2),\n      this.alpha\n    );\n  }\n\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  private toRGB(): IColor {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n: number, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(\n      Math.round(fn(5) * 255),\n      Math.round(fn(3) * 255),\n      Math.round(fn(1) * 255),\n      this.alpha\n    );\n  }\n\n  clone(): IColor {\n    return new HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case 'hue':\n        return {minValue: 0, maxValue: 360, step: 1, pageSize: 15};\n      case 'saturation':\n      case 'brightness':\n        return {minValue: 0, maxValue: 100, step: 1, pageSize: 10};\n      case 'alpha':\n        return {minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case 'hue':\n        return {style: 'unit', unit: 'degree', unitDisplay: 'narrow'};\n      case 'saturation':\n      case 'brightness':\n      case 'alpha':\n        return {style: 'percent'};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === 'saturation' || channel === 'brightness') {\n      value /= 100;\n    }\n    return new NumberFormatter(locale, options).format(value);\n  }\n\n  getColorSpace(): ColorSpace {\n    return 'hsb';\n  }\n\n  static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = ['hue', 'saturation', 'brightness'];\n  getColorChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return HSBColor.colorChannels;\n  }\n}\n\n// X = <negative/positive number with/without decimal places>\n// before/after a comma, 0 or more whitespaces are allowed\n// - hsl(X, X%, X%)\n// - hsla(X, X%, X%, X)\nconst HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\n\nclass HSLColor extends Color {\n  constructor(private hue: number, private saturation: number, private lightness: number, private alpha: number) {\n    super();\n  }\n\n  static parse(value: string): HSLColor | void {\n    let m: RegExpMatchArray | null;\n    if ((m = value.match(HSL_REGEX))) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(',').map(n => Number(n.trim().replace('%', '')));\n      return new HSLColor(normalizeHue(h), clamp(s, 0, 100), clamp(l, 0, 100), clamp(a ?? 1, 0, 1));\n    }\n  }\n\n  toString(format: ColorFormat | 'css' = 'css') {\n    switch (format) {\n      case 'hex':\n        return this.toRGB().toString('hex');\n      case 'hexa':\n        return this.toRGB().toString('hexa');\n      case 'hsl':\n        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;\n      case 'css':\n      case 'hsla':\n        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format: ColorFormat): IColor {\n    switch (format) {\n      case 'hsl':\n      case 'hsla':\n        return this;\n      case 'hsb':\n      case 'hsba':\n        return this.toHSB();\n      case 'rgb':\n      case 'rgba':\n        return this.toRGB();\n      default:\n        throw new Error('Unsupported color conversion: hsl -> ' + format);\n    }\n  }\n\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  private toHSB(): IColor {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      this.alpha\n    );\n  }\n\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  private toRGB(): IColor {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n: number, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(\n      Math.round(fn(0) * 255),\n      Math.round(fn(8) * 255),\n      Math.round(fn(4) * 255),\n      this.alpha\n    );\n  }\n\n  clone(): IColor {\n    return new HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case 'hue':\n        return {minValue: 0, maxValue: 360, step: 1, pageSize: 15};\n      case 'saturation':\n      case 'lightness':\n        return {minValue: 0, maxValue: 100, step: 1, pageSize: 10};\n      case 'alpha':\n        return {minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case 'hue':\n        return {style: 'unit', unit: 'degree', unitDisplay: 'narrow'};\n      case 'saturation':\n      case 'lightness':\n      case 'alpha':\n        return {style: 'percent'};\n      default:\n        throw new Error('Unknown color channel: ' + channel);\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === 'saturation' || channel === 'lightness') {\n      value /= 100;\n    }\n    return new NumberFormatter(locale, options).format(value);\n  }\n\n  getColorSpace(): ColorSpace {\n    return 'hsl';\n  }\n\n  static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = ['hue', 'saturation', 'lightness'];\n  getColorChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return HSLColor.colorChannels;\n  }\n}\n\n// https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction toOKLCH(color: Color) {\n  let rgb = color.toFormat('rgb');\n  let red = rgb.getChannelValue('red') / 255;\n  let green = rgb.getChannelValue('green') / 255;\n  let blue = rgb.getChannelValue('blue') / 255;\n  [red, green, blue] = lin_sRGB(red, green, blue);\n  let [x, y, z] = lin_sRGB_to_XYZ(red, green, blue);\n  let [l, a, b] = XYZ_to_OKLab(x, y, z);\n  return OKLab_to_OKLCH(l, a, b);\n}\n\nfunction OKLab_to_OKLCH(l: number, a: number, b: number): [number, number, number] {\n  var hue = Math.atan2(b, a) * 180 / Math.PI;\n  return [\n    l,\n    Math.sqrt(a ** 2 + b ** 2), // Chroma\n    hue >= 0 ? hue : hue + 360 // Hue, in degrees [0 to 360)\n  ];\n}\n\nfunction lin_sRGB(r: number, g: number, b: number): [number, number, number] {\n  // convert an array of sRGB values\n  // where in-gamut values are in the range [0 - 1]\n  // to linear light (un-companded) form.\n  // https://en.wikipedia.org/wiki/SRGB\n  // Extended transfer function:\n  // for negative values,  linear portion is extended on reflection of axis,\n  // then reflected power function is used.\n  return [lin_sRGB_component(r), lin_sRGB_component(g), lin_sRGB_component(b)];\n}\n\nfunction lin_sRGB_component(val: number) {\n  let sign = val < 0 ? -1 : 1;\n  let abs = Math.abs(val);\n\n  if (abs <= 0.04045) {\n    return val / 12.92;\n  }\n\n  return sign * (Math.pow((abs + 0.055) / 1.055, 2.4));\n}\n\nfunction lin_sRGB_to_XYZ(r: number, g: number, b: number) {\n  // convert an array of linear-light sRGB values to CIE XYZ\n  // using sRGB's own white, D65 (no chromatic adaptation)\n  const M = [\n    506752 / 1228815, 87881 / 245763,  12673 / 70218,\n    87098 / 409605,   175762 / 245763, 12673 / 175545,\n    7918 / 409605,    87881 / 737289,  1001167 / 1053270\n  ];\n  return multiplyMatrix(M, r, g, b);\n}\n\nfunction XYZ_to_OKLab(x: number, y: number, z: number) {\n  // Given XYZ relative to D65, convert to OKLab\n  const XYZtoLMS = [\n    0.8190224379967030, 0.3619062600528904, -0.1288737815209879,\n    0.0329836539323885, 0.9292868615863434,  0.0361446663506424,\n    0.0481771893596242, 0.2642395317527308,  0.6335478284694309\n  ];\n  const LMStoOKLab = [\n    0.2104542683093140,  0.7936177747023054, -0.0040720430116193,\n    1.9779985324311684, -2.4285922420485799,  0.4505937096174110,\n    0.0259040424655478,  0.7827717124575296, -0.8086757549230774\n  ];\n\n  let [a, b, c] = multiplyMatrix(XYZtoLMS, x, y, z);\n  return multiplyMatrix(LMStoOKLab, Math.cbrt(a), Math.cbrt(b), Math.cbrt(c));\n}\n\nfunction multiplyMatrix(m: number[], x: number, y: number, z: number): [number, number, number] {\n  let a = m[0] * x + m[1] * y + m[2] * z;\n  let b = m[3] * x + m[4] * y + m[5] * z;\n  let c = m[6] * x + m[7] * y + m[8] * z;\n  return [a, b, c];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}